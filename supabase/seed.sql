-- ============================================
-- Seed: All 28 lessons across 5 phases
-- Auto-generated by scripts/generate-seed.js
-- ============================================

-- Clear existing data (in reverse dependency order)
DELETE FROM exercises;
DELETE FROM lessons;

-- ============================================
-- Lesson 1: Hello MATLAB
-- ============================================
INSERT INTO lessons (id, phase, order_num, title, description, difficulty, estimated_minutes, content_md)
VALUES (1, 1, 1, 'Hello MATLAB',
  'Your very first MATLAB commands — displaying text, basic arithmetic, and understanding the command window.',
  'beginner', 20,
  '# Hello MATLAB!

Welcome to your MATLAB journey! MATLAB (short for **MAT**rix **LAB**oratory) is a powerful tool used by scientists all over the world to analyze data — including brain signals from EEG experiments.

Don''t worry if you''ve never written code before. We''ll start from the very basics.

## Your First Command

The simplest thing you can do in MATLAB is display text on the screen. Try this:

```matlab
disp(''Hello, Neuroscience!'')
```

`disp` is short for **display**. It shows whatever you put inside the parentheses.

## Basic Math

MATLAB is like a powerful calculator. Try these:

```matlab
2 + 3
10 - 4
5 * 3
20 / 4
2 ^ 3
```

The `^` symbol means "to the power of" — so `2^3` means 2 × 2 × 2 = 8.

## Semicolons: To Show or Not to Show

Notice what happens when you add a semicolon `;` at the end:

```matlab
5 + 3      % This shows the result: 8
5 + 3;     % This runs silently (no output shown)
```

The `%` symbol starts a **comment** — text that MATLAB ignores. It''s for your own notes.

## The `disp` Function

You can display numbers too:

```matlab
disp(42)
disp(3.14159)
```

And you can combine text with numbers using `num2str`:

```matlab
age = 25;
disp([''I am '' num2str(age) '' years old''])
```

## Why This Matters for Neuroscience

Every analysis you''ll do — loading EEG data, filtering brain signals, calculating frequencies — starts with these basic commands. Think of this as learning the alphabet before writing stories about the brain!');

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (1, 1, 'Display a greeting',
  'Use the `disp` function to display the text: Hello, World!',
  '% Display ''Hello, World!'' below
',
  'disp(''Hello, World!'')',
  '["The disp function takes something inside parentheses and shows it on screen.","Text (called a ''string'') needs to be wrapped in single quotes: ''like this''","The answer looks like: disp(''...'')"]',
  '[{"expected_output":"Hello, World!\n"}]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (1, 2, 'Brain math',
  'The human brain has approximately 86 billion neurons. Each neuron can have up to 10,000 connections (synapses). Calculate the total number of possible synapses and display it.

Hint: 86 billion = 86e9 (scientific notation), and 10000 connections each.',
  '% Calculate total synapses
neurons = 86e9;
connections_per_neuron = 10000;

% Calculate and display the total
',
  'neurons = 86e9;
connections_per_neuron = 10000;
total_synapses = neurons * connections_per_neuron;
disp(total_synapses)',
  '["Multiply the number of neurons by the connections per neuron.","Store the result in a variable: total_synapses = neurons * connections_per_neuron","Then display it: disp(total_synapses)"]',
  '[{"expected_output":"860000000000000\n"}]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (1, 3, 'Silent calculation',
  'Calculate 2 to the power of 10 and store it in a variable called `result`, but do NOT show the intermediate calculation. Only display the final answer using `disp`.

Remember: adding a semicolon `;` suppresses output.',
  '% Calculate 2^10 silently, then display it
',
  'result = 2^10;
disp(result)',
  '["Use the ^ operator for exponents: 2^10","Add a semicolon after the assignment to suppress output: result = 2^10;","Then use disp(result) to show just the final answer"]',
  '[{"expected_output":"1024\n"}]',
  false);


-- ============================================
-- Lesson 2: Variables & Types
-- ============================================
INSERT INTO lessons (id, phase, order_num, title, description, difficulty, estimated_minutes, content_md)
VALUES (2, 1, 2, 'Variables & Types',
  'Learn to store data in variables — numbers, text, and logical values. The building blocks of every program.',
  'beginner', 25,
  '# Variables & Types

Imagine you''re running a meditation experiment. You need to keep track of things like the participant''s name, their heart rate, and whether they completed the session. In MATLAB, we use **variables** to store these pieces of information.

## Creating Variables

A variable is like a labeled box where you store data:

```matlab
age = 25
name = ''Priya''
heartRate = 72.5
```

The `=` sign means "store this value in this variable." It does NOT mean "equals" in the math sense.

## Variable Naming Rules

- Must start with a letter
- Can contain letters, numbers, and underscores
- Case-sensitive: `Age` and `age` are different variables!
- No spaces allowed: use `heart_rate` or `heartRate`

## Types of Data

MATLAB handles different types of data:

### Numbers (doubles)
```matlab
sampling_rate = 256;      % Hz — samples per second in EEG
temperature = 36.6;       % Body temperature
negative_value = -5;
```

### Text (strings/character arrays)
```matlab
participant = ''Subject_01'';
condition = ''meditation'';
```

### Logical (true/false)
```matlab
is_meditating = true;
completed_session = false;
```

## Checking Your Variables

Use `whos` to see all your variables:
```matlab
whos
```

Use `class()` to check a variable''s type:
```matlab
x = 42;
class(x)    % Returns ''double''
```

## Overwriting Variables

You can change a variable''s value anytime:
```matlab
count = 1;
count = count + 1;   % Now count is 2
count = count + 1;   % Now count is 3
```

## Why This Matters

When you analyze EEG data, every measurement gets stored in a variable. The sampling rate, electrode positions, signal voltages — they''re all variables. Mastering this is essential!');

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (2, 1, 'Store experiment data',
  'You''re setting up an EEG experiment. Create three variables:
- `subject_name` storing the text ''Participant_01''
- `sampling_rate` storing the number 256
- `duration_minutes` storing the number 30

Then display each one using `disp`.',
  '% Create your experiment variables


% Display each variable
',
  'subject_name = ''Participant_01'';
sampling_rate = 256;
duration_minutes = 30;
disp(subject_name)
disp(sampling_rate)
disp(duration_minutes)',
  '["Text values go in single quotes: ''like this''","Numbers don''t need quotes: sampling_rate = 256;","Use disp(variable_name) for each one"]',
  '[{"expected_output":"Participant_01\n256\n30\n"}]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (2, 2, 'Calculate total samples',
  'In an EEG experiment, the total number of data points (samples) equals:

total_samples = sampling_rate × duration_in_seconds

Given:
- sampling_rate = 256 (samples per second)
- duration_minutes = 10

First convert minutes to seconds, then calculate total_samples. Display the result.',
  'sampling_rate = 256;
duration_minutes = 10;

% Convert to seconds


% Calculate total samples


% Display the result
',
  'sampling_rate = 256;
duration_minutes = 10;
duration_seconds = duration_minutes * 60;
total_samples = sampling_rate * duration_seconds;
disp(total_samples)',
  '["To convert minutes to seconds, multiply by 60","duration_seconds = duration_minutes * 60","Then: total_samples = sampling_rate * duration_seconds"]',
  '[{"expected_output":"153600\n"}]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (2, 3, 'Update a counter',
  'Simulate counting meditation sessions. Start with `sessions = 0`. Then increment it by 1 three times (each line adds 1 to the current value). Display the final count.',
  'sessions = 0;

% Increment sessions three times


% Display the final count
',
  'sessions = 0;
sessions = sessions + 1;
sessions = sessions + 1;
sessions = sessions + 1;
disp(sessions)',
  '["To add 1 to a variable: sessions = sessions + 1","Do this three times on separate lines","The final value should be 3"]',
  '[{"expected_output":"3\n"}]',
  false);


-- ============================================
-- Lesson 3: Arrays & Matrices
-- ============================================
INSERT INTO lessons (id, phase, order_num, title, description, difficulty, estimated_minutes, content_md)
VALUES (3, 1, 3, 'Arrays & Matrices',
  'The heart of MATLAB — creating and working with arrays and matrices. Essential for handling EEG channel data.',
  'beginner', 35,
  '# Arrays & Matrices

MATLAB was literally built for matrices (it''s in the name!). An **array** is a list of numbers, and a **matrix** is a grid of numbers. When you work with EEG data, each electrode channel gives you an array of voltage readings over time.

## Creating Arrays (Vectors)

A **row vector** — numbers in a horizontal line:
```matlab
eeg_channel = [1.2, 3.4, 2.1, 5.6, 4.3]
```

A **column vector** — numbers in a vertical line:
```matlab
electrodes = [1; 2; 3; 4; 5]
```

## Quick Ways to Create Arrays

### Using the colon operator `:` 
```matlab
x = 1:5           % [1 2 3 4 5]
x = 0:0.5:2        % [0 0.5 1.0 1.5 2.0] — start:step:end
x = 10:-2:0        % [10 8 6 4 2 0] — counting backwards
```

### Using `linspace`
```matlab
t = linspace(0, 1, 5)   % 5 evenly spaced points from 0 to 1
% Result: [0 0.25 0.5 0.75 1.0]
```

### Using built-in functions
```matlab
z = zeros(1, 5)    % [0 0 0 0 0]
o = ones(1, 5)      % [1 1 1 1 1]
r = rand(1, 5)      % 5 random numbers between 0 and 1
```

## Accessing Elements (Indexing)

MATLAB counts from **1** (not 0 like some languages):
```matlab
data = [10 20 30 40 50];
data(1)        % 10 — first element
data(3)        % 30 — third element
data(end)      % 50 — last element
data(2:4)      % [20 30 40] — elements 2 through 4
```

## Array Math

MATLAB does math on entire arrays at once — no loops needed!
```matlab
raw_signal = [1.2 3.4 2.1 5.6 4.3];
scaled = raw_signal * 1000;     % Multiply every element by 1000
shifted = raw_signal - mean(raw_signal);  % Subtract the average
```

## Useful Array Functions
```matlab
length(data)   % Number of elements
size(data)     % Dimensions [rows, columns]
sum(data)      % Sum of all elements
mean(data)     % Average
max(data)      % Largest value
min(data)      % Smallest value
sort(data)     % Sort in ascending order
```

## Matrices (2D Arrays)

A matrix is like a spreadsheet — rows and columns:
```matlab
% 3 electrodes, 4 time points each
eeg_data = [1.2 3.4 2.1 5.6;
            0.8 2.9 1.7 4.2;
            1.5 3.8 2.4 6.1];

eeg_data(2, 3)     % Row 2, Column 3 = 1.7
eeg_data(1, :)     % Entire first row
eeg_data(:, 2)     % Entire second column
```

## Why This Matters

EEG data is fundamentally a matrix: **channels × time points**. A 64-channel EEG recording at 256 Hz for 10 seconds gives you a 64 × 2560 matrix. Everything you learn here applies directly to that data!');

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (3, 1, 'Create a time vector',
  'Create a time vector `t` that goes from 0 to 1 second with a step of 0.1 seconds (using the colon operator). Then display it.',
  '% Create time vector from 0 to 1 with step 0.1


% Display it
',
  't = 0:0.1:1;
disp(t)',
  '["The colon operator syntax is start:step:end","For 0 to 1 with step 0.1: t = 0:0.1:1","Then use disp(t) to show the result"]',
  '[{"expected_output":"   0   0.1000   0.2000   0.3000   0.4000   0.5000   0.6000   0.7000   0.8000   0.9000   1.0000\n"}]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (3, 2, 'EEG channel statistics',
  'Given an EEG channel recording:

`signal = [2.3, -1.5, 4.2, 0.8, -3.1, 5.7, 1.2, -0.4]`

Calculate and display:
1. The mean (average) voltage
2. The maximum voltage
3. The minimum voltage

Use `disp` to show each value on a separate line.',
  'signal = [2.3, -1.5, 4.2, 0.8, -3.1, 5.7, 1.2, -0.4];

% Calculate and display the mean


% Calculate and display the maximum


% Calculate and display the minimum
',
  'signal = [2.3, -1.5, 4.2, 0.8, -3.1, 5.7, 1.2, -0.4];
disp(mean(signal))
disp(max(signal))
disp(min(signal))',
  '["Use the built-in functions: mean(), max(), min()","You can put the function call directly inside disp: disp(mean(signal))","The mean of this signal should be about 1.15"]',
  '[{"expected_output":"1.1500\n5.7000\n-3.1000\n"}]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (3, 3, 'Extract brain wave data',
  'Given a matrix where each row is an electrode and each column is a time point:

```
eeg = [1.2 3.4 2.1 5.6; 0.8 2.9 1.7 4.2; 1.5 3.8 2.4 6.1];
```

Extract and display:
1. The entire second row (electrode 2''s data)
2. The value at row 3, column 4
3. All values in column 1 (all electrodes at time point 1)',
  'eeg = [1.2 3.4 2.1 5.6; 0.8 2.9 1.7 4.2; 1.5 3.8 2.4 6.1];

% Display entire second row


% Display value at row 3, column 4


% Display all values in column 1
',
  'eeg = [1.2 3.4 2.1 5.6; 0.8 2.9 1.7 4.2; 1.5 3.8 2.4 6.1];
disp(eeg(2, :))
disp(eeg(3, 4))
disp(eeg(:, 1))',
  '["Use (row, column) to index a matrix. The colon : means ''all''.","Entire row 2: eeg(2, :) — row 2, all columns","Single value: eeg(3, 4) — row 3, column 4. All of column 1: eeg(:, 1)"]',
  '[{"expected_output":"   0.8000   2.9000   1.7000   4.2000\n6.1000\n   1.2000\n   0.8000\n   1.5000\n"}]',
  false);


-- ============================================
-- Lesson 4: Control Flow
-- ============================================
INSERT INTO lessons (id, phase, order_num, title, description, difficulty, estimated_minutes, content_md)
VALUES (4, 1, 4, 'Control Flow',
  'Making decisions and repeating actions — using if/else, for loops, and while loops to process brain data.',
  'beginner', 30,
  '# Control Flow

So far, our code has run line by line from top to bottom. But real neuroscience analysis needs **decisions** and **repetition**. Should we flag this signal as a spike? Should we process all 64 EEG channels? Control flow lets your code think and repeat.

## If / Else: Making Decisions

The `if` statement checks whether something is true, and runs code only when it is:

```matlab
voltage = 85;

if voltage > 80
    disp(''Spike detected!'')
end
```

You can add `else` for when the condition is false:

```matlab
voltage = 45;

if voltage > 80
    disp(''Spike detected!'')
else
    disp(''No spike'')
end
```

And `elseif` for multiple conditions:

```matlab
voltage = 65;

if voltage > 80
    disp(''Strong spike'')
elseif voltage > 50
    disp(''Weak spike'')
else
    disp(''No spike'')
end
```

### Comparison Operators
| Operator | Meaning |
|---|---|
| `>` | Greater than |
| `<` | Less than |
| `>=` | Greater than or equal |
| `<=` | Less than or equal |
| `==` | Equal to (two equals signs!) |
| `~=` | Not equal to |

## For Loops: Repeating a Fixed Number of Times

A `for` loop repeats code a set number of times. This is perfect for processing each EEG channel one by one:

```matlab
channels = [12.3, 45.6, 78.9, 23.4];

for i = 1:length(channels)
    disp(channels(i))
end
```

The variable `i` takes the values 1, 2, 3, 4 in turn. Each time through the loop, we do something with `channels(i)`.

Here''s a classic example — adding up numbers:

```matlab
data = [10, 20, 30, 40];
total = 0;

for i = 1:length(data)
    total = total + data(i);
end

disp(total)   % Shows 100
```

## While Loops: Repeating Until a Condition Changes

A `while` loop keeps going as long as a condition is true. This is great for simulations — for example, a neuron accumulating charge until it fires:

```matlab
membrane_potential = 0;
threshold = 70;

while membrane_potential < threshold
    membrane_potential = membrane_potential + 15;
end

disp(membrane_potential)
```

Be careful with `while` loops! If the condition never becomes false, the loop runs forever (an "infinite loop"). Always make sure something inside the loop changes the condition.

## Putting It Together

Here''s a real-world-style example — scanning EEG channels for spikes:

```matlab
eeg_channels = [23, 91, 45, 88, 12, 67];
spike_count = 0;

for i = 1:length(eeg_channels)
    if eeg_channels(i) > 80
        spike_count = spike_count + 1;
    end
end

disp([''Spikes found: '' num2str(spike_count)])
```

## Why This Matters

When you analyze real brain data, you''ll loop through thousands of time points across dozens of channels, checking thresholds and making decisions at every step. Control flow is the engine that powers all of that.');

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (4, 1, 'Spike or no spike?',
  'A neuron fires (produces a "spike") when its voltage exceeds a threshold.

Given a signal value of 72 microvolts and a threshold of 65 microvolts, use an if/else statement to check:
- If the signal is **greater than** the threshold, display: `Spike detected`
- Otherwise, display: `No spike`',
  'signal_value = 72;
threshold = 65;

% Use if/else to check if signal_value exceeds threshold
% Display ''Spike detected'' or ''No spike''
',
  'signal_value = 72;
threshold = 65;

if signal_value > threshold
    disp(''Spike detected'')
else
    disp(''No spike'')
end',
  '["Start with: if signal_value > threshold","Inside the if block, use disp(''Spike detected''). Add an else block with disp(''No spike'').","The full structure is: if signal_value > threshold ... disp(''Spike detected'') ... else ... disp(''No spike'') ... end"]',
  '[{"expected_output":"Spike detected\n"}]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (4, 2, 'Sum the brain signals',
  'You have voltage readings from 5 EEG time points:

`readings = [12.5, 8.3, 15.1, 6.7, 9.4]`

Use a `for` loop to calculate the sum of all values. Store the running total in a variable called `total` (start it at 0). After the loop, display the total using `disp`.

(Yes, you could use the built-in `sum()` function — but the goal here is to practice loops!)',
  'readings = [12.5, 8.3, 15.1, 6.7, 9.4];
total = 0;

% Use a for loop to add each reading to total


% Display the total
',
  'readings = [12.5, 8.3, 15.1, 6.7, 9.4];
total = 0;

for i = 1:length(readings)
    total = total + readings(i);
end

disp(total)',
  '["The loop should go from 1 to the length of the readings array: for i = 1:length(readings)","Inside the loop, add the current reading to total: total = total + readings(i);","After the loop ends, display the result: disp(total). The answer should be 52."]',
  '[{"expected_output":"52\n"}]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (4, 3, 'Neuron reaches firing threshold',
  'Simulate a simple neuron that accumulates charge over time. The neuron starts with a membrane potential of 0 mV and gains 18 mV on each time step. The firing threshold is 70 mV.

Use a `while` loop to keep adding 18 to the membrane potential until it reaches or exceeds the threshold. Also count how many steps it takes (start a counter at 0 and increment it each loop iteration).

After the loop, display the final membrane potential and then the number of steps, each on their own line using `disp`.',
  'membrane_potential = 0;
threshold = 70;
steps = 0;

% Use a while loop: keep adding 18 to membrane_potential
% until it reaches or exceeds the threshold
% Count each step


% Display the final membrane potential

% Display the number of steps
',
  'membrane_potential = 0;
threshold = 70;
steps = 0;

while membrane_potential < threshold
    membrane_potential = membrane_potential + 18;
    steps = steps + 1;
end

disp(membrane_potential)
disp(steps)',
  '["The while condition should be: while membrane_potential < threshold","Inside the loop, increase membrane_potential by 18 and increase steps by 1 each time.","After the loop: disp(membrane_potential) then disp(steps). The neuron reaches 72 mV in 4 steps."]',
  '[{"expected_output":"72\n4\n"}]',
  false);


-- ============================================
-- Lesson 5: Functions
-- ============================================
INSERT INTO lessons (id, phase, order_num, title, description, difficulty, estimated_minutes, content_md)
VALUES (5, 1, 5, 'Functions',
  'Writing reusable functions to organize your brain data analysis — inputs, outputs, and built-in helpers.',
  'beginner', 30,
  '# Functions

As your neuroscience analysis grows, you''ll find yourself repeating the same calculations over and over — converting units, computing averages, counting spikes. **Functions** let you write that code once and reuse it anywhere.

## What Is a Function?

A function is like a little machine: you give it **inputs**, it does some work, and it gives you **outputs**.

You''ve already used built-in functions:
```matlab
mean([1, 2, 3, 4])   % Input: an array. Output: 2.5
length([10, 20, 30])  % Input: an array. Output: 3
```

Now you''ll learn to write your own!

## Writing Your Own Functions

In Octave, you can define a function right inside your script. The function definition must come **before** you call it. Here''s the basic structure:

```matlab
function output = function_name(input)
    % code that computes something
    output = ...;
end
```

Let''s write a function that converts degrees Celsius to Fahrenheit:

```matlab
function f = celsius_to_fahrenheit(c)
    f = c * 9/5 + 32;
end

% Now use it
result = celsius_to_fahrenheit(37);
disp(result)   % Shows 98.6
```

## Multiple Outputs

A function can return more than one value using square brackets:

```matlab
function [mn, mx] = min_max(data)
    mn = min(data);
    mx = max(data);
end

% Call it
[lo, hi] = min_max([3, 7, 1, 9, 4]);
disp(lo)   % 1
disp(hi)   % 9
```

## Multiple Inputs

Functions can take as many inputs as you need:

```matlab
function rate = firing_rate(spike_count, duration_seconds)
    rate = spike_count / duration_seconds;
end

r = firing_rate(150, 10);
disp(r)   % 15 spikes per second
```

## Useful Built-in Functions for Neuroscience

MATLAB/Octave comes with hundreds of built-in functions. Here are some you''ll use often:

| Function | What it does | Example |
|---|---|---|
| `mean(x)` | Average | `mean([2, 4, 6])` = 4 |
| `std(x)` | Standard deviation | `std([2, 4, 6])` = 2 |
| `max(x)` | Largest value | `max([2, 4, 6])` = 6 |
| `min(x)` | Smallest value | `min([2, 4, 6])` = 2 |
| `abs(x)` | Absolute value | `abs(-5)` = 5 |
| `sqrt(x)` | Square root | `sqrt(16)` = 4 |
| `round(x)` | Round to nearest integer | `round(3.7)` = 4 |
| `num2str(x)` | Number to text | `num2str(42)` = ''42'' |

## Important Rules

1. **Function definition goes at the top** of your script (before any calling code)
2. Variables inside a function are **local** — they don''t affect variables outside
3. Give your functions **descriptive names** like `calculate_firing_rate` rather than `f1`

## Why This Matters

In a real EEG study, you might write functions like `filter_signal()`, `detect_spikes()`, `compute_power_spectrum()`, and `plot_eeg_channel()`. Each one handles a specific job, keeping your analysis clean and organized. Functions are the building blocks of every serious neuroscience analysis pipeline.');

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (5, 1, 'Convert microvolts to millivolts',
  'EEG data is often recorded in microvolts (uV) but sometimes needs to be in millivolts (mV). There are 1000 microvolts in 1 millivolt.

Write a function called `uv_to_mv` that takes a value in microvolts and returns the value in millivolts (divide by 1000).

Then use your function to convert 4500 microvolts to millivolts and display the result.',
  '% Define your function here


% Convert 4500 microvolts and display the result
',
  'function mv = uv_to_mv(uv)
    mv = uv / 1000;
end

result = uv_to_mv(4500);
disp(result)',
  '["Start with: function mv = uv_to_mv(uv) and end with: end","Inside the function, divide the input by 1000: mv = uv / 1000;","After the function definition, call it: result = uv_to_mv(4500); disp(result)"]',
  '[{"expected_output":"4.5000\n"}]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (5, 2, 'Signal statistics function',
  'Write a function called `signal_stats` that takes an array of signal values and returns **two** outputs: the mean and the standard deviation.

Then call your function with this EEG data:
`data = [2.1, 3.5, 1.8, 4.2, 3.0, 2.7]`

Display the mean on the first line and the standard deviation on the second line using `disp`.

Hint: Use the built-in `mean()` and `std()` functions inside your function.',
  '% Define your function with two outputs here


% Call it with the data and display both results
data = [2.1, 3.5, 1.8, 4.2, 3.0, 2.7];
',
  'function [m, s] = signal_stats(signal)
    m = mean(signal);
    s = std(signal);
end

data = [2.1, 3.5, 1.8, 4.2, 3.0, 2.7];
[m, s] = signal_stats(data);
disp(m)
disp(s)',
  '["For multiple outputs, use square brackets: function [m, s] = signal_stats(signal)","Inside the function: m = mean(signal); and s = std(signal);","Call it with: [m, s] = signal_stats(data); then disp(m) and disp(s)"]',
  '[{"expected_output":"2.8833\n0.88863\n"}]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (5, 3, 'Calculate firing rate',
  'A neuron''s **firing rate** is the number of spikes divided by the recording duration (in seconds). The result is in Hz (spikes per second).

Write a function called `calc_firing_rate` that takes two inputs:
1. `spike_count` — number of spikes observed
2. `duration` — recording duration in seconds

The function should return the firing rate.

Then use it: a neuron fired 42 spikes in 3 seconds. Display the firing rate.',
  '% Define the firing rate function here


% Calculate the firing rate for 42 spikes in 3 seconds
% Display the result
',
  'function rate = calc_firing_rate(spike_count, duration)
    rate = spike_count / duration;
end

result = calc_firing_rate(42, 3);
disp(result)',
  '["Start with: function rate = calc_firing_rate(spike_count, duration)","Inside the function: rate = spike_count / duration;","Call it: result = calc_firing_rate(42, 3); disp(result). The answer should be 14."]',
  '[{"expected_output":"14\n"}]',
  false);


-- ============================================
-- Lesson 6: Plotting Basics
-- ============================================
INSERT INTO lessons (id, phase, order_num, title, description, difficulty, estimated_minutes, content_md)
VALUES (6, 1, 6, 'Plotting Basics',
  'Visualizing brain signals — creating plots, adding labels, and using subplots to display neuroscience data.',
  'beginner', 35,
  '# Plotting Basics

One of MATLAB''s superpowers is making graphs. In neuroscience, plotting is essential — you need to **see** brain signals to understand them. A wall of numbers won''t tell you much, but a clear plot can reveal patterns instantly.

## Your First Plot

The `plot()` function draws a line connecting data points:

```matlab
y = [1, 4, 2, 5, 3];
plot(y)
```

This plots the values against their index (1, 2, 3, 4, 5). But usually you want to plot against a meaningful x-axis, like time:

```matlab
t = [0, 0.25, 0.5, 0.75, 1.0];   % time in seconds
y = [1, 4, 2, 5, 3];               % voltage readings
plot(t, y)
```

## Adding Labels and Titles

Always label your plots! Unlabeled axes are a cardinal sin in science:

```matlab
t = 0:0.01:1;
signal = sin(2 * pi * 5 * t);
plot(t, signal)
xlabel(''Time (s)'')
ylabel(''Voltage (uV)'')
title(''5 Hz Brain Oscillation'')
```

- `xlabel()` — labels the horizontal axis
- `ylabel()` — labels the vertical axis
- `title()` — adds a title at the top

## Plot Customization

You can change colors and line styles:

```matlab
plot(t, signal, ''r'')       % Red line
plot(t, signal, ''b--'')     % Blue dashed line
plot(t, signal, ''g.'')      % Green dots
plot(t, signal, ''k-'', ''LineWidth'', 2)  % Thick black line
```

Common color codes: `r` (red), `b` (blue), `g` (green), `k` (black), `m` (magenta)

Common line styles: `-` (solid), `--` (dashed), `:` (dotted), `.` (points)

## Multiple Lines on One Plot

Use `hold on` to overlay multiple signals:

```matlab
t = 0:0.01:1;
alpha_wave = sin(2 * pi * 10 * t);
beta_wave = 0.5 * sin(2 * pi * 20 * t);

plot(t, alpha_wave, ''b'')
hold on
plot(t, beta_wave, ''r'')
hold off

legend(''Alpha (10 Hz)'', ''Beta (20 Hz)'')
xlabel(''Time (s)'')
ylabel(''Amplitude (uV)'')
title(''Brain Wave Comparison'')
```

`legend()` adds a key so viewers know which line is which.

## Subplots: Multiple Plots in One Figure

Sometimes you want to show related plots side by side (or stacked). `subplot` divides the figure into a grid:

```matlab
subplot(2, 1, 1)   % 2 rows, 1 column, plot #1 (top)
plot(t, alpha_wave)
title(''Alpha Wave'')

subplot(2, 1, 2)   % 2 rows, 1 column, plot #2 (bottom)
plot(t, beta_wave, ''r'')
title(''Beta Wave'')
```

The three numbers mean: `subplot(rows, columns, which_plot)`

## Grid Lines

Add a grid to make it easier to read values:
```matlab
plot(t, signal)
grid on
```

## Why This Matters

Neuroscientists live and breathe plots. EEG time series, power spectra, event-related potentials, topographic maps — these are all visualizations. Learning to create clear, labeled plots is one of the most practical skills you''ll gain. A good plot can communicate in seconds what would take paragraphs to describe.');

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (6, 1, 'Plot a brain oscillation',
  'Create a simple sine wave that represents a 6 Hz brain oscillation (theta wave) lasting 1 second.

1. Create a time vector `t` from 0 to 1 with a step of 0.001 (1000 points per second)
2. Create the signal: `signal = sin(2 * pi * 6 * t)`
3. Plot the signal against time
4. Add the x-label: `Time (s)`
5. Add the y-label: `Amplitude (uV)`
6. Add the title: `Theta Wave (6 Hz)`',
  '% Create time vector


% Create 6 Hz sine wave


% Plot it


% Add labels and title
',
  't = 0:0.001:1;
signal = sin(2 * pi * 6 * t);
plot(t, signal)
xlabel(''Time (s)'')
ylabel(''Amplitude (uV)'')
title(''Theta Wave (6 Hz)'')',
  '["Time vector: t = 0:0.001:1 gives you 1001 points from 0 to 1 second.","The sine wave formula is: signal = sin(2 * pi * 6 * t) where 6 is the frequency in Hz.","Then: plot(t, signal), xlabel(''Time (s)''), ylabel(''Amplitude (uV)''), title(''Theta Wave (6 Hz)'')"]',
  '[]',
  true);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (6, 2, 'Compare two brain rhythms',
  'Plot two brain rhythms on the same figure to compare them:

1. Create a time vector `t` from 0 to 1 with step 0.001
2. Create an alpha wave: `alpha = sin(2 * pi * 10 * t)` (10 Hz)
3. Create a gamma wave: `gamma = 0.4 * sin(2 * pi * 40 * t)` (40 Hz, smaller amplitude)
4. Plot alpha in blue (`''b''`), use `hold on`, then plot gamma in red (`''r''`), then `hold off`
5. Add a legend with labels `Alpha (10 Hz)` and `Gamma (40 Hz)`
6. Add x-label: `Time (s)`, y-label: `Amplitude (uV)`, title: `Alpha vs Gamma Waves`',
  '% Create time vector


% Create alpha and gamma waves


% Plot both on the same figure


% Add legend, labels, and title
',
  't = 0:0.001:1;
alpha = sin(2 * pi * 10 * t);
gamma = 0.4 * sin(2 * pi * 40 * t);

plot(t, alpha, ''b'')
hold on
plot(t, gamma, ''r'')
hold off

legend(''Alpha (10 Hz)'', ''Gamma (40 Hz)'')
xlabel(''Time (s)'')
ylabel(''Amplitude (uV)'')
title(''Alpha vs Gamma Waves'')',
  '["Create both signals first, then use plot(t, alpha, ''b'') for the blue alpha wave.","Use hold on before the second plot, then plot(t, gamma, ''r''), then hold off.","Add legend(''Alpha (10 Hz)'', ''Gamma (40 Hz)'') and the xlabel, ylabel, title calls."]',
  '[]',
  true);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (6, 3, 'Subplot: time and frequency view',
  'Create a figure with two stacked plots (2 rows, 1 column) showing different views of brain data:

**Top plot (subplot 1):**
1. Create time vector: `t = 0:0.001:1`
2. Create signal: `signal = sin(2 * pi * 8 * t) + 0.5 * sin(2 * pi * 20 * t)`
3. Plot the signal in black (`''k''`)
4. Title: `EEG Signal (Time Domain)`
5. x-label: `Time (s)`, y-label: `Voltage (uV)`

**Bottom plot (subplot 2):**
1. Create frequency values: `freqs = [2, 5, 8, 12, 20, 30, 40]`
2. Create power values: `power = [0.1, 0.3, 1.0, 0.4, 0.5, 0.2, 0.1]`
3. Plot power vs frequency as a red line with circular markers (`''ro-''`)
4. Title: `Power Spectrum`
5. x-label: `Frequency (Hz)`, y-label: `Power`',
  '% Top plot: time domain signal




% Bottom plot: frequency domain (power spectrum)

',
  't = 0:0.001:1;
signal = sin(2 * pi * 8 * t) + 0.5 * sin(2 * pi * 20 * t);

subplot(2, 1, 1)
plot(t, signal, ''k'')
title(''EEG Signal (Time Domain)'')
xlabel(''Time (s)'')
ylabel(''Voltage (uV)'')

freqs = [2, 5, 8, 12, 20, 30, 40];
power = [0.1, 0.3, 1.0, 0.4, 0.5, 0.2, 0.1];

subplot(2, 1, 2)
plot(freqs, power, ''ro-'')
title(''Power Spectrum'')
xlabel(''Frequency (Hz)'')
ylabel(''Power'')',
  '["Use subplot(2, 1, 1) before the first plot and subplot(2, 1, 2) before the second plot.","The top plot uses plot(t, signal, ''k''). The bottom plot uses plot(freqs, power, ''ro-'').","Add title, xlabel, ylabel after each plot call. Each subplot gets its own labels."]',
  '[]',
  true);


-- ============================================
-- Lesson 7: Loading Data
-- ============================================
INSERT INTO lessons (id, phase, order_num, title, description, difficulty, estimated_minutes, content_md)
VALUES (7, 2, 1, 'Loading Data',
  'Learn to load data from files into MATLAB — essential for working with EEG recordings and experiment results.',
  'intermediate', 30,
  '# Loading Data

In real neuroscience research, you rarely type data by hand. Instead, your EEG system, eye tracker, or stimulus program saves data to files. Your job is to **load** that data into MATLAB so you can analyze it.

Let''s learn the key tools for getting data into your workspace.

## Saving and Loading `.mat` Files

MATLAB has its own file format: `.mat` files. These are great because they preserve your variable names and types perfectly.

### Saving data
```matlab
eeg_signal = [1.2 3.4 2.1 5.6 4.3];
sampling_rate = 256;
save(''my_data.mat'', ''eeg_signal'', ''sampling_rate'');
```

This creates a file called `my_data.mat` containing both variables.

### Loading data
```matlab
load(''my_data.mat'');
% Now eeg_signal and sampling_rate are back in your workspace!
```

You can also load specific variables:
```matlab
load(''my_data.mat'', ''eeg_signal'');
% Only eeg_signal is loaded
```

## Reading CSV Files with `csvread`

CSV (Comma-Separated Values) files are simple text files where numbers are separated by commas. Many experiment programs export data this way.

```matlab
data = csvread(''experiment_results.csv'');
```

If your CSV has a header row, you can skip it:
```matlab
data = csvread(''experiment_results.csv'', 1, 0);
% Skips 1 row, 0 columns
```

## Reading Delimited Files with `dlmread`

Some files use tabs or other separators instead of commas. `dlmread` handles any delimiter:

```matlab
% Tab-delimited file
data = dlmread(''data.txt'', ''\t'');

% Space-delimited file
data = dlmread(''data.txt'', '' '');

% Comma-delimited (same as csvread)
data = dlmread(''data.csv'', '','');
```

## Working with Loaded Data

Once data is loaded, it''s just a regular matrix. You can use everything you already know:

```matlab
data = csvread(''eeg_recording.csv'');

% Check the size
[num_channels, num_timepoints] = size(data);

% Get the first channel
channel_1 = data(1, :);

% Get the first 100 time points from all channels
first_segment = data(:, 1:100);
```

## Practical Example: Loading an EEG Recording

Imagine you have a file with 4 EEG channels recorded over 8 time points:

```matlab
% Save some sample EEG data
eeg = [1.2 3.4 2.1 5.6 4.3 2.8 1.9 3.7;
       0.8 2.9 1.7 4.2 3.8 2.1 1.4 3.2;
       1.5 3.8 2.4 6.1 4.7 3.1 2.2 4.0;
       0.9 3.1 1.9 5.0 4.0 2.5 1.7 3.5];
save(''eeg_recording.mat'', ''eeg'');

% Now load it back
clear;  % Clear workspace
load(''eeg_recording.mat'');
disp(size(eeg));
% Output: 4  8  (4 channels, 8 time points)
```

## Tips

- Always check `size()` after loading data to make sure it looks right
- Use `whos` to see what variables were loaded
- `.mat` files are best for MATLAB work; CSV files are best for sharing with other programs
- If your data does not load correctly, check for header rows or extra whitespace in the file');

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (7, 1, 'Save and load experiment data',
  'Create a simulated EEG dataset and practice saving and loading it.

1. Create a variable `eeg_data` containing this 3x5 matrix (3 channels, 5 time points):
   [1.2 2.3 3.1 2.8 1.9; 0.8 1.9 2.7 2.2 1.5; 1.5 2.6 3.4 3.0 2.1]
2. Create a variable `fs` (sampling rate) equal to 256
3. Save both variables to a file called ''recording.mat''
4. Clear the workspace using `clear`
5. Load the file back
6. Display `fs` and then display the size of `eeg_data`',
  '% Step 1: Create the EEG data matrix


% Step 2: Set the sampling rate


% Step 3: Save to file


% Step 4: Clear workspace


% Step 5: Load the file


% Step 6: Display fs and the size of eeg_data
',
  'eeg_data = [1.2 2.3 3.1 2.8 1.9; 0.8 1.9 2.7 2.2 1.5; 1.5 2.6 3.4 3.0 2.1];
fs = 256;
save(''recording.mat'', ''eeg_data'', ''fs'');
clear;
load(''recording.mat'');
disp(fs)
disp(size(eeg_data))',
  '["Use semicolons in the matrix to separate rows: [row1; row2; row3]","The save function takes the filename first, then variable names as strings: save(''file.mat'', ''var1'', ''var2'')","After clear and load, use disp(fs) and disp(size(eeg_data)) to show the results"]',
  '[{"expected_output":"256\n   3   5\n"}]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (7, 2, 'Parse CSV-style data',
  'Sometimes you need to work with data that was read from a CSV file. Simulate this by creating a matrix directly (as if csvread had loaded it), then extract information.

1. Create a variable `trial_data` with this matrix (rows = trials, columns = reaction time in ms, accuracy 0/1, condition 1/2):
   [245 1 1; 312 0 2; 198 1 1; 278 1 2; 356 0 1; 201 1 2]
2. Display the total number of trials (number of rows)
3. Extract column 1 (reaction times) into `rt` and display the mean reaction time
4. Extract column 2 (accuracy) into `acc` and display the mean accuracy',
  '% Step 1: Create the trial data matrix


% Step 2: Display number of trials


% Step 3: Extract and display mean reaction time


% Step 4: Extract and display mean accuracy
',
  'trial_data = [245 1 1; 312 0 2; 198 1 1; 278 1 2; 356 0 1; 201 1 2];
disp(size(trial_data, 1))
rt = trial_data(:, 1);
disp(mean(rt))
acc = trial_data(:, 2);
disp(mean(acc))',
  '["Use size(matrix, 1) to get just the number of rows (first dimension)","Extract a column using the colon operator: rt = trial_data(:, 1) means all rows, column 1","mean() calculates the average. For accuracy, mean of [1 0 1 1 0 1] gives the proportion correct"]',
  '[{"expected_output":"6\n265\n0.6667\n"}]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (7, 3, 'Extract channels from loaded data',
  'You have loaded an EEG dataset where rows are channels and columns are time points. Extract specific channels and compute a summary.

1. Create the data matrix (4 channels, 6 time points):
   `eeg = [2.1 3.5 1.8 4.2 2.9 3.1; 1.5 2.8 1.2 3.6 2.3 2.7; 3.0 4.1 2.5 5.0 3.6 3.8; 1.8 3.2 1.5 3.9 2.6 3.0]`
2. Extract channel 3 (third row) into a variable `ch3` and display it
3. Extract time points 2 through 5 from all channels into `segment` and display its size
4. Calculate the mean amplitude for each channel (mean across columns) and display the result',
  '% Step 1: Create the EEG matrix


% Step 2: Extract channel 3 and display


% Step 3: Extract time segment and display size


% Step 4: Mean amplitude per channel
',
  'eeg = [2.1 3.5 1.8 4.2 2.9 3.1; 1.5 2.8 1.2 3.6 2.3 2.7; 3.0 4.1 2.5 5.0 3.6 3.8; 1.8 3.2 1.5 3.9 2.6 3.0];
ch3 = eeg(3, :);
disp(ch3)
segment = eeg(:, 2:5);
disp(size(segment))
disp(mean(eeg, 2))',
  '["Extract a full row with eeg(3, :) — row 3, all columns","Extract a range of columns with eeg(:, 2:5) — all rows, columns 2 to 5","mean(eeg, 2) computes the mean along dimension 2 (across columns), giving one value per row (channel)"]',
  '[{"expected_output":"   3.0000   4.1000   2.5000   5.0000   3.6000   3.8000\n   4   4\n   2.9333\n   2.3500\n   3.6667\n   2.6667\n"}]',
  false);


-- ============================================
-- Lesson 8: Data Manipulation
-- ============================================
INSERT INTO lessons (id, phase, order_num, title, description, difficulty, estimated_minutes, content_md)
VALUES (8, 2, 2, 'Data Manipulation',
  'Sort, filter, reshape, and compute statistics on data — the core skills for preprocessing brain signals.',
  'intermediate', 30,
  '# Data Manipulation

Raw brain data is messy. Before you can analyze EEG signals, you need to clean them up: remove bad data points, compute summary statistics, and reshape data into useful formats. This lesson covers the essential data manipulation tools.

## Descriptive Statistics

MATLAB gives you powerful functions to summarize data:

```matlab
signal = [2.3 -1.5 4.2 0.8 -3.1 5.7 1.2 -0.4];

mean(signal)    % Average: 1.15
median(signal)  % Middle value: 1.0
std(signal)     % Standard deviation: 2.94
var(signal)     % Variance: 8.67
min(signal)     % Minimum: -3.1
max(signal)     % Maximum: 5.7
range(signal)   % Range: max - min = 8.8
```

### Statistics Along a Dimension

For matrices, you can compute statistics along rows or columns:

```matlab
eeg = [1.2 3.4 2.1; 0.8 2.9 1.7; 1.5 3.8 2.4];

mean(eeg, 1)   % Mean of each column (across rows)
mean(eeg, 2)   % Mean of each row (across columns)
```

## Sorting Data

Sort values in ascending or descending order:

```matlab
reaction_times = [312 198 456 234 189 378];

sorted_rt = sort(reaction_times);           % Ascending: [189 198 234 312 378 456]
sorted_desc = sort(reaction_times, ''descend'');  % Descending
```

You can also get the original indices:
```matlab
[sorted_vals, indices] = sort(reaction_times);
% indices tells you where each sorted value was originally
```

## Filtering Data (Logical Indexing)

This is one of MATLAB''s most powerful features. You can use a **condition** to select elements:

```matlab
signal = [2.3 -1.5 4.2 0.8 -3.1 5.7 1.2 -0.4];

% Find values above 2
high_values = signal(signal > 2);
% Result: [2.3 4.2 5.7]

% Find values between -1 and 3
normal_range = signal(signal >= -1 & signal <= 3);
% Result: [2.3 0.8 1.2 -0.4]
```

### Artifact Rejection in EEG

In real EEG analysis, you remove data points that exceed a threshold (they are probably caused by eye blinks or muscle movement, not brain activity):

```matlab
raw_eeg = [12 -85 15 8 -120 22 95 -10 7 130];
threshold = 80;

% Remove artifacts (values where |amplitude| > threshold)
clean_mask = abs(raw_eeg) <= threshold;
clean_eeg = raw_eeg(clean_mask);
% Result: [12 15 8 22 -10 7]
```

## Replacing Values

Instead of removing bad data, sometimes you replace it:

```matlab
signal = [2.3 -1.5 99.9 0.8 -3.1 -99.2 1.2];
signal(abs(signal) > 50) = 0;  % Replace outliers with 0
% Result: [2.3 -1.5 0 0.8 -3.1 0 1.2]
```

## Reshaping Data

The `reshape` function reorganizes data without changing the values:

```matlab
% A 1D signal with 12 time points
long_signal = 1:12;

% Reshape into 3 epochs of 4 time points each
epochs = reshape(long_signal, 4, 3);
% Result: 4x3 matrix (4 time points per epoch, 3 epochs)
% Note: MATLAB fills columns first!
```

**Important**: `reshape` fills **column by column**. So `reshape(1:12, 4, 3)` gives:
```
 1  5  9
 2  6 10
 3  7 11
 4  8 12
```

If you want it filled row by row, transpose afterward:
```matlab
epochs = reshape(long_signal, 3, 4)'';
% Now: 3 rows (epochs) x 4 columns (time points)
```

## Useful Summary

| Function | What it does |
|---|---|
| `mean(x)` | Average |
| `median(x)` | Middle value |
| `std(x)` | Standard deviation |
| `sort(x)` | Sort ascending |
| `x(condition)` | Logical indexing |
| `reshape(x, r, c)` | Reshape to r rows, c columns |');

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (8, 1, 'EEG amplitude statistics',
  'You have recorded EEG amplitudes (in microvolts) from a single channel during a 1-second window:

`amplitudes = [12.5 -8.3 15.1 -2.7 22.4 -11.6 7.8 -5.2 18.9 -1.4]`

Calculate and display:
1. The mean amplitude
2. The standard deviation
3. The median amplitude
4. The range (max minus min)

Display each value on its own line using `disp`.',
  'amplitudes = [12.5 -8.3 15.1 -2.7 22.4 -11.6 7.8 -5.2 18.9 -1.4];

% Calculate and display the mean


% Calculate and display the standard deviation


% Calculate and display the median


% Calculate and display the range
',
  'amplitudes = [12.5 -8.3 15.1 -2.7 22.4 -11.6 7.8 -5.2 18.9 -1.4];
disp(mean(amplitudes))
disp(std(amplitudes))
disp(median(amplitudes))
disp(max(amplitudes) - min(amplitudes))',
  '["Use the built-in functions: mean(), std(), median(), max(), min()","The range is calculated as max(amplitudes) - min(amplitudes)","Wrap each calculation in disp(): disp(mean(amplitudes)), disp(std(amplitudes)), etc."]',
  '[{"expected_output":"4.7500\n12.102\n3.2000\n34\n"}]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (8, 2, 'Artifact rejection',
  'EEG signals often contain artifacts — abnormally large values caused by eye blinks or muscle movements. These need to be removed before analysis.

Given a raw EEG signal:
`raw = [15 -82 8 120 -5 12 -95 22 7 -110 18 3]`

1. Set a threshold of 80 microvolts
2. Create a clean signal by keeping only values where the absolute value is less than or equal to the threshold
3. Display the clean signal
4. Display how many data points were removed (original length minus clean length)',
  'raw = [15 -82 8 120 -5 12 -95 22 7 -110 18 3];
threshold = 80;

% Keep only values within the threshold


% Display the clean signal


% Display count of removed points
',
  'raw = [15 -82 8 120 -5 12 -95 22 7 -110 18 3];
threshold = 80;
clean = raw(abs(raw) <= threshold);
disp(clean)
disp(length(raw) - length(clean))',
  '["Use abs() to get the absolute value of each element, then compare with <=","Logical indexing: clean = raw(abs(raw) <= threshold) keeps only values within range","Count removed points: disp(length(raw) - length(clean))"]',
  '[{"expected_output":"   15    8   -5   12   22    7   18    3\n4\n"}]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (8, 3, 'Reshape signal into epochs',
  'In EEG analysis, a long continuous signal is often divided into short segments called **epochs** (e.g., one epoch per trial in an experiment).

Given a continuous signal of 20 data points:
`signal = [3 7 2 9 5 8 1 6 4 10 11 3 8 2 7 5 9 1 6 4]`

1. Reshape this into a 5x4 matrix called `epochs` where each column is one epoch of 5 time points. Use `reshape(signal, 5, 4)`
2. Display the epochs matrix
3. Calculate and display the mean of each epoch (mean of each column). Use `mean(epochs, 1)`',
  'signal = [3 7 2 9 5 8 1 6 4 10 11 3 8 2 7 5 9 1 6 4];

% Reshape into 5 time points x 4 epochs


% Display the epochs matrix


% Display the mean of each epoch
',
  'signal = [3 7 2 9 5 8 1 6 4 10 11 3 8 2 7 5 9 1 6 4];
epochs = reshape(signal, 5, 4);
disp(epochs)
disp(mean(epochs, 1))',
  '["reshape(signal, rows, cols) rearranges the signal into a matrix. MATLAB fills column by column","epochs = reshape(signal, 5, 4) creates a 5-row, 4-column matrix","mean(epochs, 1) computes the mean along dimension 1 (down each column), giving one mean per epoch"]',
  '[{"expected_output":"    3    8   11    5\n    7    1    3    9\n    2    6    8    1\n    9    4    2    6\n    5   10    7    4\n   5.2000   5.8000   6.2000   5.0000\n"}]',
  false);


-- ============================================
-- Lesson 9: Advanced Plotting
-- ============================================
INSERT INTO lessons (id, phase, order_num, title, description, difficulty, estimated_minutes, content_md)
VALUES (9, 2, 3, 'Advanced Plotting',
  'Create heatmaps, bar charts, and multi-panel figures — the visualizations neuroscientists use every day.',
  'intermediate', 35,
  '# Advanced Plotting

In Phase 1, you learned basic line plots. Now we''ll explore the visualizations that neuroscientists rely on daily: **heatmaps** for brain activity maps, **bar charts** for comparing conditions, and **multi-panel figures** for presenting multiple results at once.

## Heatmaps with `imagesc`

A heatmap shows a matrix as a grid of colors. Higher values get warmer colors, lower values get cooler colors. This is how neuroscientists visualize EEG data across channels and time.

```matlab
% 4 channels x 8 time points
eeg = [1.2 3.4 2.1 5.6 4.3 2.8 1.9 3.7;
       0.8 2.9 1.7 4.2 3.8 2.1 1.4 3.2;
       1.5 3.8 2.4 6.1 4.7 3.1 2.2 4.0;
       0.9 3.1 1.9 5.0 4.0 2.5 1.7 3.5];

figure;
imagesc(eeg);
colorbar;
xlabel(''Time Point'');
ylabel(''Channel'');
title(''EEG Activity Heatmap'');
```

The `colorbar` adds a legend showing what the colors mean.

## Colormaps

You can change the color scheme:

```matlab
colormap(''hot'');     % Black-red-yellow-white
colormap(''jet'');     % Blue-cyan-green-yellow-red
colormap(''parula'');  % Default blue-to-yellow
colormap(''gray'');    % Grayscale
```

For brain data, `jet` and `hot` are commonly used because they make activation patterns easy to see.

## Bar Charts

Bar charts are perfect for comparing averages across conditions:

```matlab
% Average power in 4 frequency bands
bands = [8.2 15.6 4.3 2.1];

figure;
bar(bands);
set(gca, ''XTickLabel'', {''Delta'', ''Alpha'', ''Beta'', ''Gamma''});
ylabel(''Power (uV^2)'');
title(''EEG Power by Frequency Band'');
```

### Grouped Bar Charts

Compare multiple conditions side by side:

```matlab
% 2 conditions x 4 frequency bands
power_data = [8.2 15.6 4.3 2.1;
              6.5 22.3 5.1 2.8];

figure;
bar(power_data'');
legend(''Rest'', ''Task'');
set(gca, ''XTickLabel'', {''Delta'', ''Alpha'', ''Beta'', ''Gamma''});
```

## Multi-Panel Figures with `subplot`

Put multiple plots in one figure using `subplot(rows, cols, position)`:

```matlab
figure;

% Top-left panel
subplot(2, 2, 1);
plot(signal_1);
title(''Channel 1'');

% Top-right panel
subplot(2, 2, 2);
plot(signal_2);
title(''Channel 2'');

% Bottom-left panel
subplot(2, 2, 3);
bar(averages);
title(''Averages'');

% Bottom-right panel
subplot(2, 2, 4);
imagesc(matrix);
title(''Heatmap'');
```

The three numbers mean: (total rows, total columns, which panel). Panels are numbered left-to-right, top-to-bottom.

## Customizing Your Plots

Make your figures publication-ready:

```matlab
% Font sizes
set(gca, ''FontSize'', 12);

% Axis limits
xlim([0 100]);
ylim([-5 5]);

% Color of bars
bar(data, ''FaceColor'', [0.3 0.6 0.9]);  % RGB color

% Grid lines
grid on;
```

## Why This Matters

These visualizations are the bread and butter of neuroscience papers. A well-made heatmap can show brain activation patterns at a glance. Bar charts let you compare experimental conditions clearly. Multi-panel figures tell a complete story in one image.');

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (9, 1, 'EEG activity heatmap',
  'Create a heatmap showing EEG activity across channels and time.

1. Create a 5x8 matrix `eeg_data` representing 5 channels and 8 time points:
   [2.1 4.5 3.2 6.8 5.1 3.9 2.5 4.2;
    1.8 3.9 2.8 5.5 4.3 3.2 2.1 3.8;
    3.2 5.8 4.5 8.1 6.3 4.8 3.5 5.5;
    2.5 4.8 3.6 7.0 5.5 4.1 2.8 4.6;
    1.5 3.5 2.5 5.0 3.9 2.9 1.9 3.4]
2. Create a figure and display the matrix as a heatmap using `imagesc`
3. Add a colorbar
4. Label the x-axis as ''Time Point'', y-axis as ''Channel''
5. Add the title ''EEG Channel Activity Over Time''
6. Use the ''jet'' colormap',
  '% Create the EEG data matrix
eeg_data = [2.1 4.5 3.2 6.8 5.1 3.9 2.5 4.2;
            1.8 3.9 2.8 5.5 4.3 3.2 2.1 3.8;
            3.2 5.8 4.5 8.1 6.3 4.8 3.5 5.5;
            2.5 4.8 3.6 7.0 5.5 4.1 2.8 4.6;
            1.5 3.5 2.5 5.0 3.9 2.9 1.9 3.4];

% Create the heatmap
',
  'eeg_data = [2.1 4.5 3.2 6.8 5.1 3.9 2.5 4.2;
            1.8 3.9 2.8 5.5 4.3 3.2 2.1 3.8;
            3.2 5.8 4.5 8.1 6.3 4.8 3.5 5.5;
            2.5 4.8 3.6 7.0 5.5 4.1 2.8 4.6;
            1.5 3.5 2.5 5.0 3.9 2.9 1.9 3.4];
figure;
imagesc(eeg_data);
colorbar;
xlabel(''Time Point'');
ylabel(''Channel'');
title(''EEG Channel Activity Over Time'');
colormap(''jet'');',
  '["imagesc(matrix) displays the matrix as a color-coded image. Call figure; first to create a new figure window","After imagesc, add colorbar; on a new line, then use xlabel(), ylabel(), and title() for labels","Set the colormap with colormap(''jet'') — this gives the classic rainbow color scheme used in neuroscience"]',
  '[]',
  true);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (9, 2, 'Frequency band power bar chart',
  'Create a bar chart showing the average power in different EEG frequency bands.

1. Define the average power values for 5 frequency bands:
   `power = [18.5 12.3 25.7 8.4 3.2]`
   These correspond to: Delta (1-4 Hz), Theta (4-8 Hz), Alpha (8-13 Hz), Beta (13-30 Hz), Gamma (30-100 Hz)
2. Create a figure and a bar chart of the power values
3. Set the x-axis tick labels to the band names using:
   `set(gca, ''XTickLabel'', {''Delta'', ''Theta'', ''Alpha'', ''Beta'', ''Gamma''})`
4. Label the y-axis as ''Power (uV^2)''
5. Add the title ''EEG Power Spectrum by Frequency Band''
6. Add grid lines with `grid on`',
  '% Define power values
power = [18.5 12.3 25.7 8.4 3.2];

% Create the bar chart
',
  'power = [18.5 12.3 25.7 8.4 3.2];
figure;
bar(power);
set(gca, ''XTickLabel'', {''Delta'', ''Theta'', ''Alpha'', ''Beta'', ''Gamma''});
ylabel(''Power (uV^2)'');
title(''EEG Power Spectrum by Frequency Band'');
grid on;',
  '["Use bar(power) to create a bar chart. Remember to call figure; first","set(gca, ''XTickLabel'', {''Delta'', ''Theta'', ''Alpha'', ''Beta'', ''Gamma''}) replaces the 1-5 x-axis labels with band names","Add ylabel(''Power (uV^2)''), title(''EEG Power Spectrum by Frequency Band''), and grid on for the final touches"]',
  '[]',
  true);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (9, 3, 'Multi-panel neuroscience figure',
  'Create a 2x2 multi-panel figure showing different views of EEG data.

1. Create the data:
   - `time = 0:0.01:1` (time vector from 0 to 1 second)
   - `signal = sin(2 * pi * 10 * time)` (a 10 Hz brain wave)
   - `noisy = signal + 0.5 * randn(size(signal))` -- BUT for reproducibility, use `rand(''state'', 42)` before creating the noise. Actually, use this approach:
     `rand(''state'', 42); noisy = signal + 0.5 * (rand(size(signal)) - 0.5)`
   - `band_power = [18.5 12.3 25.7 8.4 3.2]`
   - `topo_map = [1.2 2.3 1.8; 3.1 4.5 3.3; 2.0 3.2 2.1]` (a simple 3x3 scalp map)

2. Create a figure with 4 subplots:
   - subplot(2,2,1): Plot the clean signal vs time. Title: ''Clean Signal (10 Hz)''
   - subplot(2,2,2): Plot the noisy signal vs time. Title: ''Noisy Signal''
   - subplot(2,2,3): Bar chart of band_power. Title: ''Band Power''
   - subplot(2,2,4): Heatmap of topo_map using imagesc. Title: ''Scalp Map''. Add a colorbar',
  '% Create the data
time = 0:0.01:1;
signal = sin(2 * pi * 10 * time);
rand(''state'', 42);
noisy = signal + 0.5 * (rand(size(signal)) - 0.5);
band_power = [18.5 12.3 25.7 8.4 3.2];
topo_map = [1.2 2.3 1.8; 3.1 4.5 3.3; 2.0 3.2 2.1];

% Create 2x2 figure
figure;

% Panel 1: Clean signal


% Panel 2: Noisy signal


% Panel 3: Bar chart


% Panel 4: Scalp heatmap
',
  'time = 0:0.01:1;
signal = sin(2 * pi * 10 * time);
rand(''state'', 42);
noisy = signal + 0.5 * (rand(size(signal)) - 0.5);
band_power = [18.5 12.3 25.7 8.4 3.2];
topo_map = [1.2 2.3 1.8; 3.1 4.5 3.3; 2.0 3.2 2.1];
figure;
subplot(2, 2, 1);
plot(time, signal);
title(''Clean Signal (10 Hz)'');
subplot(2, 2, 2);
plot(time, noisy);
title(''Noisy Signal'');
subplot(2, 2, 3);
bar(band_power);
title(''Band Power'');
subplot(2, 2, 4);
imagesc(topo_map);
title(''Scalp Map'');
colorbar;',
  '["subplot(2, 2, N) selects the Nth panel in a 2x2 grid. Panel 1 is top-left, 2 is top-right, 3 is bottom-left, 4 is bottom-right","For panels 1 and 2, use plot(time, signal) and plot(time, noisy). For panel 3, use bar(band_power). For panel 4, use imagesc(topo_map)","After each subplot command, add the plot command and title(). For the last panel, add colorbar; after imagesc"]',
  '[]',
  true);


-- ============================================
-- Lesson 10: File I/O
-- ============================================
INSERT INTO lessons (id, phase, order_num, title, description, difficulty, estimated_minutes, content_md)
VALUES (10, 2, 4, 'File I/O',
  'Read and write data files, work with strings and paths — essential for batch processing experiment data.',
  'intermediate', 25,
  '# File I/O

In a real neuroscience lab, you might have data from 50 participants, each with multiple session files. You need to **write** analysis results to files and **read** data files efficiently. This lesson teaches you how.

## Writing to Text Files

The basic workflow for writing a file:

```matlab
% Open a file for writing
fid = fopen(''results.txt'', ''w'');

% Write some text
fprintf(fid, ''Experiment Results\n'');
fprintf(fid, ''Subject: %s\n'', ''P001'');
fprintf(fid, ''Mean RT: %.2f ms\n'', 245.7);

% Close the file
fclose(fid);
```

### Key Concepts:
- `fopen(''filename'', ''w'')` opens a file for **w**riting (creates it if it doesn''t exist)
- `fid` is a "file identifier" — a number that refers to your open file
- `fprintf` writes formatted text (just like printing, but to a file)
- `fclose` closes the file — **always close your files!**

## Format Specifiers

Inside `fprintf`, special codes control how values are printed:

| Code | Meaning | Example |
|---|---|---|
| `%s` | String (text) | `''hello''` |
| `%d` | Integer | `42` |
| `%f` | Decimal number | `3.14` |
| `%.2f` | Decimal, 2 places | `3.14` |
| `%e` | Scientific notation | `1.23e+04` |
| `\n` | New line | (line break) |
| `\t` | Tab | (spacing) |

## Reading Text Files

Read a file line by line:

```matlab
fid = fopen(''results.txt'', ''r'');
line1 = fgetl(fid);   % Read first line
line2 = fgetl(fid);   % Read second line
fclose(fid);
```

`fgetl` reads one line at a time and returns it as a string.

### Reading an Entire File

```matlab
fid = fopen(''data.txt'', ''r'');
line_num = 0;
while ~feof(fid)
    line = fgetl(fid);
    line_num = line_num + 1;
    disp(line);
end
fclose(fid);
disp([''Total lines: '' num2str(line_num)]);
```

`feof(fid)` returns true when you''ve reached the **E**nd **O**f **F**ile.

## Working with Strings

Useful string functions for processing filenames and data:

```matlab
% Combining strings
subject = ''P001'';
filename = [''data_'' subject ''.mat''];
% Result: ''data_P001.mat''

% Number to string
num2str(42)        % ''42''
num2str(3.14)      % ''3.14''

% String to number
str2num(''42'')      % 42

% Formatted string
name = sprintf(''subject_%03d.mat'', 5);
% Result: ''subject_005.mat'' (zero-padded to 3 digits)
```

## Building File Paths

When working with data in different folders:

```matlab
folder = ''experiment_data'';
filename = ''session_01.mat'';
full_path = [folder ''/'' filename];
% Result: ''experiment_data/session_01.mat''
```

You can also use `fullfile` for platform-independent paths:
```matlab
full_path = fullfile(''experiment_data'', ''session_01.mat'');
```

## Batch Processing Pattern

Process multiple files in a loop:

```matlab
for i = 1:5
    filename = sprintf(''subject_%02d.mat'', i);
    disp([''Processing: '' filename]);
    % load(filename);
    % ... do analysis ...
end
```

This generates: `subject_01.mat`, `subject_02.mat`, ..., `subject_05.mat`

## Why This Matters

Every neuroscience experiment generates many data files. Being able to read, write, and batch process files means you can analyze an entire study automatically instead of manually opening each file. This saves hours (or days!) of work.');

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (10, 1, 'Write experiment results',
  'Write a summary of experiment results to a text file.

1. Define these variables:
   - `subject_id = ''P042''`
   - `n_trials = 120`
   - `mean_rt = 287.5` (mean reaction time in ms)
   - `accuracy = 0.875` (proportion correct)

2. Open a file called ''experiment_summary.txt'' for writing
3. Write these lines to the file (use fprintf with the format specifiers shown):
   - `''Subject: P042\n''` (use %s for the subject ID)
   - `''Number of trials: 120\n''` (use %d for the integer)
   - `''Mean reaction time: 287.50 ms\n''` (use %.2f for 2 decimal places)
   - `''Accuracy: 87.5%%\n''` (multiply accuracy by 100 and use %.1f; use %% to print a literal percent sign)
4. Close the file
5. Verify by reading and displaying the file content: open the file for reading, use a while loop with feof and fgetl to read and disp each line, then close',
  'subject_id = ''P042'';
n_trials = 120;
mean_rt = 287.5;
accuracy = 0.875;

% Write to file


% Read and display the file to verify
',
  'subject_id = ''P042'';
n_trials = 120;
mean_rt = 287.5;
accuracy = 0.875;
fid = fopen(''experiment_summary.txt'', ''w'');
fprintf(fid, ''Subject: %s\n'', subject_id);
fprintf(fid, ''Number of trials: %d\n'', n_trials);
fprintf(fid, ''Mean reaction time: %.2f ms\n'', mean_rt);
fprintf(fid, ''Accuracy: %.1f%%\n'', accuracy * 100);
fclose(fid);
fid = fopen(''experiment_summary.txt'', ''r'');
while ~feof(fid)
    line = fgetl(fid);
    disp(line);
end
fclose(fid);',
  '["Open the file with fid = fopen(''experiment_summary.txt'', ''w''); and close with fclose(fid);","Use fprintf(fid, ''format'', value) for each line. %s for strings, %d for integers, %.2f for 2 decimal places","To print a literal % sign in fprintf, use %%. So ''Accuracy: %.1f%%\\n'' prints something like ''Accuracy: 87.5%''"]',
  '[{"expected_output":"Subject: P042\nNumber of trials: 120\nMean reaction time: 287.50 ms\nAccuracy: 87.5%\n"}]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (10, 2, 'Read and parse a data file',
  'Create a data file and then read it back, parsing the numbers.

1. First, create a data file with 5 lines of tab-separated values (channel number and mean amplitude):
   Open ''channel_data.txt'' for writing and write these lines:
   `''1\t12.5\n2\t-3.8\n3\t8.2\n4\t-1.5\n5\t15.3\n''`
   (You can write this as a single fprintf call)
   Close the file.

2. Now read the data back using dlmread:
   `data = dlmread(''channel_data.txt'', ''\t'')`

3. Extract the channel numbers (column 1) into `channels` and amplitudes (column 2) into `amplitudes`

4. Display the channel with the highest amplitude. Use max with two outputs to get the index:
   `[max_amp, idx] = max(amplitudes)`
   Then display: the max amplitude and the corresponding channel number',
  '% Step 1: Create the data file


% Step 2: Read data with dlmread


% Step 3: Extract columns


% Step 4: Find and display the channel with highest amplitude
',
  'fid = fopen(''channel_data.txt'', ''w'');
fprintf(fid, ''1\t12.5\n2\t-3.8\n3\t8.2\n4\t-1.5\n5\t15.3\n'');
fclose(fid);
data = dlmread(''channel_data.txt'', ''\t'');
channels = data(:, 1);
amplitudes = data(:, 2);
[max_amp, idx] = max(amplitudes);
disp(max_amp)
disp(channels(idx))',
  '["Write all lines at once: fprintf(fid, ''1\\t12.5\\n2\\t-3.8\\n3\\t8.2\\n4\\t-1.5\\n5\\t15.3\\n''). The \\t creates tabs between values","dlmread(''channel_data.txt'', ''\\t'') reads the tab-separated file into a matrix. Then use data(:, 1) and data(:, 2) to extract columns","[max_amp, idx] = max(amplitudes) returns both the maximum value and its position. Use channels(idx) to get the channel number"]',
  '[{"expected_output":"15.300\n5\n"}]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (10, 3, 'Batch process filenames',
  'In a real experiment, you need to generate filenames for multiple subjects and sessions. Practice building filenames in a loop.

1. Create a loop that goes through subject numbers 1, 2, and 3
2. For each subject, create another loop for sessions 1 and 2
3. Inside the inner loop, use `sprintf` to create a filename in the format:
   `''sub-01_ses-01_eeg.mat''` (with zero-padded 2-digit numbers)
4. Display each filename using disp

The output should be 6 filenames total.',
  '% Loop through subjects and sessions to generate filenames
',
  'for sub = 1:3
    for ses = 1:2
        filename = sprintf(''sub-%02d_ses-%02d_eeg.mat'', sub, ses);
        disp(filename)
    end
end',
  '["Use two nested for loops: for sub = 1:3 and for ses = 1:2","sprintf(''sub-%02d_ses-%02d_eeg.mat'', sub, ses) creates a formatted string. %02d means a 2-digit zero-padded integer","The complete structure is: for sub = 1:3, for ses = 1:2, filename = sprintf(..., sub, ses); disp(filename), end, end"]',
  '[{"expected_output":"sub-01_ses-01_eeg.mat\nsub-01_ses-02_eeg.mat\nsub-02_ses-01_eeg.mat\nsub-02_ses-02_eeg.mat\nsub-03_ses-01_eeg.mat\nsub-03_ses-02_eeg.mat\n"}]',
  false);


-- ============================================
-- Lesson 11: Understanding Signals
-- ============================================
INSERT INTO lessons (id, phase, order_num, title, description, difficulty, estimated_minutes, content_md)
VALUES (11, 3, 1, 'Understanding Signals',
  'Learn what signals are, how sampling works, and why the Nyquist theorem matters — all through the lens of brain wave recordings.',
  'intermediate', 30,
  '# Understanding Signals

Every thought you have, every memory you recall, every sensation you feel — your brain produces **electrical signals** while doing all of it. In this lesson, you''ll learn how we capture and represent those signals digitally.

## What Is a Signal?

A **signal** is simply a quantity that changes over time. When a neuroscientist places electrodes on your scalp (an EEG recording), they measure tiny voltage changes — typically between 10 and 100 microvolts. That voltage going up and down over time **is** your brain signal.

In MATLAB, we represent a signal as a **vector of numbers** — one number for each point in time:

```matlab
% A tiny example signal: 5 voltage measurements over time
signal = [0.2, 0.5, 0.8, 0.4, 0.1];
```

That''s it! A signal is just a list of numbers captured at regular intervals.

## Time Series and Sampling Rate

When we record EEG, we don''t capture the voltage **continuously** — we take snapshots at regular intervals. This is called **sampling**.

The **sampling rate** (also called sampling frequency, abbreviated `Fs` or `fs`) tells you how many snapshots per second you take. It''s measured in **Hertz (Hz)**.

- **256 Hz** = 256 samples per second (common in clinical EEG)
- **512 Hz** = 512 samples per second (common in research EEG)
- **1000 Hz** = 1000 samples per second (high-resolution recordings)

If you record for 2 seconds at 256 Hz, you get:

```matlab
Fs = 256;             % Sampling rate in Hz
duration = 2;         % Duration in seconds
num_samples = Fs * duration;  % 512 samples total!
```

## Creating a Time Vector

To work with signals, we need a **time vector** — a list of time points at which each sample was taken:

```matlab
Fs = 256;                           % 256 samples per second
duration = 1;                       % 1 second
t = 0 : 1/Fs : duration - 1/Fs;    % Time vector from 0 to ~1 second
```

The spacing between time points is `1/Fs`. At 256 Hz, each sample is `1/256 = 0.0039` seconds apart.

## Sine Waves: The Building Blocks

Here''s a beautiful fact: **every brain signal can be broken down into a combination of sine waves** at different frequencies. This is the foundation of EEG analysis.

A sine wave is the simplest possible signal — a smooth, repeating oscillation:

```matlab
Fs = 256;                    % Sampling rate
t = 0 : 1/Fs : 1 - 1/Fs;    % 1 second time vector
freq = 10;                   % 10 Hz (alpha brain wave!)
signal = sin(2 * pi * freq * t);
```

The formula `sin(2 * pi * freq * t)` creates a sine wave at the specified frequency. Think of `2 * pi * freq` as "how fast the wave oscillates." A 10 Hz wave completes 10 full cycles per second — that''s the **alpha rhythm**, associated with relaxation and closing your eyes!

## Brain Wave Frequency Bands

Neuroscientists organize brain waves by frequency:

| Band | Frequency | Associated With |
|------|-----------|----------------|
| **Delta** | 0.5 - 4 Hz | Deep sleep |
| **Theta** | 4 - 8 Hz | Drowsiness, meditation |
| **Alpha** | 8 - 13 Hz | Relaxed, eyes closed |
| **Beta** | 13 - 30 Hz | Active thinking, focus |
| **Gamma** | 30 - 100 Hz | Higher cognitive functions |

## The Nyquist Theorem: Why Sampling Rate Matters

Here''s a critical rule in signal processing:

> **To accurately capture a frequency, you must sample at least TWICE as fast as that frequency.**

This is the **Nyquist theorem**. The highest frequency you can reliably measure is called the **Nyquist frequency**:

```
Nyquist frequency = Sampling rate / 2
```

For example, if your EEG samples at 256 Hz:
- Nyquist frequency = 256 / 2 = **128 Hz**
- You can accurately capture any brain wave up to 128 Hz
- That covers all standard brain wave bands (delta through gamma)!

If you tried to capture a 200 Hz signal with 256 Hz sampling, it would appear as a **different, lower frequency** — a phenomenon called **aliasing**. It''s like trying to film a helicopter rotor with a slow camera — the blades appear to spin backwards!

## Combining Signals

Real EEG is never a single clean sine wave. It''s a **mixture** of many frequencies all happening at once. We can simulate this:

```matlab
Fs = 256;
t = 0 : 1/Fs : 1 - 1/Fs;
alpha = sin(2 * pi * 10 * t);     % 10 Hz alpha wave
beta = 0.5 * sin(2 * pi * 20 * t); % 20 Hz beta wave (half amplitude)
eeg_simulated = alpha + beta;      % Combined signal!
```

This gives you a signal that looks like a wobbly wave — the large slow alpha rhythm with the smaller, faster beta rhythm riding on top. This is exactly what real EEG looks like!

## Summary

- **Signals** are sequences of numbers measured over time
- **Sampling rate** determines how many measurements per second
- **Sine waves** are the building blocks — brain waves are categorized by their frequency
- The **Nyquist theorem** says you need at least 2x the frequency as your sampling rate
- Real brain signals are **combinations** of many frequencies');

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (11, 1, 'Create an alpha brain wave',
  'Create a 10 Hz sine wave (alpha brain wave) that lasts for 1 second, using a sampling rate of 256 Hz.

1. Set the sampling rate `Fs` to 256
2. Create a time vector `t` from 0 to just before 1 second, with steps of `1/Fs`
3. Create the sine wave in a variable called `signal` using `sin(2 * pi * freq * t)` with `freq = 10`
4. Display the number of samples (the length of the signal) using `disp(length(signal))`
5. Display the value of the signal at sample 1 (it should be 0 since sin(0) = 0) using `disp(signal(1))`',
  '% Create a 10 Hz alpha wave at 256 Hz sampling rate
Fs = 256;
freq = 10;

% Create time vector (0 to just under 1 second)

% Create the sine wave signal

% Display the number of samples

% Display the first sample value
',
  'Fs = 256;
freq = 10;
t = 0 : 1/Fs : 1 - 1/Fs;
signal = sin(2 * pi * freq * t);
disp(length(signal))
disp(signal(1))',
  '["The time vector goes from 0 to (1 - 1/Fs) with steps of 1/Fs. Use the colon operator: t = 0 : 1/Fs : 1 - 1/Fs","The sine wave formula is: signal = sin(2 * pi * freq * t) where freq is 10.","Use length(signal) to get the number of samples and signal(1) to get the first value. The full solution: t = 0:1/Fs:1-1/Fs; signal = sin(2*pi*freq*t); disp(length(signal)); disp(signal(1))"]',
  '[{"expected_output":"256\n0\n"}]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (11, 2, 'Calculate Nyquist frequencies',
  'A neuroscience lab has three EEG systems with different sampling rates: 256 Hz, 512 Hz, and 1000 Hz.

For each system, calculate the Nyquist frequency (the maximum frequency that can be accurately captured) and display it.

Remember: Nyquist frequency = Sampling rate / 2

Display each result on its own line using disp().',
  '% Three EEG systems
Fs1 = 256;
Fs2 = 512;
Fs3 = 1000;

% Calculate and display each Nyquist frequency
',
  'Fs1 = 256;
Fs2 = 512;
Fs3 = 1000;
disp(Fs1 / 2)
disp(Fs2 / 2)
disp(Fs3 / 2)',
  '["The Nyquist frequency is simply the sampling rate divided by 2.","For each system: nyquist = Fs / 2. Then use disp() to show it.","disp(Fs1 / 2); disp(Fs2 / 2); disp(Fs3 / 2) — this will print 128, 256, and 500."]',
  '[{"expected_output":"128\n256\n500\n"}]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (11, 3, 'Combine alpha and beta brain waves',
  'Create a simulated EEG signal that combines two brain wave rhythms and visualize them.

1. An **alpha wave** at 10 Hz with amplitude 1.0
2. A **beta wave** at 20 Hz with amplitude 0.5

Use a sampling rate of 256 Hz and a duration of 1 second.

Combine them by adding: `eeg = alpha + beta`

Display the total number of samples: `disp(length(eeg))`

Then create a plot with 3 subplots showing:
- Top: the alpha wave alone
- Middle: the beta wave alone
- Bottom: the combined EEG signal

Add a title to each subplot. This will help you SEE how brain waves combine!',
  '% Sampling parameters
Fs = 256;
t = 0 : 1/Fs : 1 - 1/Fs;

% Create alpha wave (10 Hz, amplitude 1.0)

% Create beta wave (20 Hz, amplitude 0.5)

% Combine into EEG signal

% Display number of samples

% Plot all three signals in subplots
',
  'Fs = 256;
t = 0 : 1/Fs : 1 - 1/Fs;
alpha = sin(2 * pi * 10 * t);
beta = 0.5 * sin(2 * pi * 20 * t);
eeg = alpha + beta;
disp(length(eeg))
subplot(3, 1, 1);
plot(t, alpha);
title(''Alpha Wave (10 Hz)'');
subplot(3, 1, 2);
plot(t, beta);
title(''Beta Wave (20 Hz)'');
subplot(3, 1, 3);
plot(t, eeg);
title(''Combined EEG Signal'');',
  '["Alpha wave: alpha = sin(2 * pi * 10 * t). Beta wave: beta = 0.5 * sin(2 * pi * 20 * t). The 0.5 multiplier sets the amplitude.","Combine them by simple addition: eeg = alpha + beta. Display the length with disp(length(eeg)).","Plot with subplot(3,1,1); plot(t, alpha); title(''Alpha Wave (10 Hz)''); then subplot(3,1,2) for beta and subplot(3,1,3) for the combined eeg."]',
  '[{"expected_output":"256\n"}]',
  true);


-- ============================================
-- Lesson 12: Filtering
-- ============================================
INSERT INTO lessons (id, phase, order_num, title, description, difficulty, estimated_minutes, content_md)
VALUES (12, 3, 2, 'Filtering',
  'Learn how to clean up brain signals using filters — removing noise, isolating specific brain wave rhythms, and understanding low-pass, high-pass, and band-pass filtering.',
  'intermediate', 40,
  '# Filtering

Imagine you''re recording someone''s brain waves during meditation. The EEG signal you get is a messy mixture of everything: the brain rhythms you care about, electrical noise from the room, muscle movements, and more. **Filtering** is how we clean up that signal to find what we''re looking for.

## What Is Filtering?

A **filter** is a tool that selectively removes certain frequencies from a signal while keeping others. Think of it like a coffee filter — it lets the liquid through but catches the grounds. In our case, the "liquid" is the brain wave frequencies we want, and the "grounds" are the noise frequencies we don''t.

## Types of Filters

There are three main types:

### 1. Low-Pass Filter
Lets **low frequencies pass** through, blocks high frequencies.
- **Use case**: Removing high-frequency muscle noise from EEG
- "Keep everything below X Hz"

### 2. High-Pass Filter
Lets **high frequencies pass** through, blocks low frequencies.
- **Use case**: Removing slow drift in the EEG signal (electrode movement)
- "Keep everything above X Hz"

### 3. Band-Pass Filter
Lets only a **specific range** (band) of frequencies through.
- **Use case**: Isolating alpha waves (8-13 Hz) from everything else
- "Keep only frequencies between X and Y Hz"

## The Simplest Filter: Moving Average

The easiest filter to understand is the **moving average**. It works by replacing each data point with the average of its neighbors:

```matlab
% A noisy signal
noisy = [1, 5, 2, 8, 3, 7, 2, 6, 1, 5];

% Moving average with window size 3
% For each point, average it with its neighbors
smoothed = zeros(size(noisy));
for i = 2 : length(noisy) - 1
    smoothed(i) = (noisy(i-1) + noisy(i) + noisy(i+1)) / 3;
end
% Handle edges
smoothed(1) = noisy(1);
smoothed(end) = noisy(end);
```

The moving average is a **low-pass filter** — it smooths out rapid changes (high frequencies) while preserving slow trends (low frequencies). The larger the window, the more smoothing you get.

## Using Convolution for Filtering

A more elegant way to apply a moving average is using **convolution** with the `conv` function:

```matlab
% Create a moving average kernel (window)
window_size = 5;
kernel = ones(1, window_size) / window_size;  % e.g., [0.2, 0.2, 0.2, 0.2, 0.2]

% Apply filter using convolution
smoothed = conv(signal, kernel, ''same'');
```

The `kernel` is like a recipe: `ones(1, 5) / 5` says "take 5 points and average them equally." The `''same''` option keeps the output the same length as the input.

## Building a Simple Low-Pass Filter

For a more proper low-pass filter, we can create a **sinc-based FIR filter** (Finite Impulse Response). Don''t worry about the math — here''s the intuition:

- A low-pass filter with cutoff frequency `fc` keeps all frequencies below `fc`
- We design a small "kernel" (a list of numbers) that does this
- We apply it using `conv()`

```matlab
% Design a simple low-pass FIR filter
function filtered = simple_lowpass(signal, Fs, cutoff_freq, filter_order)
    % Normalized cutoff (0 to 1, where 1 = Nyquist)
    fc = cutoff_freq / (Fs / 2);
    
    % Create sinc-based filter kernel
    n = -(filter_order/2) : (filter_order/2);
    kernel = sinc(2 * fc * n) .* (2 * fc);
    
    % Apply Hamming window to reduce artifacts
    w = 0.54 - 0.46 * cos(2 * pi * (0:filter_order) / filter_order);
    kernel = kernel .* w;
    
    % Normalize so gains sum to 1
    kernel = kernel / sum(kernel);
    
    % Apply filter
    filtered = conv(signal, kernel, ''same'');
end
```

## Band-Pass Filtering

To isolate a specific brain wave band (like alpha at 8-13 Hz), we use a **band-pass filter**. Conceptually, it''s a combination of a high-pass (remove everything below 8 Hz) and a low-pass (remove everything above 13 Hz).

A simple approach is to subtract two low-pass filtered versions of the signal:

```matlab
% Band-pass by subtracting two low-pass filters
low_part = simple_lowpass(signal, Fs, 13, 100);   % Keep below 13 Hz
very_low_part = simple_lowpass(signal, Fs, 8, 100); % Keep below 8 Hz
alpha_band = low_part - very_low_part;              % What''s left is 8-13 Hz!
```

## Why Filtering Matters in Neuroscience

Filtering is one of the **most important preprocessing steps** in any EEG study:

1. **High-pass at 0.1-1 Hz**: Removes slow electrode drift
2. **Low-pass at 40-50 Hz**: Removes muscle noise and electrical interference
3. **Notch filter at 50/60 Hz**: Removes power line noise
4. **Band-pass for specific rhythms**: Isolate alpha/beta/theta for analysis

Every EEG paper you read will describe their filtering pipeline. Now you understand what they''re doing!

## Summary

- **Filters** remove unwanted frequencies from signals
- **Low-pass**: keeps low frequencies, removes high
- **High-pass**: keeps high frequencies, removes low
- **Band-pass**: keeps only a specific frequency range
- **Moving average** is the simplest low-pass filter
- **Convolution** (`conv`) is how we apply filters in code
- Filtering is **essential** for cleaning EEG data before analysis');

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (12, 1, 'Smooth a noisy brain signal',
  'A neuroscience researcher has a noisy EEG recording. Apply a **moving average filter** to smooth it out.

1. Create a noisy signal by combining a 5 Hz sine wave with random noise:
   - Use `Fs = 256` and 1 second of data
   - `clean = sin(2 * pi * 5 * t)`
   - `noisy = clean + 0.5 * randn(size(t))`
   - IMPORTANT: set the random seed first with `randn(''state'', 42)` so results are reproducible

2. Create a moving average kernel of window size 15:
   - `kernel = ones(1, 15) / 15`

3. Apply the filter using convolution:
   - `smoothed = conv(noisy, kernel, ''same'')`

4. Plot three subplots showing: (a) the clean signal, (b) the noisy signal, (c) the smoothed signal. Give each subplot a title.',
  '% Set random seed for reproducibility
randn(''state'', 42);

% Parameters
Fs = 256;
t = 0 : 1/Fs : 1 - 1/Fs;

% Create clean signal (5 Hz sine wave)

% Add noise

% Create moving average kernel (window size 15)

% Apply filter using conv()

% Plot results in 3 subplots
',
  'randn(''state'', 42);
Fs = 256;
t = 0 : 1/Fs : 1 - 1/Fs;
clean = sin(2 * pi * 5 * t);
noisy = clean + 0.5 * randn(size(t));
kernel = ones(1, 15) / 15;
smoothed = conv(noisy, kernel, ''same'');
subplot(3, 1, 1);
plot(t, clean);
title(''Clean Signal (5 Hz)'');
subplot(3, 1, 2);
plot(t, noisy);
title(''Noisy Signal'');
subplot(3, 1, 3);
plot(t, smoothed);
title(''Smoothed Signal (Moving Average)'');',
  '["Create the clean signal first: clean = sin(2 * pi * 5 * t). Then add noise: noisy = clean + 0.5 * randn(size(t)).","The kernel for a moving average of size 15 is: kernel = ones(1, 15) / 15. Apply it with: smoothed = conv(noisy, kernel, ''same'').","For plotting use subplot(3,1,1); plot(t,clean); title(''Clean Signal (5 Hz)''); then repeat for noisy and smoothed in subplot(3,1,2) and subplot(3,1,3)."]',
  '[]',
  true);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (12, 2, 'Build a simple low-pass filter',
  'Create a simple low-pass filter using a sinc function and apply it to remove high-frequency noise from an EEG signal.

1. Define this function at the TOP of your code:
```
function filtered = simple_lowpass(signal, Fs, cutoff, order)
    fc = cutoff / (Fs / 2);
    n = -(order/2) : (order/2);
    h = sinc(2 * fc * n) .* (2 * fc);
    w = 0.54 - 0.46 * cos(2 * pi * (0:order) / order);
    h = h .* w;
    h = h / sum(h);
    filtered = conv(signal, h, ''same'');
end
```

2. Then create a test signal: combine a 5 Hz wave (brain signal) + a 50 Hz wave (electrical noise), using `Fs = 256`, 1 second duration.

3. Apply the low-pass filter with a cutoff of 20 Hz and filter order 80.

4. Plot two subplots: (a) the original mixed signal, (b) the filtered signal (the 50 Hz noise should be removed!). Add titles to each.',
  '% Define the low-pass filter function FIRST

% Then your main code below:
Fs = 256;
t = 0 : 1/Fs : 1 - 1/Fs;

% Create signal: 5 Hz brain wave + 50 Hz noise

% Apply low-pass filter (cutoff = 20 Hz, order = 80)

% Plot original and filtered signals
',
  'function filtered = simple_lowpass(signal, Fs, cutoff, order)
    fc = cutoff / (Fs / 2);
    n = -(order/2) : (order/2);
    h = sinc(2 * fc * n) .* (2 * fc);
    w = 0.54 - 0.46 * cos(2 * pi * (0:order) / order);
    h = h .* w;
    h = h / sum(h);
    filtered = conv(signal, h, ''same'');
end

Fs = 256;
t = 0 : 1/Fs : 1 - 1/Fs;
brain_wave = sin(2 * pi * 5 * t);
noise = 0.5 * sin(2 * pi * 50 * t);
mixed = brain_wave + noise;
filtered = simple_lowpass(mixed, Fs, 20, 80);
subplot(2, 1, 1);
plot(t, mixed);
title(''Original Signal (5 Hz + 50 Hz noise)'');
subplot(2, 1, 2);
plot(t, filtered);
title(''After Low-Pass Filter (cutoff = 20 Hz)'');',
  '["Put the function definition at the very top of your code. Then below it: brain_wave = sin(2*pi*5*t); noise = 0.5*sin(2*pi*50*t); mixed = brain_wave + noise;","Apply the filter: filtered = simple_lowpass(mixed, Fs, 20, 80). The cutoff of 20 Hz means the 50 Hz noise gets removed but the 5 Hz brain wave stays.","Plot with: subplot(2,1,1); plot(t, mixed); title(''Original Signal (5 Hz + 50 Hz noise)''); subplot(2,1,2); plot(t, filtered); title(''After Low-Pass Filter (cutoff = 20 Hz)'');"]',
  '[]',
  true);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (12, 3, 'Extract alpha waves with a band-pass filter',
  'A researcher is studying alpha brain waves during a relaxation experiment. The EEG signal contains delta (2 Hz), alpha (10 Hz), and beta (25 Hz) components. Use band-pass filtering to extract ONLY the alpha waves (8-13 Hz).

1. Define the `simple_lowpass` function at the TOP (same as previous exercise).

2. Create a composite signal with three components:
   - `delta = sin(2 * pi * 2 * t)` (amplitude 1)
   - `alpha = 1.5 * sin(2 * pi * 10 * t)` (amplitude 1.5 — the strongest rhythm during relaxation!)
   - `beta = 0.3 * sin(2 * pi * 25 * t)` (amplitude 0.3)
   - `eeg = delta + alpha + beta`

3. Band-pass filter (8-13 Hz) using the subtraction trick:
   - `low_passed = simple_lowpass(eeg, Fs, 13, 100)` (keep everything below 13 Hz)
   - `very_low_passed = simple_lowpass(eeg, Fs, 8, 100)` (keep everything below 8 Hz)
   - `alpha_extracted = low_passed - very_low_passed` (what remains is 8-13 Hz!)

4. Plot three subplots: (a) the full EEG signal, (b) the original alpha component, (c) the extracted alpha band. Add titles.',
  '% Define the low-pass filter function FIRST

% Main code
Fs = 256;
t = 0 : 1/Fs : 1 - 1/Fs;

% Create composite EEG signal

% Band-pass filter: subtract two low-pass filters

% Plot results in 3 subplots
',
  'function filtered = simple_lowpass(signal, Fs, cutoff, order)
    fc = cutoff / (Fs / 2);
    n = -(order/2) : (order/2);
    h = sinc(2 * fc * n) .* (2 * fc);
    w = 0.54 - 0.46 * cos(2 * pi * (0:order) / order);
    h = h .* w;
    h = h / sum(h);
    filtered = conv(signal, h, ''same'');
end

Fs = 256;
t = 0 : 1/Fs : 1 - 1/Fs;
delta = sin(2 * pi * 2 * t);
alpha = 1.5 * sin(2 * pi * 10 * t);
beta = 0.3 * sin(2 * pi * 25 * t);
eeg = delta + alpha + beta;
low_passed = simple_lowpass(eeg, Fs, 13, 100);
very_low_passed = simple_lowpass(eeg, Fs, 8, 100);
alpha_extracted = low_passed - very_low_passed;
subplot(3, 1, 1);
plot(t, eeg);
title(''Full EEG Signal (delta + alpha + beta)'');
subplot(3, 1, 2);
plot(t, alpha);
title(''Original Alpha Component (10 Hz)'');
subplot(3, 1, 3);
plot(t, alpha_extracted);
title(''Extracted Alpha Band (8-13 Hz)'');',
  '["Start by creating the three components: delta = sin(2*pi*2*t); alpha = 1.5*sin(2*pi*10*t); beta = 0.3*sin(2*pi*25*t); eeg = delta + alpha + beta;","The band-pass trick: low_passed = simple_lowpass(eeg, Fs, 13, 100); very_low_passed = simple_lowpass(eeg, Fs, 8, 100); alpha_extracted = low_passed - very_low_passed;","Plot with subplot(3,1,1); plot(t,eeg); title(''Full EEG Signal (delta + alpha + beta)''); subplot(3,1,2); plot(t,alpha); title(''Original Alpha Component (10 Hz)''); subplot(3,1,3); plot(t,alpha_extracted); title(''Extracted Alpha Band (8-13 Hz)'');"]',
  '[]',
  true);


-- ============================================
-- Lesson 13: Fourier Transform
-- ============================================
INSERT INTO lessons (id, phase, order_num, title, description, difficulty, estimated_minutes, content_md)
VALUES (13, 3, 3, 'Fourier Transform',
  'Discover how the FFT lets you peek inside a brain signal to see which frequencies are present — the foundation of all EEG frequency analysis.',
  'intermediate', 40,
  '# Fourier Transform

Here is one of the most powerful ideas in all of signal processing:

> **Any signal — no matter how complex — can be broken down into a sum of simple sine waves at different frequencies.**

This is the key insight behind the **Fourier Transform**, and it is the reason we can look at a messy EEG recording and say "this person has strong alpha waves" or "this patient''s theta activity is abnormal."

## From Time to Frequency

When you look at an EEG signal plotted over time, you see voltage going up and down. This is the **time domain** — we see *when* things happen.

But often we want to ask: **which frequencies are present?** That''s the **frequency domain**. The Fourier Transform takes you from time domain to frequency domain:

```
Time domain:   "The signal wobbles in a complicated way over 2 seconds"
Frequency domain: "The signal contains 10 Hz (strong), 4 Hz (medium), 25 Hz (weak)"
```

It''s like listening to a chord on a piano and being able to identify the individual notes.

## The FFT: Fast Fourier Transform

The **FFT** (Fast Fourier Transform) is the algorithm that computes the Fourier Transform efficiently. In MATLAB/Octave, it''s just one function call:

```matlab
Y = fft(signal);
```

That''s it! But the output `Y` is a vector of **complex numbers** (numbers with real and imaginary parts). What we usually care about is the **magnitude** — how strong each frequency is:

```matlab
magnitude = abs(Y);   % abs() gets the magnitude of complex numbers
```

## Building the Frequency Axis

The FFT gives you magnitudes, but you also need to know **which frequency** each value corresponds to. Here''s how to create the frequency axis:

```matlab
Fs = 256;                      % Sampling rate
N = length(signal);            % Number of samples
f = (0 : N-1) * (Fs / N);     % Frequency vector
```

Important: the FFT output is **symmetric** — the second half is a mirror of the first half. We only need the first half (up to the Nyquist frequency):

```matlab
half = 1 : floor(N/2);    % Indices for the first half
f_half = f(half);          % Frequencies for first half
mag_half = magnitude(half); % Magnitudes for first half
```

## A Complete FFT Example

Let''s analyze a simple 10 Hz sine wave:

```matlab
% Create a 10 Hz signal
Fs = 256;
t = 0 : 1/Fs : 1 - 1/Fs;
signal = sin(2 * pi * 10 * t);

% Compute FFT
Y = fft(signal);
magnitude = abs(Y);

% Frequency axis (first half only)
N = length(signal);
f = (0 : N-1) * (Fs / N);
half = 1 : floor(N/2);

% Plot
plot(f(half), magnitude(half));
xlabel(''Frequency (Hz)'');
ylabel(''Magnitude'');
title(''Frequency Spectrum'');
```

You''ll see a sharp peak at exactly 10 Hz. That''s the FFT telling you: "there is a 10 Hz component in your signal!"

## Power Spectrum

In neuroscience, we usually look at the **power spectrum** rather than the magnitude spectrum. Power is simply the magnitude squared, often normalized by the number of samples:

```matlab
power = (abs(Y) .^ 2) / N;
```

Or equivalently, `power = magnitude .^ 2 / N`.

Power tells you how much **energy** is at each frequency. When neuroscientists say "alpha power increased during meditation," they mean the power at 8-13 Hz went up.

## Brain Wave Frequency Bands (Reminder)

Here''s why the FFT matters for neuroscience — these are the frequency bands we look for:

| Band | Frequency Range | What It Tells Us |
|------|----------------|------------------|
| **Delta** | 0.5 - 4 Hz | Deep sleep, brain injury |
| **Theta** | 4 - 8 Hz | Drowsiness, memory encoding, meditation |
| **Alpha** | 8 - 13 Hz | Relaxation, idling, eyes closed |
| **Beta** | 13 - 30 Hz | Active thinking, concentration, anxiety |
| **Gamma** | 30 - 100 Hz | Binding, consciousness, perception |

The FFT lets us **measure** the strength of each of these bands in any EEG recording.

## Finding Peak Frequency

To find the **dominant frequency** in a signal (the loudest "note"):

```matlab
[peak_value, peak_index] = max(magnitude(half));
peak_frequency = f(peak_index);
disp([''Peak frequency: '' num2str(peak_frequency) '' Hz'']);
```

The `max()` function returns both the maximum value and its **index** (position). We then look up what frequency that index corresponds to.

## Analyzing a Complex Signal

Real EEG has many frequencies mixed together. Let''s see the FFT pull them apart:

```matlab
Fs = 256;
t = 0 : 1/Fs : 2 - 1/Fs;  % 2 seconds for better resolution

% Simulate EEG with multiple brain waves
delta = 2.0 * sin(2 * pi * 2 * t);     % Strong delta
alpha = 1.5 * sin(2 * pi * 10 * t);    % Strong alpha
beta  = 0.5 * sin(2 * pi * 20 * t);    % Weak beta
eeg = delta + alpha + beta;

% FFT
Y = fft(eeg);
magnitude = abs(Y);
N = length(eeg);
f = (0 : N-1) * (Fs / N);
half = 1 : floor(N/2);

plot(f(half), magnitude(half));
```

You''ll see three distinct peaks at 2, 10, and 20 Hz — the FFT perfectly separates the mixed frequencies!

## Frequency Resolution

One important detail: the **frequency resolution** (how precisely you can distinguish nearby frequencies) depends on the duration of your signal:

```
Frequency resolution = Fs / N = 1 / duration
```

So a 1-second recording gives 1 Hz resolution (you can tell 10 Hz from 11 Hz but not 10 Hz from 10.5 Hz). A 2-second recording gives 0.5 Hz resolution. Longer recordings give better frequency precision.

## Summary

- The **Fourier Transform** converts signals from time domain to frequency domain
- **FFT** (`fft()`) is the fast algorithm to compute it
- Use `abs()` to get **magnitude** from the complex FFT output
- **Power spectrum** = magnitude squared (divided by N)
- Build a **frequency axis** to know which frequency each FFT bin represents
- Only use the **first half** of the FFT (the rest is a mirror)
- The FFT is how neuroscientists measure **brain wave band power**');

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (13, 1, 'Find the frequency of a sine wave',
  'Use the FFT to analyze a mystery sine wave and find its frequency.

1. Create a sine wave at 15 Hz (but pretend you don''t know the frequency!):
   - `Fs = 256; t = 0:1/Fs:1-1/Fs;`
   - `signal = sin(2 * pi * 15 * t);`

2. Compute the FFT and get the magnitude:
   - `Y = fft(signal);`
   - `magnitude = abs(Y);`

3. Create the frequency axis (first half only):
   - `N = length(signal);`
   - `f = (0 : N-1) * (Fs / N);`
   - `half = 1 : floor(N/2);`

4. Find the peak frequency:
   - Use `[peak_val, peak_idx] = max(magnitude(half));`
   - `peak_freq = f(peak_idx);`

5. Display the peak frequency: `disp(peak_freq)`',
  '% Create the signal
Fs = 256;
t = 0 : 1/Fs : 1 - 1/Fs;
signal = sin(2 * pi * 15 * t);

% Compute FFT

% Get magnitude

% Create frequency axis

% Find and display peak frequency
',
  'Fs = 256;
t = 0 : 1/Fs : 1 - 1/Fs;
signal = sin(2 * pi * 15 * t);
Y = fft(signal);
magnitude = abs(Y);
N = length(signal);
f = (0 : N-1) * (Fs / N);
half = 1 : floor(N/2);
[peak_val, peak_idx] = max(magnitude(half));
peak_freq = f(peak_idx);
disp(peak_freq)',
  '["After creating the signal: Y = fft(signal); magnitude = abs(Y); — this gives you the strength of each frequency.","Create the frequency axis: N = length(signal); f = (0:N-1) * (Fs/N); half = 1:floor(N/2);","Find the peak: [peak_val, peak_idx] = max(magnitude(half)); peak_freq = f(peak_idx); disp(peak_freq). The answer should be 15."]',
  '[{"expected_output":"15\n"}]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (13, 2, 'Calculate the power spectrum',
  'Compute and analyze the power spectrum of a signal containing a 10 Hz alpha wave.

1. Create a 10 Hz sine wave with amplitude 2, lasting 2 seconds:
   - `Fs = 256; t = 0:1/Fs:2-1/Fs;`
   - `signal = 2 * sin(2 * pi * 10 * t);`

2. Compute the FFT and the power spectrum:
   - `Y = fft(signal);`
   - `N = length(signal);`
   - `power = (abs(Y) .^ 2) / N;`

3. Create the frequency axis (first half):
   - `f = (0 : N-1) * (Fs / N);`
   - `half = 1 : floor(N/2);`

4. Find the peak frequency and its power:
   - `[peak_power, peak_idx] = max(power(half));`
   - `peak_freq = f(peak_idx);`

5. Display the peak frequency and the peak power (rounded to 1 decimal):
   - `disp(peak_freq)`
   - `disp(round(peak_power * 10) / 10)`',
  '% Create signal: 10 Hz alpha wave, amplitude 2, 2 seconds
Fs = 256;
t = 0 : 1/Fs : 2 - 1/Fs;
signal = 2 * sin(2 * pi * 10 * t);

% Compute FFT

% Compute power spectrum

% Create frequency axis (first half)

% Find peak frequency and power

% Display peak frequency

% Display peak power (rounded to 1 decimal place)
',
  'Fs = 256;
t = 0 : 1/Fs : 2 - 1/Fs;
signal = 2 * sin(2 * pi * 10 * t);
Y = fft(signal);
N = length(signal);
power = (abs(Y) .^ 2) / N;
f = (0 : N-1) * (Fs / N);
half = 1 : floor(N/2);
[peak_power, peak_idx] = max(power(half));
peak_freq = f(peak_idx);
disp(peak_freq)
disp(round(peak_power * 10) / 10)',
  '["Power spectrum is magnitude squared divided by N: Y = fft(signal); N = length(signal); power = (abs(Y) .^ 2) / N;","Frequency axis: f = (0:N-1) * (Fs/N); half = 1:floor(N/2); Then find the peak: [peak_power, peak_idx] = max(power(half));","Get peak frequency: peak_freq = f(peak_idx); Display: disp(peak_freq) then disp(round(peak_power * 10) / 10). Peak should be at 10 Hz with power 512.0."]',
  '[{"expected_output":"10\n512\n"}]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (13, 3, 'Identify dominant brain wave frequency',
  'A simulated EEG signal contains three brain wave components. Use the FFT to identify the DOMINANT (strongest) frequency.

The signal contains:
- Theta at 6 Hz, amplitude 0.8
- Alpha at 10 Hz, amplitude 2.5 (the dominant rhythm — this person is relaxed!)
- Beta at 22 Hz, amplitude 0.4

1. Create the composite signal (Fs = 256, duration = 2 seconds):
   - `theta = 0.8 * sin(2 * pi * 6 * t);`
   - `alpha = 2.5 * sin(2 * pi * 10 * t);`
   - `beta = 0.4 * sin(2 * pi * 22 * t);`
   - `eeg = theta + alpha + beta;`

2. Compute the FFT magnitude spectrum (first half only)

3. Find the peak frequency

4. Display the dominant frequency using `disp(peak_freq)`

5. Determine which brain wave band the dominant frequency belongs to and display it:
   - If 4-8 Hz: `disp(''theta'')`
   - If 8-13 Hz: `disp(''alpha'')`
   - If 13-30 Hz: `disp(''beta'')`',
  '% Parameters
Fs = 256;
t = 0 : 1/Fs : 2 - 1/Fs;

% Create brain wave components

% Combine into EEG

% Compute FFT and magnitude (first half)

% Find dominant frequency

% Display the dominant frequency

% Display which band it belongs to
',
  'Fs = 256;
t = 0 : 1/Fs : 2 - 1/Fs;
theta = 0.8 * sin(2 * pi * 6 * t);
alpha = 2.5 * sin(2 * pi * 10 * t);
beta = 0.4 * sin(2 * pi * 22 * t);
eeg = theta + alpha + beta;
Y = fft(eeg);
magnitude = abs(Y);
N = length(eeg);
f = (0 : N-1) * (Fs / N);
half = 1 : floor(N/2);
[peak_val, peak_idx] = max(magnitude(half));
peak_freq = f(peak_idx);
disp(peak_freq)
if peak_freq >= 4 && peak_freq < 8
    disp(''theta'')
elseif peak_freq >= 8 && peak_freq <= 13
    disp(''alpha'')
elseif peak_freq > 13 && peak_freq <= 30
    disp(''beta'')
end',
  '["Create the components: theta = 0.8*sin(2*pi*6*t); alpha = 2.5*sin(2*pi*10*t); beta = 0.4*sin(2*pi*22*t); eeg = theta + alpha + beta;","FFT analysis: Y = fft(eeg); magnitude = abs(Y); N = length(eeg); f = (0:N-1)*(Fs/N); half = 1:floor(N/2); [peak_val, peak_idx] = max(magnitude(half)); peak_freq = f(peak_idx);","The dominant frequency should be 10 Hz (alpha has the highest amplitude). Use an if/elseif to check: if peak_freq >= 8 && peak_freq <= 13, disp(''alpha''), end"]',
  '[{"expected_output":"10\nalpha\n"}]',
  false);


-- ============================================
-- Lesson 14: Spectral Analysis
-- ============================================
INSERT INTO lessons (id, phase, order_num, title, description, difficulty, estimated_minutes, content_md)
VALUES (14, 3, 4, 'Spectral Analysis',
  'Dive deeper into frequency analysis with power spectral density, band power calculations, and spectrograms — essential tools for studying how brain rhythms change over time.',
  'advanced', 45,
  '# Spectral Analysis

In the previous lesson, you learned how the FFT reveals which frequencies are present in a signal. Now we''ll take it further with techniques that neuroscientists use every day: calculating **power in specific frequency bands**, comparing power between experimental conditions, and watching **how frequencies change over time** with spectrograms.

## Power Spectral Density (PSD)

The **Power Spectral Density** tells you how power is distributed across frequencies. It''s like the FFT power spectrum, but properly scaled so you can compare between signals of different lengths.

Here''s how to compute a basic PSD:

```matlab
Fs = 256;
N = length(signal);
Y = fft(signal);
PSD = (abs(Y) .^ 2) / (N * Fs);    % Scale by N * Fs
PSD(2:end-1) = 2 * PSD(2:end-1);    % Double non-DC, non-Nyquist components

f = (0 : N-1) * (Fs / N);
half = 1 : floor(N/2);
plot(f(half), PSD(half));
xlabel(''Frequency (Hz)'');
ylabel(''Power/Hz'');
```

The key difference from the regular power spectrum: PSD is normalized so that the **area under the curve** equals the total signal power. This means you can integrate (sum) over a frequency range to get the power in that band.

## Calculating Band Power

This is one of the most common operations in EEG research: **how much power is in the alpha band? The theta band?**

The idea is simple — sum up the PSD values in the frequency range you care about:

```matlab
% Define frequency bands
alpha_range = [8, 13];   % Alpha: 8-13 Hz

% Find which frequency bins fall in this range
f = (0 : N-1) * (Fs / N);
alpha_idx = find(f >= alpha_range(1) & f <= alpha_range(2));

% Sum the power in those bins
alpha_power = sum(PSD(alpha_idx));
```

The `find()` function returns the indices where the condition is true — so `alpha_idx` contains the positions of all frequencies between 8 and 13 Hz.

## Relative Band Power

Often it''s more meaningful to look at **relative** band power — what fraction of total power is in each band:

```matlab
total_power = sum(PSD(half));
alpha_relative = alpha_power / total_power * 100;  % As a percentage
disp([''Alpha band contains '' num2str(alpha_relative) ''% of total power'']);
```

This is useful because absolute power varies between people (thicker skulls attenuate the signal!), but relative power is more consistent.

## Comparing Conditions

A classic neuroscience experiment: compare brain activity between two conditions. For example, alpha power is known to **increase when you close your eyes** (the "alpha blocking" effect discovered in 1929!).

```matlab
% Simulated EEG: eyes open vs eyes closed
% Eyes open: weak alpha
eyes_open = 0.5 * sin(2 * pi * 10 * t) + randn(size(t)) * 0.3;

% Eyes closed: strong alpha
eyes_closed = 2.0 * sin(2 * pi * 10 * t) + randn(size(t)) * 0.3;

% Compare alpha power between conditions
% (Compute PSD for each, then sum in alpha band)
```

This kind of comparison is at the heart of countless EEG studies — meditation vs. rest, healthy vs. patient, before treatment vs. after.

## Spectrograms: Frequency Over Time

The FFT tells you which frequencies are in a signal, but not **when** they occur. A **spectrogram** solves this by breaking the signal into short overlapping windows and computing the FFT of each window.

Think of it like this:
- Chop the signal into short segments (e.g., 0.5 seconds each)
- Compute the FFT of each segment
- Stack the results side by side
- The result shows frequency on the y-axis, time on the x-axis, and color = power

```matlab
% Manual spectrogram using windowed FFT
window_size = 128;     % Samples per window
step_size = 64;        % Step between windows (50% overlap)

num_windows = floor((length(signal) - window_size) / step_size) + 1;
spect = zeros(floor(window_size/2), num_windows);

for i = 1 : num_windows
    start_idx = (i - 1) * step_size + 1;
    segment = signal(start_idx : start_idx + window_size - 1);
    Y = fft(segment);
    spect(:, i) = (abs(Y(1:floor(window_size/2))) .^ 2) / window_size;
end
```

Spectrograms are beautiful and informative — they can show you, for example, how alpha power builds up gradually as someone relaxes, or how theta bursts appear during memory encoding.

## Windowing

When computing the FFT of a short segment, the sharp edges of the segment can create artificial frequencies (called **spectral leakage**). We reduce this by applying a **window function** that smoothly tapers the edges to zero:

```matlab
% Hamming window — the most common choice
w = 0.54 - 0.46 * cos(2 * pi * (0:window_size-1) / (window_size-1));
windowed_segment = segment .* w;
Y = fft(windowed_segment);
```

The Hamming window is the default choice in most EEG toolboxes. It slightly reduces frequency resolution but greatly reduces leakage artifacts.

## Practical Tips for Neuroscience

1. **Always use a window** when computing spectrograms (Hamming is a safe default)
2. **50% overlap** between windows is standard
3. **Longer windows** = better frequency resolution but worse time resolution (a tradeoff!)
4. **Log scale** often helps visualize power: `10 * log10(power)` converts to decibels (dB)
5. **Relative band power** is more robust than absolute power for group comparisons

## Summary

- **PSD** (Power Spectral Density) is the properly scaled power spectrum
- **Band power** is calculated by summing PSD values in a frequency range
- **Relative band power** (percentage of total) is more robust for comparisons
- **Spectrograms** show how frequencies change over time using windowed FFTs
- **Window functions** (like Hamming) reduce spectral leakage artifacts
- These are the core tools neuroscientists use to analyze EEG rhythms');

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (14, 1, 'Calculate brain wave band powers',
  'A simulated EEG signal contains delta, theta, alpha, and beta components. Calculate the power in each frequency band and visualize them as a bar chart.

1. Define a helper function at the TOP:
```
function bp = band_power(psd, f, low_freq, high_freq)
    idx = find(f >= low_freq & f <= high_freq);
    bp = sum(psd(idx));
end
```

2. Create a simulated EEG (Fs=256, 2 seconds):
   - `delta_wave = 1.0 * sin(2*pi*2*t);`
   - `theta_wave = 0.8 * sin(2*pi*6*t);`
   - `alpha_wave = 2.0 * sin(2*pi*10*t);`  (strongest!)
   - `beta_wave = 0.5 * sin(2*pi*20*t);`
   - `eeg = delta_wave + theta_wave + alpha_wave + beta_wave;`

3. Compute PSD:
   - `Y = fft(eeg); N = length(eeg);`
   - `psd = (abs(Y).^2) / (N * Fs);`
   - `psd(2:end-1) = 2 * psd(2:end-1);`
   - `f = (0:N-1) * (Fs/N);`

4. Calculate power in each band using the helper function:
   - Delta: 0.5-4 Hz, Theta: 4-8 Hz, Alpha: 8-13 Hz, Beta: 13-30 Hz

5. Display which band has the most power using max() and a cell array of band names.

6. Create a bar chart of the four band powers:
   - `bar([delta_power, theta_power, alpha_power, beta_power])`
   - `set(gca, ''XTickLabel'', {''Delta'', ''Theta'', ''Alpha'', ''Beta''})`
   - `ylabel(''Power'')` and `title(''EEG Band Power Distribution'')`

The alpha bar should be clearly the tallest!',
  '% Define helper function at TOP

% Main code
Fs = 256;
t = 0 : 1/Fs : 2 - 1/Fs;

% Create EEG components

% Combine into EEG signal

% Compute PSD

% Calculate band powers

% Display the dominant band name

% Create bar chart of band powers
',
  'function bp = band_power(psd, f, low_freq, high_freq)
    idx = find(f >= low_freq & f <= high_freq);
    bp = sum(psd(idx));
end

Fs = 256;
t = 0 : 1/Fs : 2 - 1/Fs;
delta_wave = 1.0 * sin(2 * pi * 2 * t);
theta_wave = 0.8 * sin(2 * pi * 6 * t);
alpha_wave = 2.0 * sin(2 * pi * 10 * t);
beta_wave = 0.5 * sin(2 * pi * 20 * t);
eeg = delta_wave + theta_wave + alpha_wave + beta_wave;
Y = fft(eeg);
N = length(eeg);
psd = (abs(Y) .^ 2) / (N * Fs);
psd(2:end-1) = 2 * psd(2:end-1);
f = (0 : N-1) * (Fs / N);
delta_power = band_power(psd, f, 0.5, 4);
theta_power = band_power(psd, f, 4, 8);
alpha_power = band_power(psd, f, 8, 13);
beta_power = band_power(psd, f, 13, 30);
powers = [delta_power, theta_power, alpha_power, beta_power];
bands = {''delta'', ''theta'', ''alpha'', ''beta''};
[max_val, max_idx] = max(powers);
disp(bands{max_idx})
bar(powers);
set(gca, ''XTickLabel'', {''Delta'', ''Theta'', ''Alpha'', ''Beta''});
ylabel(''Power'');
title(''EEG Band Power Distribution'');',
  '["Put the band_power function at the very top. Then create the EEG: delta_wave=1.0*sin(2*pi*2*t); etc., and eeg = delta_wave + theta_wave + alpha_wave + beta_wave;","Compute PSD: Y=fft(eeg); N=length(eeg); psd=(abs(Y).^2)/(N*Fs); psd(2:end-1)=2*psd(2:end-1); f=(0:N-1)*(Fs/N); Then call: delta_power = band_power(psd, f, 0.5, 4); and similarly for others.","Store powers in a vector: powers = [delta_power, theta_power, alpha_power, beta_power]; bands = {''delta'',''theta'',''alpha'',''beta''}; [max_val, max_idx] = max(powers); disp(bands{max_idx}). Then bar(powers); set(gca, ''XTickLabel'', {''Delta'',''Theta'',''Alpha'',''Beta''});"]',
  '[{"expected_output":"alpha\n"}]',
  true);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (14, 2, 'Compare alpha power: eyes open vs eyes closed',
  'Simulate the classic "alpha blocking" experiment! When you close your eyes, alpha power increases dramatically.

1. Define the `band_power` helper function at the TOP (same as before).

2. Create two conditions (Fs=256, 2 seconds each, set seed with `randn(''state'', 42)`):
   - **Eyes open**: weak alpha (amplitude 0.5) + noise
     `eyes_open = 0.5 * sin(2*pi*10*t) + 0.3 * randn(size(t));`
   - **Eyes closed**: strong alpha (amplitude 2.0) + same noise level
     `eyes_closed = 2.0 * sin(2*pi*10*t) + 0.3 * randn(size(t));`

3. Compute PSD for both signals

4. Calculate alpha band power (8-13 Hz) for both conditions

5. Plot the two PSDs overlaid on ONE plot (frequencies 0-40 Hz only):
   - Use `plot(f(range), psd1(range), ''b'', f(range), psd2(range), ''r'')`
   - Add a legend: `legend(''Eyes Open'', ''Eyes Closed'')`
   - Title: `title(''Alpha Power: Eyes Open vs Closed'')`
   - `xlabel(''Frequency (Hz)'')` and `ylabel(''Power/Hz'')`',
  '% Define band_power function at TOP

% Main code
randn(''state'', 42);
Fs = 256;
t = 0 : 1/Fs : 2 - 1/Fs;

% Create eyes open signal (weak alpha + noise)

% Create eyes closed signal (strong alpha + noise)

% Compute PSD for eyes open

% Compute PSD for eyes closed

% Calculate alpha power for both

% Plot both PSDs (0-40 Hz range)

% Add legend, title, axis labels
',
  'function bp = band_power(psd, f, low_freq, high_freq)
    idx = find(f >= low_freq & f <= high_freq);
    bp = sum(psd(idx));
end

randn(''state'', 42);
Fs = 256;
t = 0 : 1/Fs : 2 - 1/Fs;
eyes_open = 0.5 * sin(2 * pi * 10 * t) + 0.3 * randn(size(t));
eyes_closed = 2.0 * sin(2 * pi * 10 * t) + 0.3 * randn(size(t));
Y1 = fft(eyes_open);
N = length(eyes_open);
psd1 = (abs(Y1) .^ 2) / (N * Fs);
psd1(2:end-1) = 2 * psd1(2:end-1);
Y2 = fft(eyes_closed);
psd2 = (abs(Y2) .^ 2) / (N * Fs);
psd2(2:end-1) = 2 * psd2(2:end-1);
f = (0 : N-1) * (Fs / N);
alpha_open = band_power(psd1, f, 8, 13);
alpha_closed = band_power(psd2, f, 8, 13);
range = find(f >= 0 & f <= 40);
plot(f(range), psd1(range), ''b'', f(range), psd2(range), ''r'');
legend(''Eyes Open'', ''Eyes Closed'');
title(''Alpha Power: Eyes Open vs Closed'');
xlabel(''Frequency (Hz)'');
ylabel(''Power/Hz'');',
  '["Create signals: eyes_open = 0.5*sin(2*pi*10*t) + 0.3*randn(size(t)); eyes_closed = 2.0*sin(2*pi*10*t) + 0.3*randn(size(t));","Compute PSD for each: Y1 = fft(eyes_open); N = length(eyes_open); psd1 = (abs(Y1).^2)/(N*Fs); psd1(2:end-1) = 2*psd1(2:end-1); Repeat for eyes_closed.","Plot with range: range = find(f >= 0 & f <= 40); plot(f(range), psd1(range), ''b'', f(range), psd2(range), ''r''); legend(''Eyes Open'', ''Eyes Closed''); title(''Alpha Power: Eyes Open vs Closed'');"]',
  '[]',
  true);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (14, 3, 'Create a basic spectrogram',
  'Build a spectrogram to visualize how brain wave frequencies change over time!

Simulate a 4-second EEG signal where the dominant rhythm CHANGES:
- Seconds 0-2: strong alpha (10 Hz, amplitude 2) — person is relaxed
- Seconds 2-4: strong beta (20 Hz, amplitude 2) — person starts concentrating

Then create a spectrogram using windowed FFT.

1. Create the changing signal:
```
Fs = 256;
t = 0 : 1/Fs : 4 - 1/Fs;
signal = zeros(size(t));
signal(t < 2) = 2 * sin(2 * pi * 10 * t(t < 2));
signal(t >= 2) = 2 * sin(2 * pi * 20 * t(t >= 2));
```

2. Compute the spectrogram with windowed FFT:
```
window_size = 128;
step_size = 32;
num_windows = floor((length(signal) - window_size) / step_size) + 1;
half_win = floor(window_size / 2);
spect = zeros(half_win, num_windows);
hamming_win = 0.54 - 0.46 * cos(2 * pi * (0:window_size-1) / (window_size-1));
for i = 1 : num_windows
    start_idx = (i - 1) * step_size + 1;
    segment = signal(start_idx : start_idx + window_size - 1);
    segment = segment .* hamming_win;
    Y = fft(segment);
    spect(:, i) = (abs(Y(1:half_win)) .^ 2) / window_size;
end
```

3. Plot the spectrogram:
```
f_axis = (0 : half_win - 1) * (Fs / window_size);
t_axis = ((0 : num_windows - 1) * step_size + window_size / 2) / Fs;
imagesc(t_axis, f_axis, spect);
axis(''xy'');
ylim([0 40]);
xlabel(''Time (s)'');
ylabel(''Frequency (Hz)'');
title(''EEG Spectrogram: Relaxation to Concentration'');
colorbar;
```

You should see alpha (10 Hz) dominating in the first half and beta (20 Hz) in the second half!',
  '% Create a signal that changes from alpha to beta
Fs = 256;
t = 0 : 1/Fs : 4 - 1/Fs;

% First 2 seconds: alpha (10 Hz), Last 2 seconds: beta (20 Hz)

% Compute spectrogram with windowed FFT
window_size = 128;
step_size = 32;

% Create Hamming window

% Loop over windows, compute FFT of each

% Plot the spectrogram using imagesc
',
  'Fs = 256;
t = 0 : 1/Fs : 4 - 1/Fs;
signal = zeros(size(t));
signal(t < 2) = 2 * sin(2 * pi * 10 * t(t < 2));
signal(t >= 2) = 2 * sin(2 * pi * 20 * t(t >= 2));
window_size = 128;
step_size = 32;
num_windows = floor((length(signal) - window_size) / step_size) + 1;
half_win = floor(window_size / 2);
spect = zeros(half_win, num_windows);
hamming_win = 0.54 - 0.46 * cos(2 * pi * (0:window_size-1) / (window_size-1));
for i = 1 : num_windows
    start_idx = (i - 1) * step_size + 1;
    segment = signal(start_idx : start_idx + window_size - 1);
    segment = segment .* hamming_win;
    Y = fft(segment);
    spect(:, i) = (abs(Y(1:half_win)) .^ 2) / window_size;
end
f_axis = (0 : half_win - 1) * (Fs / window_size);
t_axis = ((0 : num_windows - 1) * step_size + window_size / 2) / Fs;
imagesc(t_axis, f_axis, spect);
axis(''xy'');
ylim([0 40]);
xlabel(''Time (s)'');
ylabel(''Frequency (Hz)'');
title(''EEG Spectrogram: Relaxation to Concentration'');
colorbar;',
  '["Create the changing signal: signal = zeros(size(t)); signal(t < 2) = 2*sin(2*pi*10*t(t < 2)); signal(t >= 2) = 2*sin(2*pi*20*t(t >= 2));","The spectrogram loop: for each window, extract a segment, multiply by Hamming window, compute FFT, store the power of the first half. num_windows = floor((length(signal)-window_size)/step_size)+1;","Plot with imagesc(t_axis, f_axis, spect); axis(''xy''); ylim([0 40]); The axis(''xy'') flips the y-axis so low frequencies are at the bottom. Add xlabel, ylabel, title, and colorbar."]',
  '[]',
  true);


-- ============================================
-- Lesson 15: Intro to Neural Data
-- ============================================
INSERT INTO lessons (id, phase, order_num, title, description, difficulty, estimated_minutes, content_md)
VALUES (15, 4, 1, 'Intro to Neural Data',
  'Explore the main types of neuroscience data — EEG, fMRI, spike trains, and calcium imaging — and understand what they measure.',
  'intermediate', 30,
  '# Intro to Neural Data

Welcome to Phase 4! Everything you have learned so far — variables, matrices, plotting, filtering, spectral analysis — was building toward this moment. Now we apply those skills to **real neuroscience problems**.

Your friend who studies meditation and yoga effects on the brain works with several types of neural data every day. Let''s understand what those data types are and how they differ.

## The Big Four: Types of Neural Recording

### 1. EEG (Electroencephalography)
- **What it measures:** Electrical voltages on the scalp produced by large populations of neurons firing together
- **Temporal resolution:** Excellent — millisecond precision (typically 250-1000 Hz sampling)
- **Spatial resolution:** Poor — each electrode picks up activity from millions of neurons
- **Typical data shape:** channels x time points (e.g., 64 channels x 500,000 samples)
- **Why it matters for meditation research:** EEG is the most common tool for studying brain waves during meditation. It is portable, relatively cheap, and captures the fast rhythms (alpha, theta) that change during mindful states.

```matlab
% A single EEG channel is just a time series of voltages
fs = 256;             % sampling rate in Hz
t = 0:1/fs:2;         % 2 seconds of time
eeg_signal = randn(1, length(t)) * 10;  % microvolts (simplified)
```

### 2. fMRI (Functional Magnetic Resonance Imaging)
- **What it measures:** Blood-oxygen-level-dependent (BOLD) signal — an indirect measure of neural activity
- **Temporal resolution:** Poor — one volume every 1-3 seconds
- **Spatial resolution:** Excellent — millimeter precision in 3D
- **Typical data shape:** 3D volume over time (e.g., 64x64x36 voxels x 200 time points)
- **Why it matters:** fMRI can show which brain *regions* are active during meditation, but it cannot capture fast oscillations.

### 3. Spike Trains
- **What it measures:** Action potentials (spikes) from individual neurons, recorded with microelectrodes
- **Temporal resolution:** Superb — sub-millisecond
- **Spatial resolution:** Single neuron
- **Typical data shape:** A list of spike times for each neuron
- **Common in:** Animal research, some human clinical recordings

```matlab
% Spike train: just a list of times when a neuron fired
spike_times = [0.05, 0.12, 0.31, 0.45, 0.52, 0.78, 0.91];
```

### 4. Calcium Imaging
- **What it measures:** Fluorescence changes linked to intracellular calcium, which rises when neurons fire
- **Temporal resolution:** Moderate (10-30 Hz typically)
- **Spatial resolution:** Single neuron (can image hundreds simultaneously)
- **Typical data shape:** neurons x time points (fluorescence traces)

## Resolution Trade-offs

There is a fundamental trade-off in neuroscience:

| Technique | Temporal Res. | Spatial Res. | Invasive? |
|---|---|---|---|
| EEG | ~1 ms | ~cm | No |
| fMRI | ~1 s | ~mm | No |
| Spikes | ~0.1 ms | Single neuron | Yes |
| Calcium | ~30 ms | Single neuron | Yes |

No single technique gives you both high temporal AND high spatial resolution non-invasively. Researchers choose based on their question.

## Working with Simulated Data

Since we cannot load real data files in this environment, we will **simulate** realistic neural data. This is actually a critical skill — computational neuroscientists build simulated datasets all the time to test their analysis pipelines before applying them to real data.

```matlab
% Simulating data lets you control the ground truth
% If you put a 10 Hz signal into simulated EEG,
% your analysis SHOULD find a 10 Hz peak!
```

In the exercises below, you will create each type of data from scratch.');

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (15, 1, 'Create simulated spike train data',
  'Simulate spike train data for a neuron firing at approximately 20 Hz (20 spikes per second) over a 5-second recording.

Use a Poisson process: at each 1 ms time bin, the probability of a spike is firing_rate * dt.

Steps:
1. Set the firing rate to 20 Hz and duration to 5 seconds
2. Create time bins of 1 ms (dt = 0.001)
3. Use rand to generate random numbers and compare to (firing_rate * dt) to determine spikes
4. Extract spike times from the binary spike vector
5. Display the number of spikes and the measured firing rate (num_spikes / duration)

Use rand("state", 42); randn("state", 42) for reproducibility.',
  '% Simulate a Poisson spike train
rand("state", 42); randn("state", 42);

firing_rate = 20;  % Hz
duration = 5;      % seconds
dt = 0.001;        % 1 ms bins

% Create time vector
time_bins = 0:dt:duration-dt;

% Generate spikes: random number < firing_rate*dt means a spike
% YOUR CODE HERE

% Extract spike times (times where spikes occurred)
% YOUR CODE HERE

% Display results
% YOUR CODE HERE
',
  'rand("state", 42); randn("state", 42);

firing_rate = 20;
duration = 5;
dt = 0.001;

time_bins = 0:dt:duration-dt;

spike_vector = rand(1, length(time_bins)) < (firing_rate * dt);

spike_times = time_bins(spike_vector);

num_spikes = length(spike_times);
measured_rate = num_spikes / duration;

disp([''Number of spikes: '' num2str(num_spikes)]);
disp([''Measured firing rate: '' num2str(measured_rate) '' Hz'']);',
  '["A Poisson spike train: generate a random number for each time bin using rand(1, length(time_bins)). If the random number is less than firing_rate * dt, that bin has a spike.","Create a logical vector: spike_vector = rand(1, length(time_bins)) < (firing_rate * dt); Then get spike times: spike_times = time_bins(spike_vector);","Count spikes with length(spike_times) and divide by duration to get the measured rate. Display with disp([''Number of spikes: '' num2str(num_spikes)]);"]',
  '[{"expected_output":"Number of spikes: 89\nMeasured firing rate: 17.8 Hz\n"}]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (15, 2, 'Simulate a basic EEG-like signal',
  'Create a simulated EEG signal that contains three frequency components commonly found in brain recordings:
- Alpha waves: 10 Hz, amplitude 20 microvolts
- Beta waves: 22 Hz, amplitude 8 microvolts
- Theta waves: 6 Hz, amplitude 15 microvolts

Plus random noise with standard deviation of 5 microvolts.

Steps:
1. Set sampling rate to 256 Hz, duration to 2 seconds
2. Create the time vector
3. Build each sine component and add them together with noise
4. Display the total number of samples, the min voltage (rounded to 1 decimal), and the max voltage (rounded to 1 decimal)

Use rand("state", 10); randn("state", 10) for reproducibility.',
  '% Simulate multi-component EEG signal
rand("state", 10); randn("state", 10);

fs = 256;           % sampling rate (Hz)
duration = 2;       % seconds
t = 0:1/fs:duration-1/fs;

% Create frequency components
% Alpha (10 Hz, amplitude 20 uV)
% Beta (22 Hz, amplitude 8 uV)
% Theta (6 Hz, amplitude 15 uV)
% YOUR CODE HERE

% Add noise (std = 5 uV)
% YOUR CODE HERE

% Combine into final EEG signal
% YOUR CODE HERE

% Display properties
% YOUR CODE HERE
',
  'rand("state", 10); randn("state", 10);

fs = 256;
duration = 2;
t = 0:1/fs:duration-1/fs;

alpha = 20 * sin(2 * pi * 10 * t);
beta = 8 * sin(2 * pi * 22 * t);
theta = 15 * sin(2 * pi * 6 * t);

noise = 5 * randn(1, length(t));

eeg_signal = alpha + beta + theta + noise;

disp([''Total samples: '' num2str(length(eeg_signal))]);
disp([''Min voltage: '' num2str(round(min(eeg_signal)*10)/10) '' uV'']);
disp([''Max voltage: '' num2str(round(max(eeg_signal)*10)/10) '' uV'']);',
  '["Each sine component follows the pattern: amplitude * sin(2 * pi * frequency * t). For example, alpha = 20 * sin(2 * pi * 10 * t);","Generate noise with randn: noise = 5 * randn(1, length(t)); Then combine: eeg_signal = alpha + beta + theta + noise;","For rounding to 1 decimal: round(value*10)/10. Display with disp([''Min voltage: '' num2str(round(min(eeg_signal)*10)/10) '' uV'']);"]',
  '[{"expected_output":"Total samples: 512\nMin voltage: -42.4 uV\nMax voltage: 44.6 uV\n"}]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (15, 3, 'Compare recording technique properties',
  'Create a summary of four neural recording techniques by calculating key properties.

For each technique, compute:
- Number of time points in a 10-second recording at its typical sampling rate
- Data size: time_points * num_channels (approximate number of data values)

Use these parameters:
- EEG: 256 Hz, 64 channels
- fMRI: 0.5 Hz (1 volume every 2 seconds), 50000 voxels (approximate)
- Spikes: 30000 Hz, 4 electrodes
- Calcium: 30 Hz, 200 neurons

Display the technique name, number of time points, and total data values for each.',
  '% Compare neural recording techniques
recording_duration = 10;  % seconds

% Define technique parameters: [sampling_rate, num_channels]
% YOUR CODE HERE

% Calculate and display for each technique
% YOUR CODE HERE
',
  'recording_duration = 10;

techniques = {''EEG'', ''fMRI'', ''Spikes'', ''Calcium''};
sampling_rates = [256, 0.5, 30000, 30];
num_channels = [64, 50000, 4, 200];

for i = 1:4
  time_points = recording_duration * sampling_rates(i);
  data_values = time_points * num_channels(i);
  disp([techniques{i} '': '' num2str(time_points) '' time points, '' num2str(data_values) '' total values'']);
end',
  '["Number of time points = duration * sampling_rate. For EEG: 10 * 256 = 2560. Total data values = time_points * num_channels.","Store parameters in arrays: sampling_rates = [256, 0.5, 30000, 30]; num_channels = [64, 50000, 4, 200]; Use a cell array for names: techniques = {''EEG'', ''fMRI'', ''Spikes'', ''Calcium''};","Loop through each technique: for i = 1:4 ... end. Inside compute time_points = recording_duration * sampling_rates(i); data_values = time_points * num_channels(i); then disp."]',
  '[{"expected_output":"EEG: 2560 time points, 163840 total values\nfMRI: 5 time points, 250000 total values\nSpikes: 300000 time points, 1200000 total values\nCalcium: 300 time points, 60000 total values\n"}]',
  false);


-- ============================================
-- Lesson 16: Spike Train Analysis
-- ============================================
INSERT INTO lessons (id, phase, order_num, title, description, difficulty, estimated_minutes, content_md)
VALUES (16, 4, 2, 'Spike Train Analysis',
  'Analyze neural spike data — calculate firing rates, inter-spike intervals, and create raster plots.',
  'advanced', 40,
  '# Spike Train Analysis

When a neuron "fires," it produces a brief electrical pulse called an **action potential** or **spike**. By recording these spikes, neuroscientists can decode what the brain is computing.

This lesson is inspired by Mike X Cohen''s approach to spike data analysis. We will work with the fundamental building blocks: spike times, firing rates, and inter-spike interval distributions.

## What Is a Spike Train?

A spike train is simply a **list of times** when a neuron produced an action potential:

```matlab
% Example: one neuron''s spike times in seconds
spike_times = [0.10, 0.25, 0.31, 0.58, 0.72, 0.89, 1.05];
```

From this simple list, we can extract surprisingly rich information about neural coding.

## Firing Rate

The most basic measure of neural activity is the **firing rate** — how many spikes per second (measured in Hz).

```matlab
% Simple firing rate
num_spikes = length(spike_times);
recording_duration = max(spike_times) - min(spike_times);
firing_rate = num_spikes / recording_duration;  % in Hz
```

But firing rate can change over time! To see this, we can compute **instantaneous firing rate** using time bins:

```matlab
% Binned firing rate
bin_width = 0.1;  % 100 ms bins
edges = 0:bin_width:max(spike_times);
counts = histc(spike_times, edges);
firing_rate_over_time = counts / bin_width;  % spikes/second in each bin
```

## Inter-Spike Intervals (ISI)

The **ISI** is the time between consecutive spikes. It reveals the neuron''s temporal firing pattern.

```matlab
ISI = diff(spike_times);  % differences between consecutive spike times
```

ISI distributions tell us about the neuron:
- **Regular firing:** narrow ISI distribution (like a metronome)
- **Poisson firing:** exponential ISI distribution (random timing)
- **Bursting:** bimodal ISI — short intervals within bursts, long intervals between bursts

## Coefficient of Variation (CV)

The **CV of the ISI** is a key measure of firing regularity:

```matlab
CV = std(ISI) / mean(ISI);
```

- CV < 1: more regular than Poisson
- CV = 1: Poisson-like (random)
- CV > 1: more bursty than Poisson

## Raster Plots

A **raster plot** shows spike times for multiple neurons (or multiple trials). Each row is a neuron/trial, and each tick mark is a spike.

```matlab
% Simple raster for one neuron on one row
y_pos = 1;  % row number
for s = 1:length(spike_times)
  line([spike_times(s) spike_times(s)], [y_pos-0.4 y_pos+0.4], ''Color'', ''k'');
end
```

Raster plots are one of the most common visualizations in systems neuroscience.

## Peristimulus Time Histogram (PSTH)

When you have multiple trials, you can align spikes to a stimulus event and build a **PSTH** — showing the average firing rate over time locked to the event. This reveals how neurons respond to stimuli.

In the exercises below, you will implement these analyses from scratch.');

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (16, 1, 'Calculate firing rate from spike times',
  'Given simulated spike data from a neuron, calculate:
1. The total number of spikes
2. The overall firing rate (spikes / total recording duration)
3. The binned firing rate using 500 ms bins over the full recording
4. The peak binned firing rate (maximum across all bins)

Use rand("state", 42); randn("state", 42). Generate spikes using a Poisson process at 35 Hz for 10 seconds with dt = 0.001.

Display: number of spikes, overall firing rate (1 decimal), and peak binned firing rate (1 decimal).',
  '% Calculate firing rates from spike data
rand("state", 42); randn("state", 42);

% Generate Poisson spike train
firing_rate_true = 35;  % Hz
duration = 10;          % seconds
dt = 0.001;
time_bins = 0:dt:duration-dt;

spike_vector = rand(1, length(time_bins)) < (firing_rate_true * dt);
spike_times = time_bins(spike_vector);

% 1. Total number of spikes
% YOUR CODE HERE

% 2. Overall firing rate
% YOUR CODE HERE

% 3. Binned firing rate (500 ms bins)
bin_width = 0.5;
% YOUR CODE HERE

% 4. Peak binned firing rate
% YOUR CODE HERE

% Display results
% YOUR CODE HERE
',
  'rand("state", 42); randn("state", 42);

firing_rate_true = 35;
duration = 10;
dt = 0.001;
time_bins = 0:dt:duration-dt;

spike_vector = rand(1, length(time_bins)) < (firing_rate_true * dt);
spike_times = time_bins(spike_vector);

num_spikes = length(spike_times);
overall_rate = num_spikes / duration;

bin_width = 0.5;
edges = 0:bin_width:duration;
counts = histc(spike_times, edges);
counts = counts(1:end-1);
binned_rate = counts / bin_width;

peak_rate = max(binned_rate);

disp([''Number of spikes: '' num2str(num_spikes)]);
disp([''Overall firing rate: '' num2str(round(overall_rate*10)/10) '' Hz'']);
disp([''Peak binned firing rate: '' num2str(round(peak_rate*10)/10) '' Hz'']);',
  '["Total spikes: num_spikes = length(spike_times). Overall rate: num_spikes / duration.","For binned rate: edges = 0:bin_width:duration; counts = histc(spike_times, edges); Remove the last bin edge: counts = counts(1:end-1); Then binned_rate = counts / bin_width;","Peak rate: peak_rate = max(binned_rate). Round to 1 decimal with round(value*10)/10."]',
  '[{"expected_output":"Number of spikes: 319\nOverall firing rate: 31.9 Hz\nPeak binned firing rate: 40 Hz\n"}]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (16, 2, 'Compute inter-spike intervals',
  'From the same spike train (rand("state", 42); randn("state", 42), 35 Hz Poisson, 10 seconds, dt=0.001), compute the inter-spike interval (ISI) distribution.

Calculate:
1. The ISI vector (time between consecutive spikes)
2. Mean ISI (in milliseconds, rounded to 2 decimal places)
3. Standard deviation of ISI (in milliseconds, rounded to 2 decimal places)
4. Coefficient of variation (CV = std/mean, rounded to 2 decimal places)
5. The percentage of ISIs shorter than 10 ms (rounded to 1 decimal place)

Display all five results.',
  '% ISI analysis
rand("state", 42); randn("state", 42);

firing_rate_true = 35;
duration = 10;
dt = 0.001;
time_bins = 0:dt:duration-dt;

spike_vector = rand(1, length(time_bins)) < (firing_rate_true * dt);
spike_times = time_bins(spike_vector);

% 1. Compute ISI
% YOUR CODE HERE

% 2. Mean ISI in ms
% YOUR CODE HERE

% 3. Std of ISI in ms
% YOUR CODE HERE

% 4. CV
% YOUR CODE HERE

% 5. Percentage of ISIs < 10 ms
% YOUR CODE HERE

% Display all results
% YOUR CODE HERE
',
  'rand("state", 42); randn("state", 42);

firing_rate_true = 35;
duration = 10;
dt = 0.001;
time_bins = 0:dt:duration-dt;

spike_vector = rand(1, length(time_bins)) < (firing_rate_true * dt);
spike_times = time_bins(spike_vector);

ISI = diff(spike_times);

mean_isi_ms = mean(ISI) * 1000;
std_isi_ms = std(ISI) * 1000;
CV = std(ISI) / mean(ISI);
pct_short = sum(ISI < 0.010) / length(ISI) * 100;

disp([''Mean ISI: '' num2str(round(mean_isi_ms*100)/100) '' ms'']);
disp([''Std ISI: '' num2str(round(std_isi_ms*100)/100) '' ms'']);
disp([''CV: '' num2str(round(CV*100)/100)]);
disp([''ISIs < 10ms: '' num2str(round(pct_short*10)/10) ''%'']);',
  '["ISI = diff(spike_times) gives you the time between consecutive spikes. Multiply by 1000 to convert seconds to milliseconds.","Mean and std: mean_isi_ms = mean(ISI) * 1000; std_isi_ms = std(ISI) * 1000; CV = std(ISI) / mean(ISI);","For percentage of short ISIs: pct_short = sum(ISI < 0.010) / length(ISI) * 100; Round to 2 decimals: round(value*100)/100."]',
  '[{"expected_output":"Mean ISI: 31.4 ms\nStd ISI: 30.31 ms\nCV: 0.97\nISIs < 10ms: 24.8%\n"}]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (16, 3, 'Create a raster plot of multiple neurons',
  'Simulate and plot spike trains for 8 neurons with different firing rates.

Use rand("state", 123); randn("state", 123). Create Poisson spike trains (dt = 0.001) for 3 seconds for 8 neurons with firing rates: [5, 10, 15, 20, 30, 40, 50, 60] Hz.

Create a raster plot where:
- Each neuron is on a separate horizontal row (neuron 1 at top, neuron 8 at bottom)
- Each spike is a short vertical tick mark
- X-axis: ''Time (s)'', Y-axis: ''Neuron''
- Title: ''Raster Plot - 8 Neurons''
- Set Y-axis ticks at 1 through 8',
  '% Raster plot of 8 neurons
rand("state", 123); randn("state", 123);

firing_rates = [5, 10, 15, 20, 30, 40, 50, 60];
duration = 3;
dt = 0.001;
time_bins = 0:dt:duration-dt;
num_neurons = length(firing_rates);

figure;
hold on;

for n = 1:num_neurons
  % Generate spike train for this neuron
  % YOUR CODE HERE

  % Plot each spike as a vertical tick at row n
  % YOUR CODE HERE
end

% Label the plot
% YOUR CODE HERE

hold off;
',
  'rand("state", 123); randn("state", 123);

firing_rates = [5, 10, 15, 20, 30, 40, 50, 60];
duration = 3;
dt = 0.001;
time_bins = 0:dt:duration-dt;
num_neurons = length(firing_rates);

figure;
hold on;

for n = 1:num_neurons
  spike_vector = rand(1, length(time_bins)) < (firing_rates(n) * dt);
  spike_times = time_bins(spike_vector);

  for s = 1:length(spike_times)
    line([spike_times(s) spike_times(s)], [n-0.4 n+0.4], ''Color'', ''k'');
  end
end

xlabel(''Time (s)'');
ylabel(''Neuron'');
title(''Raster Plot - 8 Neurons'');
set(gca, ''YTick'', 1:8);
ylim([0.5 8.5]);
xlim([0 duration]);
hold off;',
  '["Inside the loop, generate spikes for neuron n: spike_vector = rand(1, length(time_bins)) < (firing_rates(n) * dt); spike_times = time_bins(spike_vector);","Plot each spike as a vertical line at row n: for s = 1:length(spike_times)  line([spike_times(s) spike_times(s)], [n-0.4 n+0.4], ''Color'', ''k''); end","After the loop: xlabel(''Time (s)''); ylabel(''Neuron''); title(''Raster Plot - 8 Neurons''); set(gca, ''YTick'', 1:8);"]',
  '[]',
  true);


-- ============================================
-- Lesson 17: EEG Processing
-- ============================================
INSERT INTO lessons (id, phase, order_num, title, description, difficulty, estimated_minutes, content_md)
VALUES (17, 4, 3, 'EEG Processing',
  'Learn the essential EEG preprocessing steps — referencing, artifact detection, and extracting event-related potentials.',
  'advanced', 45,
  '# EEG Processing

EEG (electroencephalography) records tiny electrical voltages from the scalp using an array of electrodes. Before you can analyze brain waves, the raw data needs **preprocessing**. This lesson covers the essential steps.

These are the exact techniques your friend would use before analyzing meditation EEG data.

## The EEG Preprocessing Pipeline

A typical pipeline looks like this:

1. **Load data** (or in our case, simulate it)
2. **Re-reference** — choose a reference scheme
3. **Filter** — bandpass filter to remove drift and high-frequency noise
4. **Artifact rejection** — remove or fix segments contaminated by blinks, muscle movement, etc.
5. **Epoch** — cut continuous data into segments around events
6. **Average** — compute the event-related potential (ERP)

## Re-referencing

EEG measures **voltage differences**. Every electrode is measured relative to a reference electrode (often on the mastoid or earlobe). But the choice of reference affects your results!

The **average reference** is a common choice: subtract the mean across all channels at each time point.

```matlab
% Average reference
% eeg_data is channels x time_points
avg_ref = mean(eeg_data, 1);           % mean across channels (row vector)
eeg_reref = eeg_data - avg_ref;         % subtract from each channel
```

After average referencing, the sum of all channels at each time point is zero.

## Artifact Detection

Artifacts are non-brain signals that contaminate EEG:
- **Eye blinks:** huge voltage spikes (50-200 uV) in frontal channels
- **Muscle activity:** high-frequency noise from jaw clenching, etc.
- **Electrode pops:** sudden jumps in a single channel

The simplest detection method: **threshold-based rejection**

```matlab
% If any channel exceeds +/- 100 uV, mark that time point as artifact
threshold = 100;  % microvolts
artifact_mask = any(abs(eeg_data) > threshold, 1);  % 1 x time_points logical
```

## Event-Related Potentials (ERPs)

An ERP is the brain''s response to a specific event (a sound, a visual stimulus, the beginning of a meditation period). To extract it:

1. Cut the continuous EEG into **epochs** around each event
2. (Optionally reject epochs with artifacts)
3. **Average** across epochs — the noise cancels out, the signal remains

```matlab
% Pseudocode for epoching
epoch_duration = 1.0;  % seconds
for i = 1:num_events
  start_sample = event_samples(i);
  end_sample = start_sample + epoch_duration * fs - 1;
  epochs(:,:,i) = eeg_data(:, start_sample:end_sample);
end

% Average across epochs (dimension 3)
ERP = mean(epochs, 3);
```

The power of averaging: if you have 100 trials, the noise is reduced by a factor of sqrt(100) = 10, while the consistent signal stays.

## Baseline Correction

Before averaging, it is standard to subtract the **baseline** (a short pre-stimulus period) from each epoch:

```matlab
baseline_samples = 1:round(0.2 * fs);  % first 200 ms
for i = 1:num_events
  baseline_mean = mean(epochs(:, baseline_samples, i), 2);
  epochs(:,:,i) = epochs(:,:,i) - baseline_mean;
end
```

This removes slow voltage drifts and ensures each epoch starts near zero.

Let''s implement these steps in the exercises.');

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (17, 1, 'Average reference multi-channel EEG',
  'Simulate a 4-channel EEG recording and apply average referencing.

Steps:
1. Use rand("state", 50); randn("state", 50). Set fs = 256, duration = 2 seconds.
2. Create a time vector.
3. Simulate 4 channels of EEG (channels x time_points matrix):
   - Channel 1: 15*sin(2*pi*10*t) + 3*randn
   - Channel 2: 10*sin(2*pi*10*t) + 5*sin(2*pi*20*t) + 3*randn
   - Channel 3: 8*sin(2*pi*10*t) + 3*randn
   - Channel 4: 12*sin(2*pi*10*t) + 7*sin(2*pi*6*t) + 3*randn
4. Compute the average reference (mean across channels at each time point)
5. Subtract the average reference from each channel
6. Verify: display the mean across channels of the re-referenced data at time point 100 (should be ~0)

Display: the size of the EEG matrix, the mean of the original data at time point 100 (rounded to 2 decimals), and the mean of the re-referenced data at time point 100 (rounded to 10 decimal places, displayed with format).',
  '% Average referencing of simulated EEG
rand("state", 50); randn("state", 50);

fs = 256;
duration = 2;
t = 0:1/fs:duration-1/fs;
num_samples = length(t);

% Simulate 4 channels
% YOUR CODE HERE

% Compute average reference
% YOUR CODE HERE

% Apply average reference
% YOUR CODE HERE

% Display results
% YOUR CODE HERE
',
  'rand("state", 50); randn("state", 50);

fs = 256;
duration = 2;
t = 0:1/fs:duration-1/fs;
num_samples = length(t);

eeg_data = zeros(4, num_samples);
eeg_data(1,:) = 15*sin(2*pi*10*t) + 3*randn(1, num_samples);
eeg_data(2,:) = 10*sin(2*pi*10*t) + 5*sin(2*pi*20*t) + 3*randn(1, num_samples);
eeg_data(3,:) = 8*sin(2*pi*10*t) + 3*randn(1, num_samples);
eeg_data(4,:) = 12*sin(2*pi*10*t) + 7*sin(2*pi*6*t) + 3*randn(1, num_samples);

avg_ref = mean(eeg_data, 1);

eeg_reref = eeg_data - avg_ref;

disp([''EEG matrix size: '' num2str(size(eeg_data,1)) '' x '' num2str(size(eeg_data,2))]);
disp([''Mean at time point 100 (original): '' num2str(round(mean(eeg_data(:,100))*100)/100)]);
disp([''Mean at time point 100 (re-referenced): '' num2str(round(mean(eeg_reref(:,100))))]);',
  '["Build the EEG matrix row by row: eeg_data = zeros(4, num_samples); eeg_data(1,:) = 15*sin(2*pi*10*t) + 3*randn(1, num_samples); and so on for each channel.","Average reference: avg_ref = mean(eeg_data, 1); This takes the mean across rows (channels) at each time point. Then eeg_reref = eeg_data - avg_ref;","To verify: mean(eeg_reref(:,100)) should be 0 (or very close). Display using disp([''Mean at time point 100 (re-referenced): '' num2str(mean(eeg_reref(:,100)))]);"]',
  '[{"expected_output":"EEG matrix size: 4 x 512\nMean at time point 100 (original): -9.21\nMean at time point 100 (re-referenced): 0\n"}]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (17, 2, 'Detect and remove artifacts',
  'Simulate a single-channel EEG signal with embedded artifacts, then detect and clean them.

Steps:
1. Use rand("state", 77); randn("state", 77). Set fs = 256, duration = 5 seconds.
2. Create a clean EEG signal: 12*sin(2*pi*10*t) + 4*randn
3. Insert 3 blink artifacts: At time indices 300-310, 700-710, and 1100-1110, add 150 uV to simulate blinks
4. Detect artifacts: find all indices where abs(signal) > 80 uV
5. Clean the signal: replace artifact samples with 0 (simple zeroing approach)
6. Display: number of artifact samples detected, percentage of data that is artifact (rounded to 2 decimals), max absolute value of cleaned signal (rounded to 1 decimal)
',
  '% Artifact detection and removal
rand("state", 77); randn("state", 77);

fs = 256;
duration = 5;
t = 0:1/fs:duration-1/fs;

% Create clean EEG
clean_eeg = 12*sin(2*pi*10*t) + 4*randn(1, length(t));

% Add blink artifacts
eeg_with_artifacts = clean_eeg;
% YOUR CODE HERE - add 150 uV at indices 300-310, 700-710, 1100-1110

% Detect artifacts (threshold = 80 uV)
threshold = 80;
% YOUR CODE HERE

% Clean by zeroing artifact samples
cleaned_eeg = eeg_with_artifacts;
% YOUR CODE HERE

% Display results
% YOUR CODE HERE
',
  'rand("state", 77); randn("state", 77);

fs = 256;
duration = 5;
t = 0:1/fs:duration-1/fs;

clean_eeg = 12*sin(2*pi*10*t) + 4*randn(1, length(t));

eeg_with_artifacts = clean_eeg;
eeg_with_artifacts(300:310) = eeg_with_artifacts(300:310) + 150;
eeg_with_artifacts(700:710) = eeg_with_artifacts(700:710) + 150;
eeg_with_artifacts(1100:1110) = eeg_with_artifacts(1100:1110) + 150;

threshold = 80;
artifact_idx = find(abs(eeg_with_artifacts) > threshold);
num_artifacts = length(artifact_idx);

cleaned_eeg = eeg_with_artifacts;
cleaned_eeg(artifact_idx) = 0;

pct_artifact = num_artifacts / length(eeg_with_artifacts) * 100;

disp([''Artifact samples detected: '' num2str(num_artifacts)]);
disp([''Percentage artifact: '' num2str(round(pct_artifact*100)/100) ''%'']);
disp([''Max absolute cleaned signal: '' num2str(round(max(abs(cleaned_eeg))*10)/10) '' uV'']);',
  '["Add artifacts: eeg_with_artifacts(300:310) = eeg_with_artifacts(300:310) + 150; Repeat for the other two ranges.","Detect: artifact_idx = find(abs(eeg_with_artifacts) > threshold); num_artifacts = length(artifact_idx); Clean: cleaned_eeg(artifact_idx) = 0;","Percentage: pct_artifact = num_artifacts / length(eeg_with_artifacts) * 100; Max cleaned: max(abs(cleaned_eeg))."]',
  '[{"expected_output":"Artifact samples detected: 33\nPercentage artifact: 2.58%\nMax absolute cleaned signal: 26 uV\n"}]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (17, 3, 'Extract an event-related potential (ERP)',
  'Simulate a continuous EEG recording with repeated stimulus responses embedded in noise, then extract the ERP by averaging across trials.

Steps:
1. Use rand("state", 99); randn("state", 99). Set fs = 256, total_duration = 30 seconds.
2. Generate continuous noise: 8*randn for the full duration.
3. Create 20 events spaced every 1.2 seconds, starting at t = 0.5s. Event samples = round(event_times * fs) + 1.
4. At each event, embed a response: a positive peak at 100ms post-event (sample offset = round(0.1*fs)) with amplitude 5 uV (add 5 at that single sample), and a negative dip at 200ms (offset = round(0.2*fs)) with amplitude -3 uV.
5. Epoch: extract 0 to 0.5 seconds after each event (epoch_length = round(0.5*fs) samples). Store in a matrix epochs(num_events, epoch_length).
6. Average across trials to get the ERP (mean across rows).
7. Display: number of epochs, ERP value at 100ms post-stimulus (rounded to 2 decimals), ERP value at 200ms post-stimulus (rounded to 2 decimals).

The averaging should reveal the embedded peaks while reducing the noise.',
  '% ERP extraction
rand("state", 99); randn("state", 99);

fs = 256;
total_duration = 30;
t = 0:1/fs:total_duration-1/fs;

% Generate continuous noisy signal
continuous_eeg = 8 * randn(1, length(t));

% Define event times (20 events, every 1.2s, starting at 0.5s)
num_events = 20;
event_times = 0.5 + (0:num_events-1) * 1.2;
event_samples = round(event_times * fs) + 1;

% Embed responses at each event
% YOUR CODE HERE

% Epoch extraction (0 to 0.5s after each event)
epoch_length = round(0.5 * fs);
epochs = zeros(num_events, epoch_length);
% YOUR CODE HERE

% Compute ERP (average across trials)
% YOUR CODE HERE

% Display results
% YOUR CODE HERE
',
  'rand("state", 99); randn("state", 99);

fs = 256;
total_duration = 30;
t = 0:1/fs:total_duration-1/fs;

continuous_eeg = 8 * randn(1, length(t));

num_events = 20;
event_times = 0.5 + (0:num_events-1) * 1.2;
event_samples = round(event_times * fs) + 1;

for i = 1:num_events
  peak_sample = event_samples(i) + round(0.1 * fs);
  dip_sample = event_samples(i) + round(0.2 * fs);
  continuous_eeg(peak_sample) = continuous_eeg(peak_sample) + 5;
  continuous_eeg(dip_sample) = continuous_eeg(dip_sample) - 3;
end

epoch_length = round(0.5 * fs);
epochs = zeros(num_events, epoch_length);
for i = 1:num_events
  start_idx = event_samples(i);
  end_idx = start_idx + epoch_length - 1;
  epochs(i, :) = continuous_eeg(start_idx:end_idx);
end

ERP = mean(epochs, 1);

sample_100ms = round(0.1 * fs) + 1;
sample_200ms = round(0.2 * fs) + 1;

disp([''Number of epochs: '' num2str(num_events)]);
disp([''ERP at 100ms: '' num2str(round(ERP(sample_100ms)*100)/100) '' uV'']);
disp([''ERP at 200ms: '' num2str(round(ERP(sample_200ms)*100)/100) '' uV'']);',
  '["For embedding: loop over events. peak_sample = event_samples(i) + round(0.1*fs); continuous_eeg(peak_sample) = continuous_eeg(peak_sample) + 5; Similarly for the dip at 0.2s.","For epoching: loop over events. start_idx = event_samples(i); end_idx = start_idx + epoch_length - 1; epochs(i,:) = continuous_eeg(start_idx:end_idx);","ERP = mean(epochs, 1); To read specific time points: sample_100ms = round(0.1*fs) + 1; disp([''ERP at 100ms: '' num2str(round(ERP(sample_100ms)*100)/100) '' uV'']);"]',
  '[{"expected_output":"Number of epochs: 20\nERP at 100ms: 5.54 uV\nERP at 200ms: -3.25 uV\n"}]',
  false);


-- ============================================
-- Lesson 18: Meditation & Brain Waves
-- ============================================
INSERT INTO lessons (id, phase, order_num, title, description, difficulty, estimated_minutes, content_md)
VALUES (18, 4, 4, 'Meditation & Brain Waves',
  'Analyze brain wave patterns during meditation — alpha and theta power changes, and comparing meditation to rest conditions.',
  'advanced', 45,
  '# Meditation & Brain Waves

This lesson is the heart of why you started learning MATLAB. Your friend studies how yoga and meditation affect the brain, and this is **exactly** the kind of analysis they do every day.

When someone sits quietly and meditates, their brain waves change in measurable ways. Understanding these changes is one of the most active areas in contemplative neuroscience.

## Brain Wave Frequency Bands

Neural oscillations are categorized into frequency bands, each associated with different mental states:

| Band | Frequency | Associated With |
|---|---|---|
| **Delta** | 0.5 - 4 Hz | Deep sleep |
| **Theta** | 4 - 8 Hz | Drowsiness, deep meditation, memory |
| **Alpha** | 8 - 13 Hz | Relaxed wakefulness, eyes closed, meditation |
| **Beta** | 13 - 30 Hz | Active thinking, focus, anxiety |
| **Gamma** | 30 - 100 Hz | Higher cognition, experienced meditators |

## What Happens During Meditation?

Decades of research have shown consistent patterns:

### Alpha Power Increases
The most robust finding: **alpha waves (8-13 Hz) increase during meditation**, especially in parietal and occipital regions. Alpha is associated with a calm, relaxed but alert state — exactly what meditators report experiencing.

### Theta Waves During Deep Meditation
Experienced meditators often show increased **theta activity (4-8 Hz)**, particularly in frontal regions. Theta is linked to the deeply internalized, contemplative state.

### Reduced Beta Activity
During meditation, **beta waves often decrease**, reflecting reduced analytical thinking and mental chatter.

### Gamma in Experienced Meditators
Long-term meditators (like Buddhist monks with thousands of hours of practice) have shown extraordinary increases in **gamma activity**, suggesting heightened awareness.

## How to Measure These Changes

The key technique is **power spectral analysis** — computing how much power (energy) is present at each frequency.

```matlab
% Compute power spectrum using FFT
N = length(signal);
fft_result = fft(signal);
power_spectrum = (abs(fft_result(1:N/2+1)).^2) / N;
freqs = (0:N/2) * fs / N;
```

To get **band power** (e.g., total alpha power):

```matlab
alpha_idx = freqs >= 8 & freqs <= 13;
alpha_power = sum(power_spectrum(alpha_idx));
```

## Comparing Conditions

In a typical meditation study:
1. Record EEG during a **baseline/rest** period (eyes open or closed, not meditating)
2. Record EEG during **meditation**
3. Compare the power spectra between conditions

A common measure is the **relative power change**:

```matlab
change_pct = (meditation_power - rest_power) / rest_power * 100;
```

If alpha power increases by 40-60% during meditation compared to rest, that is a strong and meaningful effect.

## Personal Connection

Imagine your friend recording EEG from participants before and during a meditation session. The participant sits comfortably, electrodes on their scalp, and begins a guided meditation. Your friend''s analysis pipeline extracts the alpha power and shows that beautiful increase — a window into the meditative brain state.

The exercises below let you build exactly that analysis.');

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (18, 1, 'Calculate alpha power from simulated EEG',
  'Simulate an EEG signal with known frequency components and extract the alpha band (8-13 Hz) power using the FFT.

Steps:
1. Use rand("state", 33); randn("state", 33). Set fs = 256, duration = 4 seconds.
2. Create a signal with:
   - Alpha component: 20*sin(2*pi*10*t) (10 Hz, amplitude 20)
   - Beta component: 5*sin(2*pi*25*t) (25 Hz, amplitude 5)
   - Noise: 3*randn
3. Compute the FFT and single-sided power spectrum
4. Create the frequency vector
5. Extract alpha power: sum of power where 8 <= freq <= 13
6. Extract total power: sum of all power
7. Compute relative alpha power (alpha_power / total_power * 100)

Display: total power (rounded to nearest integer), alpha power (rounded to nearest integer), relative alpha power (rounded to 1 decimal, with percent sign).',
  '% Alpha power calculation
rand("state", 33); randn("state", 33);

fs = 256;
duration = 4;
t = 0:1/fs:duration-1/fs;
N = length(t);

% Create signal
alpha_component = 20 * sin(2*pi*10*t);
beta_component = 5 * sin(2*pi*25*t);
noise = 3 * randn(1, N);
signal = alpha_component + beta_component + noise;

% Compute FFT and power spectrum
% YOUR CODE HERE

% Frequency vector
% YOUR CODE HERE

% Alpha power (8-13 Hz)
% YOUR CODE HERE

% Total power
% YOUR CODE HERE

% Relative alpha power
% YOUR CODE HERE

% Display
% YOUR CODE HERE
',
  'rand("state", 33); randn("state", 33);

fs = 256;
duration = 4;
t = 0:1/fs:duration-1/fs;
N = length(t);

alpha_component = 20 * sin(2*pi*10*t);
beta_component = 5 * sin(2*pi*25*t);
noise = 3 * randn(1, N);
signal = alpha_component + beta_component + noise;

fft_result = fft(signal);
power_spectrum = (abs(fft_result(1:N/2+1)).^2) / N;
freqs = (0:N/2) * fs / N;

alpha_idx = freqs >= 8 & freqs <= 13;
alpha_power = sum(power_spectrum(alpha_idx));

total_power = sum(power_spectrum);

relative_alpha = alpha_power / total_power * 100;

disp([''Total power: '' num2str(round(total_power))]);
disp([''Alpha power: '' num2str(round(alpha_power))]);
disp([''Relative alpha power: '' num2str(round(relative_alpha*10)/10) ''%'']);',
  '["FFT: fft_result = fft(signal); Power: power_spectrum = (abs(fft_result(1:N/2+1)).^2) / N; Frequency: freqs = (0:N/2) * fs / N;","Alpha indices: alpha_idx = freqs >= 8 & freqs <= 13; Alpha power: alpha_power = sum(power_spectrum(alpha_idx));","Total power: total_power = sum(power_spectrum); Relative: relative_alpha = alpha_power / total_power * 100; Display with round."]',
  '[{"expected_output":"Total power: 115270\nAlpha power: 104360\nRelative alpha power: 90.5%\n"}]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (18, 2, 'Compare alpha power: meditation vs rest',
  'Simulate two EEG conditions and compare their alpha power — just like a real meditation study.

**Rest condition:** Lower alpha (amplitude 8), higher beta (amplitude 12), noise std 4
**Meditation condition:** Higher alpha (amplitude 22), lower beta (amplitude 4), noise std 3

Both signals: 10 Hz for alpha, 20 Hz for beta, also add a 6 Hz theta component with amplitude 10 in meditation and amplitude 3 at rest.

Steps:
1. Use rand("state", 55); randn("state", 55). Set fs = 256, duration = 5 seconds.
2. Generate rest signal: 8*sin(2*pi*10*t) + 12*sin(2*pi*20*t) + 3*sin(2*pi*6*t) + 4*randn
3. Generate meditation signal: 22*sin(2*pi*10*t) + 4*sin(2*pi*20*t) + 10*sin(2*pi*6*t) + 3*randn
4. Compute power spectra for both
5. Extract alpha (8-13 Hz) power for both conditions
6. Calculate percentage change: (meditation - rest) / rest * 100

Display: rest alpha power (rounded to nearest integer), meditation alpha power (rounded to nearest integer), and the percentage change (rounded to 1 decimal, with percent sign).',
  '% Meditation vs rest alpha power comparison
rand("state", 55); randn("state", 55);

fs = 256;
duration = 5;
t = 0:1/fs:duration-1/fs;
N = length(t);

% Generate rest condition signal
% YOUR CODE HERE

% Generate meditation condition signal
% YOUR CODE HERE

% Compute power spectra for both
% YOUR CODE HERE

% Extract alpha power (8-13 Hz)
% YOUR CODE HERE

% Calculate percentage change
% YOUR CODE HERE

% Display results
% YOUR CODE HERE
',
  'rand("state", 55); randn("state", 55);

fs = 256;
duration = 5;
t = 0:1/fs:duration-1/fs;
N = length(t);

rest_signal = 8*sin(2*pi*10*t) + 12*sin(2*pi*20*t) + 3*sin(2*pi*6*t) + 4*randn(1, N);
med_signal = 22*sin(2*pi*10*t) + 4*sin(2*pi*20*t) + 10*sin(2*pi*6*t) + 3*randn(1, N);

fft_rest = fft(rest_signal);
power_rest = (abs(fft_rest(1:N/2+1)).^2) / N;

fft_med = fft(med_signal);
power_med = (abs(fft_med(1:N/2+1)).^2) / N;

freqs = (0:N/2) * fs / N;
alpha_idx = freqs >= 8 & freqs <= 13;

alpha_rest = sum(power_rest(alpha_idx));
alpha_med = sum(power_med(alpha_idx));

pct_change = (alpha_med - alpha_rest) / alpha_rest * 100;

disp([''Rest alpha power: '' num2str(round(alpha_rest))]);
disp([''Meditation alpha power: '' num2str(round(alpha_med))]);
disp([''Alpha power change: '' num2str(round(pct_change*10)/10) ''%'']);',
  '["Build each signal by summing sine waves and noise. rest_signal = 8*sin(2*pi*10*t) + 12*sin(2*pi*20*t) + 3*sin(2*pi*6*t) + 4*randn(1, N);","Compute FFT and power for both: fft_rest = fft(rest_signal); power_rest = (abs(fft_rest(1:N/2+1)).^2)/N; Same for meditation. freqs = (0:N/2)*fs/N;","Alpha indices: alpha_idx = freqs >= 8 & freqs <= 13; alpha_rest = sum(power_rest(alpha_idx)); Percentage change: (alpha_med - alpha_rest)/alpha_rest * 100."]',
  '[{"expected_output":"Rest alpha power: 19453\nMeditation alpha power: 156883\nAlpha power change: 706.5%\n"}]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (18, 3, 'Visualize brain wave changes during meditation',
  'Create a visualization showing how brain wave power changes over the course of a meditation session.

Simulate a 60-second recording divided into three 20-second phases:
- Phase 1 (0-20s): Rest — alpha amplitude 8, theta amplitude 3
- Phase 2 (20-40s): Early meditation — alpha amplitude 16, theta amplitude 8
- Phase 3 (40-60s): Deep meditation — alpha amplitude 24, theta amplitude 15

All phases also include: beta at amplitude 6 (20 Hz) and noise with std 3.

Steps:
1. Use rand("state", 44); randn("state", 44). Set fs = 256.
2. Build the signal in three segments concatenated together.
3. Compute power spectra in 4-second sliding windows (non-overlapping, so 15 windows total).
4. For each window, compute alpha (8-13 Hz) and theta (4-8 Hz) power.
5. Create a 2-subplot figure:
   - Top: alpha power over time (window number)
   - Bottom: theta power over time (window number)
   Add appropriate labels and titles. Main title: ''Brain Wave Changes During Meditation''',
  '% Meditation brain wave changes over time
rand("state", 44); randn("state", 44);

fs = 256;
phase_duration = 20;  % seconds each

% Phase 1: Rest
t1 = 0:1/fs:phase_duration-1/fs;
phase1 = 8*sin(2*pi*10*t1) + 3*sin(2*pi*6*t1) + 6*sin(2*pi*20*t1) + 3*randn(1,length(t1));

% Phase 2: Early meditation
% YOUR CODE HERE

% Phase 3: Deep meditation
% YOUR CODE HERE

% Concatenate
% YOUR CODE HERE

% Sliding window analysis (4-second windows)
window_sec = 4;
window_samples = window_sec * fs;
num_windows = floor(length(full_signal) / window_samples);

alpha_power_time = zeros(1, num_windows);
theta_power_time = zeros(1, num_windows);

for w = 1:num_windows
  % Extract window
  % YOUR CODE HERE

  % Compute power spectrum
  % YOUR CODE HERE

  % Extract alpha and theta power
  % YOUR CODE HERE
end

% Plot
figure;
% YOUR CODE HERE
',
  'rand("state", 44); randn("state", 44);

fs = 256;
phase_duration = 20;

t1 = 0:1/fs:phase_duration-1/fs;
phase1 = 8*sin(2*pi*10*t1) + 3*sin(2*pi*6*t1) + 6*sin(2*pi*20*t1) + 3*randn(1,length(t1));

t2 = 0:1/fs:phase_duration-1/fs;
phase2 = 16*sin(2*pi*10*t2) + 8*sin(2*pi*6*t2) + 6*sin(2*pi*20*t2) + 3*randn(1,length(t2));

t3 = 0:1/fs:phase_duration-1/fs;
phase3 = 24*sin(2*pi*10*t3) + 15*sin(2*pi*6*t3) + 6*sin(2*pi*20*t3) + 3*randn(1,length(t3));

full_signal = [phase1, phase2, phase3];

window_sec = 4;
window_samples = window_sec * fs;
num_windows = floor(length(full_signal) / window_samples);

alpha_power_time = zeros(1, num_windows);
theta_power_time = zeros(1, num_windows);

for w = 1:num_windows
  start_idx = (w-1) * window_samples + 1;
  end_idx = w * window_samples;
  segment = full_signal(start_idx:end_idx);

  Nw = length(segment);
  fft_seg = fft(segment);
  power_seg = (abs(fft_seg(1:Nw/2+1)).^2) / Nw;
  freqs = (0:Nw/2) * fs / Nw;

  alpha_idx = freqs >= 8 & freqs <= 13;
  theta_idx = freqs >= 4 & freqs < 8;

  alpha_power_time(w) = sum(power_seg(alpha_idx));
  theta_power_time(w) = sum(power_seg(theta_idx));
end

figure;
subplot(2,1,1);
bar(1:num_windows, alpha_power_time);
xlabel(''Window number'');
ylabel(''Alpha Power (uV^2)'');
title(''Alpha Power (8-13 Hz) Over Meditation Session'');

subplot(2,1,2);
bar(1:num_windows, theta_power_time);
xlabel(''Window number'');
ylabel(''Theta Power (uV^2)'');
title(''Theta Power (4-8 Hz) Over Meditation Session'');

sgtitle(''Brain Wave Changes During Meditation'');',
  '["Phase 2 and 3 follow the same pattern as phase 1 but with different amplitudes. phase2 = 16*sin(2*pi*10*t2) + 8*sin(2*pi*6*t2) + 6*sin(2*pi*20*t2) + 3*randn(1,length(t2)); Concatenate: full_signal = [phase1, phase2, phase3];","In the loop: start_idx = (w-1)*window_samples + 1; end_idx = w*window_samples; segment = full_signal(start_idx:end_idx); Then compute FFT and power on the segment.","freqs = (0:Nw/2)*fs/Nw; alpha_idx = freqs >= 8 & freqs <= 13; theta_idx = freqs >= 4 & freqs < 8; Use subplot(2,1,1) and subplot(2,1,2) for the two panels."]',
  '[]',
  true);


-- ============================================
-- Lesson 19: Neural Modeling Basics
-- ============================================
INSERT INTO lessons (id, phase, order_num, title, description, difficulty, estimated_minutes, content_md)
VALUES (19, 4, 5, 'Neural Modeling Basics',
  'Simulate how neurons work using the leaky integrate-and-fire model — a foundational computational neuroscience technique.',
  'advanced', 40,
  '# Neural Modeling Basics

So far, we have been analyzing neural *data*. Now let''s flip the perspective and **simulate neural activity from first principles**. This is the world of computational neuroscience.

Why model neurons? Because models let us test hypotheses about how the brain works. If your model of a neuron produces activity patterns that match real data, you have a candidate explanation for the underlying mechanism.

## The Leaky Integrate-and-Fire (LIF) Neuron

The LIF model is the "Hello, World!" of computational neuroscience. It captures the essential behavior of a neuron:

1. **Integrate:** The neuron accumulates input (like charge building up on a capacitor)
2. **Leak:** Some charge constantly leaks away (the membrane is not a perfect insulator)
3. **Fire:** When the voltage reaches a threshold, the neuron fires a spike
4. **Reset:** After firing, the voltage resets to a resting value

## The Math

The membrane potential V(t) evolves according to:

```
tau * dV/dt = -(V - V_rest) + R * I_input
```

Where:
- **tau** = membrane time constant (~10-20 ms) — how quickly voltage decays
- **V_rest** = resting potential (~-70 mV) — voltage with no input
- **R** = membrane resistance (~10 MOhm)
- **I_input** = input current (nanoamps)

When **V >= V_threshold** (about -55 mV), the neuron fires and V resets to V_rest.

## Euler Method Simulation

We simulate this using the Euler method — stepping forward in small time increments:

```matlab
dt = 0.0001;  % 0.1 ms time step
for i = 2:num_steps
  dV = (-(V(i-1) - V_rest) + R * I(i-1)) / tau;
  V(i) = V(i-1) + dV * dt;

  % Check for spike
  if V(i) >= V_thresh
    V(i) = V_rest;       % reset
    spike_times = [spike_times, t(i)];
  end
end
```

## What Can the LIF Model Teach Us?

### 1. Threshold Behavior
Below a critical input current, the neuron never fires. Above it, it fires regularly. This threshold is a fundamental property of neurons.

### 2. F-I Curve
The relationship between input current (I) and firing rate (F) is called the **F-I curve**. For the LIF model, firing rate increases roughly linearly with current above threshold. Real neurons show more complex F-I curves.

### 3. Refractory Period
After firing, real neurons have a brief period where they cannot fire again. We can add this to the model.

## Beyond LIF

More sophisticated models exist:
- **Hodgkin-Huxley:** Biophysically detailed, models ion channels
- **Izhikevich:** Computationally efficient but can reproduce many firing patterns
- **AdEx (Adaptive Exponential):** Adds adaptation and exponential spike initiation

But the LIF model remains the workhorse for large-scale network simulations because of its simplicity.

## Connection to Meditation Research

Neural models can help explain *why* brain waves change during meditation. For example, if meditation modulates the input to cortical neurons (perhaps through thalamic gating), models can predict the resulting changes in oscillatory patterns. The alpha rhythm increase during meditation may arise from changes in thalamocortical loop dynamics — something that can be explored with networks of LIF neurons.');

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (19, 1, 'Simulate a leaky integrate-and-fire neuron',
  'Implement a basic LIF neuron and simulate it for 1 second with a constant input current.

Parameters:
- tau = 0.010 (10 ms membrane time constant)
- V_rest = -70 mV
- V_thresh = -55 mV
- R = 10 MOhm
- dt = 0.0001 (0.1 ms)
- I_input = 2.0 nA (constant)
- Duration = 1 second

Steps:
1. Create time vector and initialize V to V_rest at all time points
2. Loop through time: update V using Euler method, check for threshold crossing, reset if spike
3. Count the number of spikes
4. Display: the number of spikes and the firing rate in Hz

No rng needed (deterministic simulation).',
  '% Leaky Integrate-and-Fire neuron
tau = 0.010;       % membrane time constant (s)
V_rest = -70;      % resting potential (mV)
V_thresh = -55;    % threshold (mV)
R = 10;            % membrane resistance (MOhm)
dt = 0.0001;       % time step (s)
I_input = 2.0;     % input current (nA)
duration = 1;      % simulation time (s)

t = 0:dt:duration-dt;
num_steps = length(t);

% Initialize membrane potential
V = ones(1, num_steps) * V_rest;
spike_count = 0;

% Simulate
for i = 2:num_steps
  % Update membrane potential (Euler method)
  % YOUR CODE HERE

  % Check for spike
  % YOUR CODE HERE
end

% Display results
% YOUR CODE HERE
',
  'tau = 0.010;
V_rest = -70;
V_thresh = -55;
R = 10;
dt = 0.0001;
I_input = 2.0;
duration = 1;

t = 0:dt:duration-dt;
num_steps = length(t);

V = ones(1, num_steps) * V_rest;
spike_count = 0;

for i = 2:num_steps
  dV = (-(V(i-1) - V_rest) + R * I_input) / tau;
  V(i) = V(i-1) + dV * dt;

  if V(i) >= V_thresh
    V(i) = V_rest;
    spike_count = spike_count + 1;
  end
end

firing_rate = spike_count / duration;

disp([''Number of spikes: '' num2str(spike_count)]);
disp([''Firing rate: '' num2str(firing_rate) '' Hz'']);',
  '["The Euler update: dV = (-(V(i-1) - V_rest) + R * I_input) / tau; V(i) = V(i-1) + dV * dt;","Spike check: if V(i) >= V_thresh, then V(i) = V_rest; spike_count = spike_count + 1; end","Firing rate = spike_count / duration. Display with disp([''Number of spikes: '' num2str(spike_count)]);"]',
  '[{"expected_output":"Number of spikes: 56\nFiring rate: 56 Hz\n"}]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (19, 2, 'Vary input current and observe firing rate',
  'Compute the F-I curve (firing rate vs input current) for the LIF neuron.

Test 9 input currents: I_values = [0.5, 1.0, 1.2, 1.5, 1.8, 2.0, 2.5, 3.0, 4.0] nA

Use the same neuron parameters as Exercise 1 (tau=0.010, V_rest=-70, V_thresh=-55, R=10, dt=0.0001, duration=1).

For each current:
1. Simulate the LIF neuron for 1 second
2. Count spikes
3. Record firing rate

Display the current and firing rate for each value, one per line, in the format: ''I = X.X nA -> Y Hz''',
  '% F-I curve for LIF neuron
tau = 0.010;
V_rest = -70;
V_thresh = -55;
R = 10;
dt = 0.0001;
duration = 1;

I_values = [0.5, 1.0, 1.2, 1.5, 1.8, 2.0, 2.5, 3.0, 4.0];
firing_rates = zeros(1, length(I_values));

t = 0:dt:duration-dt;
num_steps = length(t);

for idx = 1:length(I_values)
  I_input = I_values(idx);
  V = ones(1, num_steps) * V_rest;
  spike_count = 0;

  % Simulate
  % YOUR CODE HERE

  firing_rates(idx) = spike_count / duration;
end

% Display results
% YOUR CODE HERE
',
  'tau = 0.010;
V_rest = -70;
V_thresh = -55;
R = 10;
dt = 0.0001;
duration = 1;

I_values = [0.5, 1.0, 1.2, 1.5, 1.8, 2.0, 2.5, 3.0, 4.0];
firing_rates = zeros(1, length(I_values));

t = 0:dt:duration-dt;
num_steps = length(t);

for idx = 1:length(I_values)
  I_input = I_values(idx);
  V = ones(1, num_steps) * V_rest;
  spike_count = 0;

  for i = 2:num_steps
    dV = (-(V(i-1) - V_rest) + R * I_input) / tau;
    V(i) = V(i-1) + dV * dt;

    if V(i) >= V_thresh
      V(i) = V_rest;
      spike_count = spike_count + 1;
    end
  end

  firing_rates(idx) = spike_count / duration;
end

for idx = 1:length(I_values)
  disp([''I = '' num2str(I_values(idx), ''%.1f'') '' nA -> '' num2str(firing_rates(idx)) '' Hz'']);
end',
  '["The inner simulation loop is identical to Exercise 1. Just wrap it in an outer loop over I_values: for idx = 1:length(I_values) ... I_input = I_values(idx); ... end","For each current value, reset V and spike_count before simulating. V = ones(1, num_steps) * V_rest; spike_count = 0; Then run the Euler loop.","Display: for idx = 1:length(I_values)  disp([''I = '' num2str(I_values(idx), ''%.1f'') '' nA -> '' num2str(firing_rates(idx)) '' Hz'']); end"]',
  '[{"expected_output":"I = 0.5 nA -> 0 Hz\nI = 1.0 nA -> 0 Hz\nI = 1.2 nA -> 0 Hz\nI = 1.5 nA -> 0 Hz\nI = 1.8 nA -> 33 Hz\nI = 2.0 nA -> 56 Hz\nI = 2.5 nA -> 95 Hz\nI = 3.0 nA -> 126 Hz\nI = 4.0 nA -> 178 Hz\n"}]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (19, 3, 'Plot membrane potential with spike resets',
  'Simulate a LIF neuron with I = 2.0 nA and create a detailed plot of the membrane potential over time, showing the characteristic sawtooth pattern of integrate-and-fire behavior.

Use the same parameters (tau=0.010, V_rest=-70, V_thresh=-55, R=10, dt=0.0001, duration=0.2 seconds — shorter for a clearer plot).

Modification: When a spike occurs, briefly set V to +20 mV (to visually represent the spike) before resetting to V_rest. This means:
- When V >= V_thresh: set V(i) = 20 (spike visualization), then on the next step it resets to V_rest.

Create a figure with:
- Membrane potential vs time
- A dashed red horizontal line at the threshold (-55 mV)
- A dashed blue horizontal line at the resting potential (-70 mV)
- X-axis: ''Time (s)'', Y-axis: ''Membrane Potential (mV)''
- Title: ''LIF Neuron Membrane Potential''
- Legend with entries: ''V_m'', ''Threshold'', ''V_{rest}''',
  '% Plot LIF membrane potential
tau = 0.010;
V_rest = -70;
V_thresh = -55;
R = 10;
dt = 0.0001;
I_input = 2.0;
duration = 0.2;

t = 0:dt:duration-dt;
num_steps = length(t);

V = ones(1, num_steps) * V_rest;

for i = 2:num_steps
  % Check if previous step was a spike (V = 20)
  % YOUR CODE HERE

  % Normal Euler update
  % YOUR CODE HERE

  % Spike detection with visual spike
  % YOUR CODE HERE
end

% Create plot
figure;
% YOUR CODE HERE
',
  'tau = 0.010;
V_rest = -70;
V_thresh = -55;
R = 10;
dt = 0.0001;
I_input = 2.0;
duration = 0.2;

t = 0:dt:duration-dt;
num_steps = length(t);

V = ones(1, num_steps) * V_rest;

for i = 2:num_steps
  if V(i-1) == 20
    V(i) = V_rest;
  else
    dV = (-(V(i-1) - V_rest) + R * I_input) / tau;
    V(i) = V(i-1) + dV * dt;

    if V(i) >= V_thresh
      V(i) = 20;
    end
  end
end

figure;
plot(t, V, ''k'', ''LineWidth'', 1.2);
hold on;
plot([t(1) t(end)], [V_thresh V_thresh], ''r--'', ''LineWidth'', 1);
plot([t(1) t(end)], [V_rest V_rest], ''b--'', ''LineWidth'', 1);
hold off;
xlabel(''Time (s)'');
ylabel(''Membrane Potential (mV)'');
title(''LIF Neuron Membrane Potential'');
legend(''V_m'', ''Threshold'', ''V_{rest}'');
ylim([V_rest-5 30]);',
  '["After a spike (V(i-1) == 20), reset: V(i) = V_rest. Otherwise, do the normal Euler update. Then check if V(i) >= V_thresh and if so, set V(i) = 20.","Use if/else: if V(i-1) == 20, V(i) = V_rest; else, compute dV and update, then check threshold; end","For plotting: plot(t, V, ''k''); hold on; plot([t(1) t(end)], [V_thresh V_thresh], ''r--''); plot([t(1) t(end)], [V_rest V_rest], ''b--''); legend(''V_m'', ''Threshold'', ''V_{rest}'');"]',
  '[]',
  true);


-- ============================================
-- Lesson 20: Capstone: Meditation EEG Study
-- ============================================
INSERT INTO lessons (id, phase, order_num, title, description, difficulty, estimated_minutes, content_md)
VALUES (20, 4, 6, 'Capstone: Meditation EEG Study',
  'Bring it all together — build a complete EEG analysis pipeline from data simulation to publication-quality figures for a meditation study.',
  'advanced', 60,
  '# Capstone: Meditation EEG Study

This is it — the final lesson. Everything you have learned across all four phases comes together here.

You are going to build a **complete analysis pipeline** for a simulated meditation EEG study, just like the one your friend might run in their lab. By the end of this lesson, you will have:

1. Generated realistic multi-channel, multi-condition EEG data
2. Preprocessed it (referencing, artifact removal)
3. Performed spectral analysis across frequency bands
4. Compared meditation vs. baseline conditions
5. Created a publication-quality figure showing the results

This is a real-world workflow. The only difference between this and an actual study is that we simulate the data instead of loading it from a recording system.

## The Study Design

Imagine this experiment:
- **Participants:** 1 (for simplicity, but real studies have 20+)
- **Channels:** 4 EEG electrodes (Fz, Cz, Pz, Oz — frontal, central, parietal, occipital)
- **Conditions:** Baseline (eyes closed, resting) and Meditation (guided meditation)
- **Duration:** 60 seconds per condition
- **Hypothesis:** Alpha power (8-13 Hz) increases during meditation, especially at posterior electrodes (Pz, Oz)

## What Makes This a Capstone?

Each exercise in this lesson pulls from skills you learned earlier:

- **Phase 1:** Variables, loops, arrays — building the simulation
- **Phase 2:** Matrix operations, functions — organizing the pipeline
- **Phase 3:** FFT, filtering, plotting — the core analysis
- **Phase 4:** EEG preprocessing, spectral analysis, neuroscience interpretation

## Tips for the Exercises

- These exercises are longer than previous ones. Take your time.
- Read the full prompt before starting to code.
- Build incrementally: get one section working, then add the next.
- Use the hints if you get stuck — there is no shame in that.

Let''s do this.');

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (20, 1, 'Build a complete preprocessing pipeline',
  'Build a complete EEG preprocessing pipeline for a simulated meditation study.

Steps:
1. Use rand("state", 200); randn("state", 200). Set fs = 256, duration = 60 seconds per condition.
2. Define 4 channels: Fz, Cz, Pz, Oz.
3. Simulate BASELINE data (4 channels x samples):
   - All channels: alpha (10 Hz) amplitude [5, 6, 8, 9] per channel + beta (20 Hz) amplitude 7 + theta (6 Hz) amplitude 3 + noise std 4
4. Simulate MEDITATION data (4 channels x samples):
   - All channels: alpha (10 Hz) amplitude [10, 14, 22, 25] per channel + beta (20 Hz) amplitude 3 + theta (6 Hz) amplitude 10 + noise std 3
5. Insert 5 blink artifacts in each condition at random positions in channel 1 (Fz): add 200 uV for 50 samples each. Use artifact_starts_base = sort(randi([100, num_samples-100], 1, 5)) for baseline, then artifact_starts_med = sort(randi([100, num_samples-100], 1, 5)) for meditation.
6. Apply average reference to both conditions.
7. Detect artifacts: any time point where any channel exceeds abs > 60 uV. Create a clean version by setting artifact time points to 0 across all channels.
8. Create a 2x2 subplot figure showing:
   - (1,1): Raw baseline Fz channel — title: ''Baseline - Raw (Fz)''
   - (1,2): Clean baseline Fz channel — title: ''Baseline - Cleaned (Fz)''
   - (2,1): Raw meditation Fz channel — title: ''Meditation - Raw (Fz)''
   - (2,2): Clean meditation Fz channel — title: ''Meditation - Cleaned (Fz)''
   - All subplots: xlabel ''Time (s)'', ylabel ''Voltage (uV)''
   - Main title: ''Preprocessing Pipeline: Meditation EEG Study''',
  '% Capstone Exercise 1: Complete preprocessing pipeline
rand("state", 200); randn("state", 200);

fs = 256;
duration = 60;
t = 0:1/fs:duration-1/fs;
num_samples = length(t);
channel_names = {''Fz'', ''Cz'', ''Pz'', ''Oz''};
num_channels = 4;

% Alpha amplitudes per channel
alpha_amp_base = [5, 6, 8, 9];
alpha_amp_med = [10, 14, 22, 25];

% Simulate baseline data
baseline = zeros(num_channels, num_samples);
for ch = 1:num_channels
  % YOUR CODE HERE
end

% Simulate meditation data
meditation = zeros(num_channels, num_samples);
for ch = 1:num_channels
  % YOUR CODE HERE
end

% Insert blink artifacts in Fz (channel 1)
artifact_starts_base = sort(randi([100, num_samples-100], 1, 5));
% YOUR CODE HERE

artifact_starts_med = sort(randi([100, num_samples-100], 1, 5));
% YOUR CODE HERE

% Save raw copies for plotting
baseline_raw = baseline;
meditation_raw = meditation;

% Average reference
% YOUR CODE HERE

% Artifact detection and cleaning (threshold = 60 uV)
threshold = 60;
% YOUR CODE HERE

% Plot 2x2 figure
figure;
% YOUR CODE HERE
',
  'rand("state", 200); randn("state", 200);

fs = 256;
duration = 60;
t = 0:1/fs:duration-1/fs;
num_samples = length(t);
channel_names = {''Fz'', ''Cz'', ''Pz'', ''Oz''};
num_channels = 4;

alpha_amp_base = [5, 6, 8, 9];
alpha_amp_med = [10, 14, 22, 25];

baseline = zeros(num_channels, num_samples);
for ch = 1:num_channels
  baseline(ch,:) = alpha_amp_base(ch)*sin(2*pi*10*t) + 7*sin(2*pi*20*t) + 3*sin(2*pi*6*t) + 4*randn(1, num_samples);
end

meditation = zeros(num_channels, num_samples);
for ch = 1:num_channels
  meditation(ch,:) = alpha_amp_med(ch)*sin(2*pi*10*t) + 3*sin(2*pi*20*t) + 10*sin(2*pi*6*t) + 3*randn(1, num_samples);
end

artifact_starts_base = sort(randi([100, num_samples-100], 1, 5));
for a = 1:5
  idx = artifact_starts_base(a):artifact_starts_base(a)+49;
  baseline(1, idx) = baseline(1, idx) + 200;
end

artifact_starts_med = sort(randi([100, num_samples-100], 1, 5));
for a = 1:5
  idx = artifact_starts_med(a):artifact_starts_med(a)+49;
  meditation(1, idx) = meditation(1, idx) + 200;
end

baseline_raw = baseline;
meditation_raw = meditation;

avg_ref_base = mean(baseline, 1);
baseline = baseline - avg_ref_base;

avg_ref_med = mean(meditation, 1);
meditation = meditation - avg_ref_med;

threshold = 60;
art_mask_base = any(abs(baseline) > threshold, 1);
baseline(:, art_mask_base) = 0;

art_mask_med = any(abs(meditation) > threshold, 1);
meditation(:, art_mask_med) = 0;

figure;
subplot(2,2,1);
plot(t, baseline_raw(1,:));
xlabel(''Time (s)''); ylabel(''Voltage (uV)'');
title(''Baseline - Raw (Fz)'');

subplot(2,2,2);
plot(t, baseline(1,:));
xlabel(''Time (s)''); ylabel(''Voltage (uV)'');
title(''Baseline - Cleaned (Fz)'');

subplot(2,2,3);
plot(t, meditation_raw(1,:));
xlabel(''Time (s)''); ylabel(''Voltage (uV)'');
title(''Meditation - Raw (Fz)'');

subplot(2,2,4);
plot(t, meditation(1,:));
xlabel(''Time (s)''); ylabel(''Voltage (uV)'');
title(''Meditation - Cleaned (Fz)'');

sgtitle(''Preprocessing Pipeline: Meditation EEG Study'');',
  '["For simulation: baseline(ch,:) = alpha_amp_base(ch)*sin(2*pi*10*t) + 7*sin(2*pi*20*t) + 3*sin(2*pi*6*t) + 4*randn(1, num_samples); Same pattern for meditation with different amplitudes.","For artifacts: for a = 1:5, idx = artifact_starts_base(a):artifact_starts_base(a)+49; baseline(1, idx) = baseline(1, idx) + 200; end. Average reference: avg_ref = mean(baseline, 1); baseline = baseline - avg_ref;","Artifact detection: art_mask_base = any(abs(baseline) > threshold, 1); baseline(:, art_mask_base) = 0; Plot with subplot(2,2,1), etc. Use sgtitle for the main title."]',
  '[]',
  true);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (20, 2, 'Spectral analysis: meditation vs baseline',
  'Perform spectral analysis on the simulated meditation EEG data to compare frequency band power between conditions.

Steps:
1. Use rand("state", 200); randn("state", 200). Regenerate the same data as Exercise 1 (same simulation, artifacts, referencing, cleaning).
2. For each channel and each condition, compute the power spectrum using FFT on the cleaned data.
3. Compute band power for each channel in both conditions:
   - Theta (4-8 Hz)
   - Alpha (8-13 Hz)
   - Beta (13-30 Hz)
4. Create a figure with 2 subplots (side by side):
   - Left subplot: grouped bar chart of alpha power by channel for baseline (blue) and meditation (red). Title: ''Alpha Power by Channel''. Ylabel: ''Power (uV^2)''. Set XTickLabel to channel names.
   - Right subplot: grouped bar chart showing all three bands (theta, alpha, beta) averaged across channels for both conditions. Title: ''Band Power: Baseline vs Meditation''. Ylabel: ''Power (uV^2)''. Set XTickLabel to band names.
   - Main title: ''Spectral Analysis: Meditation vs Baseline''
   - Add legends to both subplots: ''Baseline'', ''Meditation''',
  '% Capstone Exercise 2: Spectral analysis
rand("state", 200); randn("state", 200);

fs = 256;
duration = 60;
t = 0:1/fs:duration-1/fs;
num_samples = length(t);
channel_names = {''Fz'', ''Cz'', ''Pz'', ''Oz''};
num_channels = 4;
alpha_amp_base = [5, 6, 8, 9];
alpha_amp_med = [10, 14, 22, 25];

% --- Regenerate and preprocess (same as Exercise 1) ---
baseline = zeros(num_channels, num_samples);
for ch = 1:num_channels
  baseline(ch,:) = alpha_amp_base(ch)*sin(2*pi*10*t) + 7*sin(2*pi*20*t) + 3*sin(2*pi*6*t) + 4*randn(1, num_samples);
end
meditation = zeros(num_channels, num_samples);
for ch = 1:num_channels
  meditation(ch,:) = alpha_amp_med(ch)*sin(2*pi*10*t) + 3*sin(2*pi*20*t) + 10*sin(2*pi*6*t) + 3*randn(1, num_samples);
end
artifact_starts_base = sort(randi([100, num_samples-100], 1, 5));
for a = 1:5
  idx = artifact_starts_base(a):artifact_starts_base(a)+49;
  baseline(1, idx) = baseline(1, idx) + 200;
end
artifact_starts_med = sort(randi([100, num_samples-100], 1, 5));
for a = 1:5
  idx = artifact_starts_med(a):artifact_starts_med(a)+49;
  meditation(1, idx) = meditation(1, idx) + 200;
end
avg_ref_base = mean(baseline, 1); baseline = baseline - avg_ref_base;
avg_ref_med = mean(meditation, 1); meditation = meditation - avg_ref_med;
threshold = 60;
art_mask_base = any(abs(baseline) > threshold, 1); baseline(:, art_mask_base) = 0;
art_mask_med = any(abs(meditation) > threshold, 1); meditation(:, art_mask_med) = 0;
% --- End preprocessing ---

% Compute power spectra per channel
N = num_samples;
freqs = (0:N/2) * fs / N;

theta_idx = freqs >= 4 & freqs < 8;
alpha_idx = freqs >= 8 & freqs <= 13;
beta_idx = freqs > 13 & freqs <= 30;

% Store band power for each channel
alpha_base = zeros(1, num_channels);
alpha_med = zeros(1, num_channels);
theta_base = zeros(1, num_channels);
theta_med = zeros(1, num_channels);
beta_base = zeros(1, num_channels);
beta_med = zeros(1, num_channels);

for ch = 1:num_channels
  % Compute power spectra for this channel
  % YOUR CODE HERE

  % Extract band powers
  % YOUR CODE HERE
end

% Create figure
figure;
% YOUR CODE HERE
',
  'rand("state", 200); randn("state", 200);

fs = 256;
duration = 60;
t = 0:1/fs:duration-1/fs;
num_samples = length(t);
channel_names = {''Fz'', ''Cz'', ''Pz'', ''Oz''};
num_channels = 4;
alpha_amp_base = [5, 6, 8, 9];
alpha_amp_med = [10, 14, 22, 25];

baseline = zeros(num_channels, num_samples);
for ch = 1:num_channels
  baseline(ch,:) = alpha_amp_base(ch)*sin(2*pi*10*t) + 7*sin(2*pi*20*t) + 3*sin(2*pi*6*t) + 4*randn(1, num_samples);
end
meditation = zeros(num_channels, num_samples);
for ch = 1:num_channels
  meditation(ch,:) = alpha_amp_med(ch)*sin(2*pi*10*t) + 3*sin(2*pi*20*t) + 10*sin(2*pi*6*t) + 3*randn(1, num_samples);
end
artifact_starts_base = sort(randi([100, num_samples-100], 1, 5));
for a = 1:5
  idx = artifact_starts_base(a):artifact_starts_base(a)+49;
  baseline(1, idx) = baseline(1, idx) + 200;
end
artifact_starts_med = sort(randi([100, num_samples-100], 1, 5));
for a = 1:5
  idx = artifact_starts_med(a):artifact_starts_med(a)+49;
  meditation(1, idx) = meditation(1, idx) + 200;
end
avg_ref_base = mean(baseline, 1); baseline = baseline - avg_ref_base;
avg_ref_med = mean(meditation, 1); meditation = meditation - avg_ref_med;
threshold = 60;
art_mask_base = any(abs(baseline) > threshold, 1); baseline(:, art_mask_base) = 0;
art_mask_med = any(abs(meditation) > threshold, 1); meditation(:, art_mask_med) = 0;

N = num_samples;
freqs = (0:N/2) * fs / N;

theta_idx = freqs >= 4 & freqs < 8;
alpha_idx = freqs >= 8 & freqs <= 13;
beta_idx = freqs > 13 & freqs <= 30;

alpha_base = zeros(1, num_channels);
alpha_med = zeros(1, num_channels);
theta_base = zeros(1, num_channels);
theta_med = zeros(1, num_channels);
beta_base = zeros(1, num_channels);
beta_med = zeros(1, num_channels);

for ch = 1:num_channels
  fft_base = fft(baseline(ch,:));
  power_base = (abs(fft_base(1:N/2+1)).^2) / N;

  fft_med = fft(meditation(ch,:));
  power_med = (abs(fft_med(1:N/2+1)).^2) / N;

  alpha_base(ch) = sum(power_base(alpha_idx));
  alpha_med(ch) = sum(power_med(alpha_idx));
  theta_base(ch) = sum(power_base(theta_idx));
  theta_med(ch) = sum(power_med(theta_idx));
  beta_base(ch) = sum(power_base(beta_idx));
  beta_med(ch) = sum(power_med(beta_idx));
end

figure;
subplot(1,2,1);
alpha_data = [alpha_base; alpha_med]'';
bar(alpha_data);
set(gca, ''XTickLabel'', channel_names);
ylabel(''Power (uV^2)'');
title(''Alpha Power by Channel'');
legend(''Baseline'', ''Meditation'');

subplot(1,2,2);
band_base_avg = [mean(theta_base), mean(alpha_base), mean(beta_base)];
band_med_avg = [mean(theta_med), mean(alpha_med), mean(beta_med)];
band_data = [band_base_avg; band_med_avg]'';
bar(band_data);
set(gca, ''XTickLabel'', {''Theta'', ''Alpha'', ''Beta''});
ylabel(''Power (uV^2)'');
title(''Band Power: Baseline vs Meditation'');
legend(''Baseline'', ''Meditation'');

sgtitle(''Spectral Analysis: Meditation vs Baseline'');',
  '["For each channel: fft_base = fft(baseline(ch,:)); power_base = (abs(fft_base(1:N/2+1)).^2)/N; Same for meditation. Then extract bands: alpha_base(ch) = sum(power_base(alpha_idx));","For the left subplot: create a matrix alpha_data = [alpha_base; alpha_med]''; then bar(alpha_data); set(gca, ''XTickLabel'', channel_names);","For the right subplot: average across channels: band_base_avg = [mean(theta_base), mean(alpha_base), mean(beta_base)]; band_data = [band_base_avg; band_med_avg]''; bar(band_data); set(gca, ''XTickLabel'', {''Theta'', ''Alpha'', ''Beta''});"]',
  '[]',
  true);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (20, 3, 'Create a publication-quality figure',
  'Create a polished, publication-quality multi-panel figure that summarizes the complete meditation EEG study results.

Regenerate the same data (rand("state", 200); randn("state", 200), same pipeline as Exercises 1-2). Then create a figure with 6 panels (3 rows x 2 columns):

**Row 1: Power Spectra**
- (1,1): Power spectrum (1-40 Hz) for Oz channel — baseline. Shade alpha band (8-13 Hz) in light blue. Title: ''Baseline Power Spectrum (Oz)''. Ylabel: ''Power (uV^2)''. Xlabel: ''Frequency (Hz)''.
- (1,2): Power spectrum (1-40 Hz) for Oz channel — meditation. Shade alpha band in light red. Title: ''Meditation Power Spectrum (Oz)''. Same axis labels.

**Row 2: Topographic-style Bar Comparisons**
- (2,1): Grouped bar chart of alpha power per channel (baseline vs meditation). Title: ''Alpha Power by Channel''. Legend: ''Baseline'', ''Meditation''.
- (2,2): Bar chart showing percentage change in alpha power per channel. Title: ''Alpha Power Change (%)''. Color bars green. Add a horizontal dashed line at 0.

**Row 3: Summary**
- (3,1): Grouped bar chart of all bands (theta, alpha, beta) averaged across all channels. Title: ''Average Band Power''. Legend: ''Baseline'', ''Meditation''.
- (3,2): Text summary panel. Use text() to display key findings:
  - ''Meditation EEG Study Results'' (bold-style, larger)
  - The mean alpha power change across channels (rounded to 1 decimal)
  - The channel with maximum alpha increase
  - Set axis off. Title: ''Summary''.

Main figure title: ''Meditation EEG Study: Complete Results''

Make the figure large: set figure position to [50, 50, 1200, 900].',
  '% Capstone Exercise 3: Publication-quality figure
rand("state", 200); randn("state", 200);

fs = 256;
duration = 60;
t = 0:1/fs:duration-1/fs;
num_samples = length(t);
channel_names = {''Fz'', ''Cz'', ''Pz'', ''Oz''};
num_channels = 4;
alpha_amp_base = [5, 6, 8, 9];
alpha_amp_med = [10, 14, 22, 25];

% --- Full pipeline: simulate, artifact, reference, clean ---
baseline = zeros(num_channels, num_samples);
for ch = 1:num_channels
  baseline(ch,:) = alpha_amp_base(ch)*sin(2*pi*10*t) + 7*sin(2*pi*20*t) + 3*sin(2*pi*6*t) + 4*randn(1, num_samples);
end
meditation = zeros(num_channels, num_samples);
for ch = 1:num_channels
  meditation(ch,:) = alpha_amp_med(ch)*sin(2*pi*10*t) + 3*sin(2*pi*20*t) + 10*sin(2*pi*6*t) + 3*randn(1, num_samples);
end
artifact_starts_base = sort(randi([100, num_samples-100], 1, 5));
for a = 1:5
  idx = artifact_starts_base(a):artifact_starts_base(a)+49;
  baseline(1, idx) = baseline(1, idx) + 200;
end
artifact_starts_med = sort(randi([100, num_samples-100], 1, 5));
for a = 1:5
  idx = artifact_starts_med(a):artifact_starts_med(a)+49;
  meditation(1, idx) = meditation(1, idx) + 200;
end
avg_ref_base = mean(baseline, 1); baseline = baseline - avg_ref_base;
avg_ref_med = mean(meditation, 1); meditation = meditation - avg_ref_med;
threshold = 60;
art_mask_base = any(abs(baseline) > threshold, 1); baseline(:, art_mask_base) = 0;
art_mask_med = any(abs(meditation) > threshold, 1); meditation(:, art_mask_med) = 0;

% --- Compute spectra and band powers ---
N = num_samples;
freqs = (0:N/2) * fs / N;
theta_idx = freqs >= 4 & freqs < 8;
alpha_idx = freqs >= 8 & freqs <= 13;
beta_idx = freqs > 13 & freqs <= 30;
plot_idx = freqs >= 1 & freqs <= 40;

alpha_base = zeros(1, num_channels);
alpha_med = zeros(1, num_channels);
theta_base = zeros(1, num_channels);
theta_med = zeros(1, num_channels);
beta_base = zeros(1, num_channels);
beta_med = zeros(1, num_channels);

power_base_all = zeros(num_channels, sum(freqs >= 0 & freqs <= fs/2));
power_med_all = zeros(num_channels, sum(freqs >= 0 & freqs <= fs/2));

for ch = 1:num_channels
  fft_base = fft(baseline(ch,:));
  pb = (abs(fft_base(1:N/2+1)).^2) / N;
  power_base_all(ch,:) = pb;

  fft_med = fft(meditation(ch,:));
  pm = (abs(fft_med(1:N/2+1)).^2) / N;
  power_med_all(ch,:) = pm;

  alpha_base(ch) = sum(pb(alpha_idx));
  alpha_med(ch) = sum(pm(alpha_idx));
  theta_base(ch) = sum(pb(theta_idx));
  theta_med(ch) = sum(pm(theta_idx));
  beta_base(ch) = sum(pb(beta_idx));
  beta_med(ch) = sum(pm(beta_idx));
end

alpha_change_pct = (alpha_med - alpha_base) ./ alpha_base * 100;

% --- Create publication-quality figure ---
figure(''Position'', [50, 50, 1200, 900]);

% Row 1: Power spectra for Oz (channel 4)
% YOUR CODE HERE

% Row 2: Alpha comparisons
% YOUR CODE HERE

% Row 3: Summary
% YOUR CODE HERE

sgtitle(''Meditation EEG Study: Complete Results'');
',
  'rand("state", 200); randn("state", 200);

fs = 256;
duration = 60;
t = 0:1/fs:duration-1/fs;
num_samples = length(t);
channel_names = {''Fz'', ''Cz'', ''Pz'', ''Oz''};
num_channels = 4;
alpha_amp_base = [5, 6, 8, 9];
alpha_amp_med = [10, 14, 22, 25];

baseline = zeros(num_channels, num_samples);
for ch = 1:num_channels
  baseline(ch,:) = alpha_amp_base(ch)*sin(2*pi*10*t) + 7*sin(2*pi*20*t) + 3*sin(2*pi*6*t) + 4*randn(1, num_samples);
end
meditation = zeros(num_channels, num_samples);
for ch = 1:num_channels
  meditation(ch,:) = alpha_amp_med(ch)*sin(2*pi*10*t) + 3*sin(2*pi*20*t) + 10*sin(2*pi*6*t) + 3*randn(1, num_samples);
end
artifact_starts_base = sort(randi([100, num_samples-100], 1, 5));
for a = 1:5
  idx = artifact_starts_base(a):artifact_starts_base(a)+49;
  baseline(1, idx) = baseline(1, idx) + 200;
end
artifact_starts_med = sort(randi([100, num_samples-100], 1, 5));
for a = 1:5
  idx = artifact_starts_med(a):artifact_starts_med(a)+49;
  meditation(1, idx) = meditation(1, idx) + 200;
end
avg_ref_base = mean(baseline, 1); baseline = baseline - avg_ref_base;
avg_ref_med = mean(meditation, 1); meditation = meditation - avg_ref_med;
threshold = 60;
art_mask_base = any(abs(baseline) > threshold, 1); baseline(:, art_mask_base) = 0;
art_mask_med = any(abs(meditation) > threshold, 1); meditation(:, art_mask_med) = 0;

N = num_samples;
freqs = (0:N/2) * fs / N;
theta_idx = freqs >= 4 & freqs < 8;
alpha_idx = freqs >= 8 & freqs <= 13;
beta_idx = freqs > 13 & freqs <= 30;
plot_idx = freqs >= 1 & freqs <= 40;

alpha_base = zeros(1, num_channels);
alpha_med = zeros(1, num_channels);
theta_base = zeros(1, num_channels);
theta_med = zeros(1, num_channels);
beta_base = zeros(1, num_channels);
beta_med = zeros(1, num_channels);

power_base_all = zeros(num_channels, N/2+1);
power_med_all = zeros(num_channels, N/2+1);

for ch = 1:num_channels
  fft_base = fft(baseline(ch,:));
  pb = (abs(fft_base(1:N/2+1)).^2) / N;
  power_base_all(ch,:) = pb;

  fft_med = fft(meditation(ch,:));
  pm = (abs(fft_med(1:N/2+1)).^2) / N;
  power_med_all(ch,:) = pm;

  alpha_base(ch) = sum(pb(alpha_idx));
  alpha_med(ch) = sum(pm(alpha_idx));
  theta_base(ch) = sum(pb(theta_idx));
  theta_med(ch) = sum(pm(theta_idx));
  beta_base(ch) = sum(pb(beta_idx));
  beta_med(ch) = sum(pm(beta_idx));
end

alpha_change_pct = (alpha_med - alpha_base) ./ alpha_base * 100;

figure(''Position'', [50, 50, 1200, 900]);

subplot(3,2,1);
plot(freqs(plot_idx), power_base_all(4, plot_idx), ''b'', ''LineWidth'', 1.2);
hold on;
alpha_plot_idx = freqs >= 8 & freqs <= 13 & plot_idx;
area_x = freqs(alpha_plot_idx);
area_y = power_base_all(4, alpha_plot_idx);
fill([area_x, fliplr(area_x)], [area_y, zeros(1, length(area_y))], [0.7 0.7 1], ''FaceAlpha'', 0.5, ''EdgeColor'', ''none'');
hold off;
xlabel(''Frequency (Hz)''); ylabel(''Power (uV^2)'');
title(''Baseline Power Spectrum (Oz)'');

subplot(3,2,2);
plot(freqs(plot_idx), power_med_all(4, plot_idx), ''r'', ''LineWidth'', 1.2);
hold on;
area_y_med = power_med_all(4, alpha_plot_idx);
fill([area_x, fliplr(area_x)], [area_y_med, zeros(1, length(area_y_med))], [1 0.7 0.7], ''FaceAlpha'', 0.5, ''EdgeColor'', ''none'');
hold off;
xlabel(''Frequency (Hz)''); ylabel(''Power (uV^2)'');
title(''Meditation Power Spectrum (Oz)'');

subplot(3,2,3);
alpha_data = [alpha_base; alpha_med]'';
bar(alpha_data);
set(gca, ''XTickLabel'', channel_names);
ylabel(''Power (uV^2)'');
title(''Alpha Power by Channel'');
legend(''Baseline'', ''Meditation'');

subplot(3,2,4);
bar(alpha_change_pct, ''FaceColor'', [0.3 0.8 0.3]);
set(gca, ''XTickLabel'', channel_names);
ylabel(''Change (%)'');
title(''Alpha Power Change (%)'');
hold on;
plot([0.5 4.5], [0 0], ''k--'');
hold off;

subplot(3,2,5);
band_base_avg = [mean(theta_base), mean(alpha_base), mean(beta_base)];
band_med_avg = [mean(theta_med), mean(alpha_med), mean(beta_med)];
band_data = [band_base_avg; band_med_avg]'';
bar(band_data);
set(gca, ''XTickLabel'', {''Theta'', ''Alpha'', ''Beta''});
ylabel(''Power (uV^2)'');
title(''Average Band Power'');
legend(''Baseline'', ''Meditation'');

subplot(3,2,6);
axis off;
mean_alpha_change = round(mean(alpha_change_pct)*10)/10;
[max_change, max_ch] = max(alpha_change_pct);
text(0.1, 0.85, ''Meditation EEG Study Results'', ''FontSize'', 14, ''FontWeight'', ''bold'');
text(0.1, 0.65, [''Mean alpha power increase: '' num2str(mean_alpha_change) ''%''], ''FontSize'', 11);
text(0.1, 0.45, [''Max increase channel: '' channel_names{max_ch} '' ('' num2str(round(max_change*10)/10) ''%)''], ''FontSize'', 11);
text(0.1, 0.25, ''Alpha increase supports meditation hypothesis'', ''FontSize'', 11);
title(''Summary'');

sgtitle(''Meditation EEG Study: Complete Results'');',
  '["Row 1: subplot(3,2,1) for baseline Oz spectrum. Plot with plot(freqs(plot_idx), power_base_all(4, plot_idx)). For shading alpha band, use fill() with the alpha frequency range. Repeat for subplot(3,2,2) with meditation.","Row 2: subplot(3,2,3) for grouped bar of alpha by channel: bar([alpha_base; alpha_med]''). subplot(3,2,4) for percentage change: bar(alpha_change_pct, ''FaceColor'', [0.3 0.8 0.3]); add plot([0.5 4.5], [0 0], ''k--'') for zero line.","Row 3: subplot(3,2,5) for band averages. subplot(3,2,6): axis off; then use text(x, y, ''string'') to place summary text. mean_alpha_change = round(mean(alpha_change_pct)*10)/10; [~,max_ch] = max(alpha_change_pct);"]',
  '[]',
  true);


-- ============================================
-- Lesson 21: Statistics for Neuroscience
-- ============================================
INSERT INTO lessons (id, phase, order_num, title, description, difficulty, estimated_minutes, content_md)
VALUES (21, 4, 7, 'Statistics for Neuroscience',
  'Hypothesis testing, t-tests, p-values, effect sizes, and multiple comparison corrections — the statistical tools every neuroscientist needs.',
  'advanced', 30,
  '# Statistics for Neuroscience

You have learned to collect, filter, and visualize brain data. But how do you know if what you see is **real** versus just random noise?

That is where statistics comes in.

## Why Statistics Matter

Imagine you run a meditation study. You measure alpha power (8-13 Hz) in two groups:
- **Group A:** 10 minutes of meditation
- **Group B:** 10 minutes of rest

Group A has slightly higher alpha power. But is the difference real, or could it be due to random variation between people?

Statistics gives you a principled way to answer this question.

## Hypothesis Testing: The Coin Flip Analogy

Imagine someone claims a coin is fair. You flip it 100 times and get 60 heads. Is the coin biased?

- **Null hypothesis (H0):** The coin is fair (50/50)
- **Alternative hypothesis (H1):** The coin is biased

The **p-value** answers: "If the coin really were fair, what is the probability of getting 60 or more heads by chance?"

If that probability is very low (typically p < 0.05), we reject H0 and conclude the coin is likely biased.

## The t-Test

The most common test in neuroscience is the **two-sample t-test**. It compares the means of two groups and asks: "Are these means significantly different?"

In Octave:
```matlab
[h, p] = t_test_2(group1, group2);
% h = 1 means reject null hypothesis (significant difference)
% p = p-value
```

## Effect Size: Cohen''s d

A p-value tells you if a difference is **statistically significant**, but not how **big** it is. Effect size (Cohen''s d) measures that:

```matlab
d = (mean(group1) - mean(group2)) / pooled_std;
```

| Cohen''s d | Interpretation |
|-----------|----------------|
| 0.2 | Small effect |
| 0.5 | Medium effect |
| 0.8 | Large effect |

## The Multiple Comparisons Problem

If you test 100 EEG channels for a difference at p < 0.05, you expect ~5 false positives **by pure chance**! This is the multiple comparisons problem.

**Bonferroni correction** is the simplest fix: divide your threshold by the number of tests.

```matlab
alpha_corrected = 0.05 / num_tests;
```

Let''s apply these tools!');

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (21, 1, 'Two-sample t-test',
  'Simulate a meditation study and run a t-test.

1. Set the random seed: rand(''state'', 42)
2. Generate simulated alpha power for two groups (30 subjects each):
   - meditation group: mean=10.5, std=2.0 → meditation = 10.5 + 2.0 * randn(1, 30)
   - rest group: mean=9.0, std=2.0 → rest = 9.0 + 2.0 * randn(1, 30)
3. Compute the t-statistic manually:
   - t = (mean(meditation) - mean(rest)) / sqrt(var(meditation)/30 + var(rest)/30)
4. Use Octave''s built-in: [h, p] = t_test_2(meditation, rest)
5. Display:
   - disp([''Meditation mean: '' num2str(mean(meditation), ''%.2f'')])
   - disp([''Rest mean: '' num2str(mean(rest), ''%.2f'')])
   - disp([''t-statistic: '' num2str(t, ''%.3f'')])
   - disp([''p-value: '' num2str(p, ''%.4f'')])
   - disp([''Significant (p<0.05): '' num2str(h)])',
  '% Two-sample t-test: Meditation vs Rest
rand(''state'', 42);

% Generate data
% YOUR CODE HERE

% Manual t-statistic
% YOUR CODE HERE

% Built-in t-test
% YOUR CODE HERE

% Display results
% YOUR CODE HERE
',
  'rand(''state'', 42);

meditation = 10.5 + 2.0 * randn(1, 30);
rest = 9.0 + 2.0 * randn(1, 30);

t = (mean(meditation) - mean(rest)) / sqrt(var(meditation)/30 + var(rest)/30);

[h, p] = t_test_2(meditation, rest);

disp([''Meditation mean: '' num2str(mean(meditation), ''%.2f'')]);
disp([''Rest mean: '' num2str(mean(rest), ''%.2f'')]);
disp([''t-statistic: '' num2str(t, ''%.3f'')]);
disp([''p-value: '' num2str(p, ''%.4f'')]);
disp([''Significant (p<0.05): '' num2str(h)]);',
  '["randn(1, 30) generates 30 random numbers from a standard normal distribution.","The t-statistic formula: t = (mean1 - mean2) / sqrt(var1/n1 + var2/n2)","t_test_2(x, y) is Octave''s built-in two-sample t-test. It returns [h, p]."]',
  '[]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (21, 2, 'Effect size (Cohen''s d)',
  'Compute Cohen''s d to measure how large the meditation effect is.

1. Set seed: rand(''state'', 42)
2. Generate the same data as Exercise 1
3. Compute the pooled standard deviation:
   pooled_std = sqrt(((30-1)*var(meditation) + (30-1)*var(rest)) / (30+30-2))
4. Compute Cohen''s d:
   d = (mean(meditation) - mean(rest)) / pooled_std
5. Classify the effect:
   if abs(d) >= 0.8: ''large''
   elseif abs(d) >= 0.5: ''medium''
   else: ''small''
6. Display:
   - disp([''Cohen''''s d: '' num2str(d, ''%.3f'')])
   - disp([''Effect size: '' classification])
   - disp([''Interpretation: The meditation group shows a [size] effect on alpha power''])',
  '% Effect size: Cohen''s d
rand(''state'', 42);

meditation = 10.5 + 2.0 * randn(1, 30);
rest = 9.0 + 2.0 * randn(1, 30);

% Compute pooled standard deviation
% YOUR CODE HERE

% Compute Cohen''s d
% YOUR CODE HERE

% Classify effect size
% YOUR CODE HERE

% Display results
% YOUR CODE HERE
',
  'rand(''state'', 42);

meditation = 10.5 + 2.0 * randn(1, 30);
rest = 9.0 + 2.0 * randn(1, 30);

pooled_std = sqrt(((30-1)*var(meditation) + (30-1)*var(rest)) / (30+30-2));

d = (mean(meditation) - mean(rest)) / pooled_std;

if abs(d) >= 0.8
  classification = ''large'';
elseif abs(d) >= 0.5
  classification = ''medium'';
else
  classification = ''small'';
end

disp([''Cohen''''s d: '' num2str(d, ''%.3f'')]);
disp([''Effect size: '' classification]);
disp([''Interpretation: The meditation group shows a '' classification '' effect on alpha power'']);',
  '["Pooled std combines the variance from both groups: sqrt(((n1-1)*var1 + (n2-1)*var2) / (n1+n2-2))","Cohen''s d = difference in means / pooled standard deviation","Use abs(d) for classification since the sign just indicates direction."]',
  '[]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (21, 3, 'Multiple comparison correction',
  'Demonstrate the multiple comparisons problem and Bonferroni correction.

1. Set seed: rand(''state'', 42)
2. Simulate testing 20 EEG channels where there is NO real effect:
   - For each channel i=1:20: generate two random groups (30 values each from the SAME distribution: randn(1,30))
   - Run t_test_2 on each pair, store the p-value
3. Count false positives at p < 0.05 (uncorrected)
4. Apply Bonferroni correction: corrected_alpha = 0.05 / 20
5. Count false positives at corrected alpha
6. Display:
   - disp([''Tests run: 20''])
   - disp([''Uncorrected false positives (p<0.05): '' num2str(uncorrected_fp)])
   - disp([''Bonferroni threshold: '' num2str(corrected_alpha, ''%.4f'')])
   - disp([''Corrected false positives: '' num2str(corrected_fp)])
   - disp([''Expected false positives (by chance): '' num2str(20*0.05)])
   - Then display each p-value: disp([''Channel '' num2str(i) '': p='' num2str(p, ''%.4f'') significance_marker])
     where significance_marker is '' *'' if p<0.05 and '' **'' if p<corrected_alpha',
  '% Multiple comparison correction
rand(''state'', 42);

num_tests = 20;
p_values = zeros(1, num_tests);

% Run 20 t-tests on random (no-effect) data
% YOUR CODE HERE

% Count false positives
corrected_alpha = 0.05 / num_tests;
% YOUR CODE HERE

% Display results
% YOUR CODE HERE
',
  'rand(''state'', 42);

num_tests = 20;
p_values = zeros(1, num_tests);

for i = 1:num_tests
  group1 = randn(1, 30);
  group2 = randn(1, 30);
  [~, p] = t_test_2(group1, group2);
  p_values(i) = p;
end

corrected_alpha = 0.05 / num_tests;
uncorrected_fp = sum(p_values < 0.05);
corrected_fp = sum(p_values < corrected_alpha);

disp([''Tests run: 20'']);
disp([''Uncorrected false positives (p<0.05): '' num2str(uncorrected_fp)]);
disp([''Bonferroni threshold: '' num2str(corrected_alpha, ''%.4f'')]);
disp([''Corrected false positives: '' num2str(corrected_fp)]);
disp([''Expected false positives (by chance): '' num2str(20*0.05)]);
disp('''');
disp(''=== Per-channel results ==='');
for i = 1:num_tests
  marker = '''';
  if p_values(i) < corrected_alpha
    marker = '' **'';
  elseif p_values(i) < 0.05
    marker = '' *'';
  end
  disp([''Channel '' num2str(i) '': p='' num2str(p_values(i), ''%.4f'') marker]);
end',
  '["Both groups come from the SAME distribution (randn), so any significant result is a false positive.","Bonferroni correction: divide alpha (0.05) by the number of tests (20).","At p<0.05 with 20 tests, you expect ~1 false positive by chance (5% of 20)."]',
  '[]',
  false);


-- ============================================
-- Lesson 22: Debugging & Defensive Coding
-- ============================================
INSERT INTO lessons (id, phase, order_num, title, description, difficulty, estimated_minutes, content_md)
VALUES (22, 4, 8, 'Debugging & Defensive Coding',
  'Learn to read error messages, debug common mistakes, and write robust code with try/catch and input validation.',
  'intermediate', 25,
  '# Debugging & Defensive Coding

Every programmer makes mistakes. The difference between a beginner and an experienced coder is not that experts make fewer errors — it is that they know how to **find and fix them quickly**.

This lesson teaches you to read error messages, use debugging tools, and write code that handles problems gracefully.

## Reading Error Messages

Octave error messages look scary, but they are actually trying to help you. Here is how to read them:

```
error: ''x'' undefined
```

This means: you used a variable called `x` that does not exist. Maybe you forgot to create it, or you have a typo.

## The 5 Most Common Errors

### 1. Undefined variable
```matlab
disp(x)  % error: ''x'' undefined
```
**Fix:** Define `x` before using it: `x = 5;`

### 2. Parse error (syntax mistake)
```matlab
for i = 1:10
  disp(i)
% error: parse error — missing ''end''
```
**Fix:** Every `for`, `if`, `while` needs a matching `end`.

### 3. Nonconformant arguments (size mismatch)
```matlab
a = [1 2 3];
b = [1 2];
a + b  % error: nonconformant arguments
```
**Fix:** Check sizes with `size(a)` and `size(b)` before operating.

### 4. Index out of bounds
```matlab
x = [10 20 30];
x(5)  % error: index (5): out of bound
```
**Fix:** Check `length(x)` before indexing.

### 5. Singular matrix
```matlab
A = [1 2; 2 4];  % rows are linearly dependent
inv(A)  % warning: matrix singular
```
**Fix:** Check `det(A)` or `rank(A)` first.

## try/catch: Handling Errors Gracefully

Instead of letting errors crash your program, you can catch them:

```matlab
try
  result = some_risky_operation();
catch e
  disp([''Error: '' e.message]);
  result = default_value;
end
```

This is essential for:
- Loading files that might not exist
- Processing data that might have unexpected formats
- Running analyses that might fail on some inputs

## Debugging Tools

- `size(x)` — check dimensions
- `class(x)` — check data type
- `disp(x)` — print values to inspect
- `whos` — see all variables and their sizes
- `isnan(x)` — check for NaN values

## The Golden Rule

**Always inspect your data before processing it.** A quick `size()`, `class()`, and `min()/max()` check can save you hours of debugging.');

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (22, 1, 'Error detective',
  'The code below has a bug that causes a dimension mismatch error. Your job:

1. Run the buggy code (it will error)
2. Read the error message carefully
3. Use size() to inspect the variables
4. Fix the bug so the code runs correctly
5. Display: disp([''Result: '' num2str(result)])

The code is supposed to compute the dot product of two vectors.
Hint: The dot product of [1,2,3] and [4,5,6] = 1*4 + 2*5 + 3*6 = 32',
  '% Bug: dimension mismatch in dot product
a = [1 2 3];       % 1x3 row vector
b = [4 5 6];       % 1x3 row vector

% This line has a bug — fix it!
result = a * b;    % matrix multiply requires compatible dimensions

disp([''Result: '' num2str(result)]);
',
  'a = [1 2 3];
b = [4 5 6];

% Fix: transpose b to make it a column vector for dot product
result = a * b'';  % or use: result = dot(a, b);

disp([''Result: '' num2str(result)]);',
  '["Matrix multiplication (a * b) requires the inner dimensions to match: (1×3) * (3×1) works, but (1×3) * (1×3) does not.","To fix this, you can transpose b with b'' to turn it from 1×3 to 3×1.","Or use the built-in dot(a, b) function which handles this automatically."]',
  '[{"expected_output":"Result: 32\n"}]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (22, 2, 'Try/catch for safe file loading',
  'Write a function that safely loads a file using try/catch.

1. Create a function called safe_load that:
   - Takes a filename as input
   - Tries to load it with load()
   - If it succeeds, returns the data and displays ''Loaded [filename] successfully''
   - If it fails, displays ''Warning: Could not load [filename] — [error message]'' and returns an empty struct
2. Test it with a file that does not exist: safe_load(''nonexistent_file.mat'')
3. Display: disp([''Result is empty: '' num2str(isempty(fieldnames(result)))])
4. Then test with a valid approach: create some data, save it, and load it:
   - test_value = 42; save(''/tmp/test_data.mat'', ''test_value'');
   - result2 = safe_load(''/tmp/test_data.mat'')
   - disp([''Loaded value: '' num2str(result2.test_value)])',
  '% Safe file loading with try/catch

% Define the safe_load function
% YOUR CODE HERE

% Test 1: file that doesn''t exist
% YOUR CODE HERE

% Test 2: file that does exist
% YOUR CODE HERE
',
  'function data = safe_load(filename)
  try
    data = load(filename);
    disp([''Loaded '' filename '' successfully'']);
  catch e
    disp([''Warning: Could not load '' filename '' - '' e.message]);
    data = struct();
  end
end

result = safe_load(''nonexistent_file.mat'');
disp([''Result is empty: '' num2str(isempty(fieldnames(result)))]);

test_value = 42;
save(''/tmp/test_data.mat'', ''test_value'');
result2 = safe_load(''/tmp/test_data.mat'');
disp([''Loaded value: '' num2str(result2.test_value)]);',
  '["The try/catch syntax: try ... catch e ... end. The variable e contains the error info.","e.message gives you the error message text.","Return struct() as an empty struct when loading fails."]',
  '[]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (22, 3, 'Defensive input validation',
  'Write a function that validates inputs before computing.

1. Create a function called safe_mean_signal that:
   - Takes one input: signal
   - Checks if input is numeric: if not, display error and return NaN
   - Checks if input is a vector (1D): if size has more than 1 non-singleton dimension, display error and return NaN
   - Checks for NaN values: if any, display a warning with count and remove them
   - Checks if signal is empty after NaN removal: if so, display error and return NaN
   - Returns the mean of the cleaned signal
2. Test with these cases:
   - safe_mean_signal([1 2 3 4 5]) → should work normally
   - safe_mean_signal(''hello'') → should catch non-numeric
   - safe_mean_signal([1 NaN 3 NaN 5]) → should warn about NaNs, return mean of [1 3 5]
   - safe_mean_signal([]) → should catch empty
3. For each test, display: disp([''Test N result: '' num2str(result)])',
  '% Defensive input validation

% Define safe_mean_signal function
% YOUR CODE HERE

% Test cases
disp(''=== Test 1: Normal vector ==='');
% YOUR CODE HERE

disp(''=== Test 2: Non-numeric input ==='');
% YOUR CODE HERE

disp(''=== Test 3: Vector with NaNs ==='');
% YOUR CODE HERE

disp(''=== Test 4: Empty input ==='');
% YOUR CODE HERE
',
  'function result = safe_mean_signal(signal)
  % Check if numeric
  if ~isnumeric(signal)
    disp(''Error: Input must be numeric'');
    result = NaN;
    return;
  end

  % Check if vector
  if ~isvector(signal) && ~isempty(signal)
    disp(''Error: Input must be a vector (1D)'');
    result = NaN;
    return;
  end

  % Check for empty
  if isempty(signal)
    disp(''Error: Input is empty'');
    result = NaN;
    return;
  end

  % Check for NaNs
  nan_count = sum(isnan(signal));
  if nan_count > 0
    disp([''Warning: Found '' num2str(nan_count) '' NaN values, removing them'']);
    signal = signal(~isnan(signal));
  end

  % Check if empty after NaN removal
  if isempty(signal)
    disp(''Error: Signal is empty after removing NaNs'');
    result = NaN;
    return;
  end

  result = mean(signal);
end

disp(''=== Test 1: Normal vector ==='');
r1 = safe_mean_signal([1 2 3 4 5]);
disp([''Test 1 result: '' num2str(r1)]);

disp(''=== Test 2: Non-numeric input ==='');
r2 = safe_mean_signal(''hello'');
disp([''Test 2 result: '' num2str(r2)]);

disp(''=== Test 3: Vector with NaNs ==='');
r3 = safe_mean_signal([1 NaN 3 NaN 5]);
disp([''Test 3 result: '' num2str(r3)]);

disp(''=== Test 4: Empty input ==='');
r4 = safe_mean_signal([]);
disp([''Test 4 result: '' num2str(r4)]);',
  '["Use isnumeric(x) to check if input is numeric, isvector(x) to check if it''s 1D.","sum(isnan(signal)) counts the NaN values. signal(~isnan(signal)) removes them.","Use ''return'' to exit the function early when validation fails."]',
  '[]',
  false);


-- ============================================
-- Lesson 23: From Simulated to Real Data
-- ============================================
INSERT INTO lessons (id, phase, order_num, title, description, difficulty, estimated_minutes, content_md)
VALUES (23, 4, 9, 'From Simulated to Real Data',
  'Learn what makes real data different from simulated data, and build a toolkit for inspecting, cleaning, and navigating messy datasets.',
  'advanced', 30,
  '# From Simulated to Real Data

Everything you have worked with so far used **simulated data** — clean, predictable signals that you generated yourself. Real neuroscience data is different.

## Simulated vs. Real: Side by Side

**Simulated sine wave:**
```matlab
t = 0:0.001:1;
clean = sin(2*pi*10*t);
```
Perfect. Exactly 10 Hz. No noise. Every time.

**Real EEG data:**
- Noisy baseline
- Artifacts from eye blinks and muscle movements
- Varies from trial to trial
- Might contain NaN values from bad channels
- Unexpected dimensions

## Common Real-Data Surprises

### 1. NaN Values
Bad channels or rejected trials often get replaced with NaN (Not a Number). Any operation involving NaN gives NaN:
```matlab
mean([1 2 NaN 4])  % Returns NaN!
nanmean([1 2 NaN 4])  % Returns 2.333 (ignores NaN)
```

### 2. Varying Lengths
Trials might have different durations. You cannot stack them into a matrix without padding or trimming.

### 3. Unexpected Dimensions
You expect a 64×1000 matrix (64 channels × 1000 timepoints) but get 1000×64. Always check with `size()`.

### 4. Missing Channels
Some channels might be missing entirely, shifting all the indices.

## The Data Inspection Checklist

Before analyzing ANY dataset, always run:
```matlab
size(data)        % How big is it?
class(data)       % What type is it?
min(data(:))      % What is the range?
max(data(:))
any(isnan(data(:)))  % Any NaN values?
any(isinf(data(:)))  % Any infinite values?
```

## Working with Structs

Real .mat files often contain **structs** — containers with named fields:
```matlab
data = load(''experiment.mat'');
fieldnames(data)           % What fields exist?
data.eeg                    % Access a field
data.params.sampling_rate   % Nested struct access
```

Use `fieldnames()` to explore, and dot notation to access.

## The Golden Rule of Real Data

**Always plot your data first.** Before any analysis, just look at it. You will catch more problems with your eyes than with any automated check.

Let''s practice working with messy data!');

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (23, 1, 'Data inspection',
  'Load a simulated ''messy'' dataset and identify all issues.

The code below creates a dataset with several problems hidden in it. Your job is to find them all.

1. Run the setup code that creates the messy data
2. Write an inspection function that checks for:
   - Size and dimensions
   - Data type (class)
   - NaN values (count them)
   - Inf values (count them)
   - Value range (min/max)
   - Outliers (values more than 5 standard deviations from the mean, after removing NaN/Inf)
3. Display a clear report for each check
4. At the end, summarize: ''Found N issues'' where N is the count of problems found (NaN count > 0 is 1 issue, Inf count > 0 is another, outlier count > 0 is another)',
  '% Data inspection exercise
% This creates a ''messy'' dataset simulating real-world problems
rand(''state'', 42);

% Simulated 8-channel, 500-timepoint EEG data
eeg = randn(8, 500) * 50;  % Normal EEG-like values

% Problem 1: Channel 3 has NaN values (bad channel)
eeg(3, 100:150) = NaN;

% Problem 2: A few Inf values (artifact)
eeg(5, 200) = Inf;
eeg(5, 201) = -Inf;

% Problem 3: Channel 7 has an extreme outlier
eeg(7, 300) = 50000;  % Way outside normal range

% Problem 4: Channel 1 has a DC offset
eeg(1, :) = eeg(1, :) + 1000;

% Now inspect this data and find all problems
disp(''=== Data Inspection Report ==='');
% YOUR CODE HERE
',
  'rand(''state'', 42);

eeg = randn(8, 500) * 50;
eeg(3, 100:150) = NaN;
eeg(5, 200) = Inf;
eeg(5, 201) = -Inf;
eeg(7, 300) = 50000;
eeg(1, :) = eeg(1, :) + 1000;

disp(''=== Data Inspection Report ==='');
issue_count = 0;

% Size and type
disp([''Size: '' num2str(size(eeg))]);
disp([''Class: '' class(eeg)]);
disp([''Channels: '' num2str(size(eeg,1)) '', Timepoints: '' num2str(size(eeg,2))]);

% NaN check
nan_count = sum(isnan(eeg(:)));
disp([''NaN values: '' num2str(nan_count)]);
if nan_count > 0
  issue_count = issue_count + 1;
  for ch = 1:size(eeg,1)
    ch_nans = sum(isnan(eeg(ch,:)));
    if ch_nans > 0
      disp([''  Channel '' num2str(ch) '': '' num2str(ch_nans) '' NaN values'']);
    end
  end
end

% Inf check
inf_count = sum(isinf(eeg(:)));
disp([''Inf values: '' num2str(inf_count)]);
if inf_count > 0
  issue_count = issue_count + 1;
  for ch = 1:size(eeg,1)
    ch_infs = sum(isinf(eeg(ch,:)));
    if ch_infs > 0
      disp([''  Channel '' num2str(ch) '': '' num2str(ch_infs) '' Inf values'']);
    end
  end
end

% Value range
clean = eeg(~isnan(eeg) & ~isinf(eeg));
disp([''Min (clean): '' num2str(min(clean))]);
disp([''Max (clean): '' num2str(max(clean))]);
disp([''Mean (clean): '' num2str(mean(clean), ''%.2f'')]);
disp([''Std (clean): '' num2str(std(clean), ''%.2f'')]);

% Outlier check (>5 std from mean)
thresh = 5 * std(clean);
mu = mean(clean);
for ch = 1:size(eeg,1)
  ch_data = eeg(ch,:);
  ch_clean = ch_data(~isnan(ch_data) & ~isinf(ch_data));
  outliers = sum(abs(ch_clean - mu) > thresh);
  if outliers > 0
    disp([''  Channel '' num2str(ch) '': '' num2str(outliers) '' outlier(s)'']);
  end
end
if any(abs(clean - mu) > thresh)
  issue_count = issue_count + 1;
end

% Channel mean check (DC offset)
disp('''');
disp(''Channel means:'');
for ch = 1:size(eeg,1)
  ch_data = eeg(ch,:);
  ch_clean = ch_data(~isnan(ch_data) & ~isinf(ch_data));
  ch_mean = mean(ch_clean);
  flag = '''';
  if abs(ch_mean) > 100
    flag = '' << DC OFFSET DETECTED'';
    issue_count = issue_count + 1;
  end
  disp([''  Channel '' num2str(ch) '': mean = '' num2str(ch_mean, ''%.1f'') flag]);
end

disp('''');
disp([''Found '' num2str(issue_count) '' issues'']);',
  '["Use isnan() and isinf() to find NaN and Inf values. sum(isnan(eeg(:))) counts total NaNs.","For outlier detection: compute mean and std of clean data, then flag anything > 5*std from the mean.","Check per-channel means to find DC offsets — a mean far from 0 indicates a problem."]',
  '[]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (23, 2, 'Data cleaning pipeline',
  'Write a function that takes messy EEG data and returns clean data.

Your clean_eeg function should:
1. Take raw EEG matrix (channels × timepoints) as input
2. Report the original size
3. Identify and reject bad channels (>20% NaN or any Inf values)
4. For remaining channels, replace isolated NaN values with interpolation (use the mean of neighbors, or just use nanmean of the channel)
5. Remove outlier timepoints (any timepoint where ANY channel exceeds 5 std)
6. Return the cleaned data and display a summary:
   - Channels removed
   - NaN values replaced
   - Timepoints removed
   - Final data size

Test with the messy data from Exercise 1.',
  '% Data cleaning pipeline
rand(''state'', 42);

% Create messy data
eeg = randn(8, 500) * 50;
eeg(3, 100:150) = NaN;
eeg(5, 200) = Inf;
eeg(5, 201) = -Inf;
eeg(7, 300) = 50000;
eeg(1, :) = eeg(1, :) + 1000;

% Define clean_eeg function
% YOUR CODE HERE

% Run the cleaning pipeline
clean = clean_eeg(eeg);
disp([''Final clean data size: '' num2str(size(clean))]);
',
  'rand(''state'', 42);

eeg = randn(8, 500) * 50;
eeg(3, 100:150) = NaN;
eeg(5, 200) = Inf;
eeg(5, 201) = -Inf;
eeg(7, 300) = 50000;
eeg(1, :) = eeg(1, :) + 1000;

function cleaned = clean_eeg(data)
  [nch, ntp] = size(data);
  disp([''Original size: '' num2str(nch) '' channels x '' num2str(ntp) '' timepoints'']);

  % Step 1: Identify bad channels
  bad_channels = [];
  for ch = 1:nch
    nan_pct = sum(isnan(data(ch,:))) / ntp;
    has_inf = any(isinf(data(ch,:)));
    if nan_pct > 0.2 || has_inf
      bad_channels(end+1) = ch;
    end
  end

  if ~isempty(bad_channels)
    disp([''Removing bad channels: '' num2str(bad_channels)]);
    data(bad_channels, :) = [];
  end

  [nch, ntp] = size(data);

  % Step 2: Replace remaining NaN values with channel mean
  nan_replaced = 0;
  for ch = 1:nch
    nan_idx = isnan(data(ch,:));
    if any(nan_idx)
      ch_mean = nanmean(data(ch,:));
      data(ch, nan_idx) = ch_mean;
      nan_replaced = nan_replaced + sum(nan_idx);
    end
  end
  disp([''NaN values replaced: '' num2str(nan_replaced)]);

  % Step 3: Remove outlier timepoints
  overall_std = std(data(:));
  overall_mean = mean(data(:));
  thresh = 5 * overall_std;
  bad_timepoints = false(1, ntp);
  for t = 1:ntp
    if any(abs(data(:,t) - overall_mean) > thresh)
      bad_timepoints(t) = true;
    end
  end
  removed_tp = sum(bad_timepoints);
  data(:, bad_timepoints) = [];
  disp([''Timepoints removed (outliers): '' num2str(removed_tp)]);

  disp([''Final size: '' num2str(size(data,1)) '' channels x '' num2str(size(data,2)) '' timepoints'']);
  cleaned = data;
end

clean = clean_eeg(eeg);
disp([''Final clean data size: '' num2str(size(clean))]);',
  '["Check each channel: if NaN% > 20% or has Inf → mark as bad. Remove all bad channels at once.","For NaN replacement: nanmean(data(ch,:)) gives the channel mean ignoring NaNs. Replace NaN positions with this value.","For outlier removal: compute global std, then check each timepoint — if ANY channel exceeds 5*std, remove that timepoint."]',
  '[]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (23, 3, 'Struct navigation',
  'Navigate a nested struct (mimicking a real .mat file) and extract specific information.

The code below creates a nested struct similar to what you would find in a real experiment file. Extract the requested information.

1. The struct is already created for you
2. Display the top-level field names
3. Navigate to experiment.params and display all parameter names and values
4. Extract the EEG data from experiment.data.eeg and display its size
5. Extract channel names from experiment.data.channel_names and display them
6. Compute the mean signal for the channel named ''Oz'' (find its index first)
7. Display:
   - ''Subject: [id]''
   - ''Sampling rate: [rate] Hz''
   - ''Channels: [count]''
   - ''Duration: [timepoints/sampling_rate] seconds''
   - ''Oz channel mean: [value]''',
  '% Struct navigation exercise
% This creates a realistic nested struct
rand(''state'', 42);

experiment = struct();
experiment.subject_id = ''S001'';
experiment.date = ''2024-03-15'';
experiment.params = struct();
experiment.params.sampling_rate = 256;
experiment.params.filter_low = 0.5;
experiment.params.filter_high = 40;
experiment.params.reference = ''average'';
experiment.data = struct();
experiment.data.eeg = randn(6, 1280) * 30;  % 6 channels, 5 seconds at 256 Hz
experiment.data.channel_names = {''Fz'', ''Cz'', ''Pz'', ''Oz'', ''F3'', ''F4''};
experiment.data.events = struct();
experiment.data.events.times = [0.5, 1.5, 2.5, 3.5];
experiment.data.events.labels = {''stim'', ''stim'', ''stim'', ''stim''};

% Navigate and extract information
% YOUR CODE HERE
',
  'rand(''state'', 42);

experiment = struct();
experiment.subject_id = ''S001'';
experiment.date = ''2024-03-15'';
experiment.params = struct();
experiment.params.sampling_rate = 256;
experiment.params.filter_low = 0.5;
experiment.params.filter_high = 40;
experiment.params.reference = ''average'';
experiment.data = struct();
experiment.data.eeg = randn(6, 1280) * 30;
experiment.data.channel_names = {''Fz'', ''Cz'', ''Pz'', ''Oz'', ''F3'', ''F4''};
experiment.data.events = struct();
experiment.data.events.times = [0.5, 1.5, 2.5, 3.5];
experiment.data.events.labels = {''stim'', ''stim'', ''stim'', ''stim''};

% Top-level fields
disp(''=== Top-level fields ==='');
disp(fieldnames(experiment));

% Parameters
disp(''=== Parameters ==='');
pnames = fieldnames(experiment.params);
for i = 1:length(pnames)
  val = experiment.params.(pnames{i});
  if isnumeric(val)
    disp([pnames{i} '': '' num2str(val)]);
  else
    disp([pnames{i} '': '' val]);
  end
end

% EEG data
eeg = experiment.data.eeg;
disp('''');
disp([''EEG size: '' num2str(size(eeg))]);

% Channel names
ch_names = experiment.data.channel_names;
disp(''Channels:'');
for i = 1:length(ch_names)
  disp([''  '' num2str(i) '': '' ch_names{i}]);
end

% Find Oz channel
oz_idx = 0;
for i = 1:length(ch_names)
  if strcmp(ch_names{i}, ''Oz'')
    oz_idx = i;
    break;
  end
end

fs = experiment.params.sampling_rate;
oz_mean = mean(eeg(oz_idx, :));

disp('''');
disp([''Subject: '' experiment.subject_id]);
disp([''Sampling rate: '' num2str(fs) '' Hz'']);
disp([''Channels: '' num2str(size(eeg, 1))]);
disp([''Duration: '' num2str(size(eeg, 2) / fs) '' seconds'']);
disp([''Oz channel mean: '' num2str(oz_mean, ''%.4f'')]);',
  '["Access nested fields with dot notation: experiment.params.sampling_rate","Channel names are in a cell array — use strcmp(ch_names{i}, ''Oz'') to find the Oz channel index.","Duration in seconds = number of timepoints / sampling rate"]',
  '[]',
  false);


-- ============================================
-- Lesson 24: Exploring Real Spike Data
-- ============================================
INSERT INTO lessons (id, phase, order_num, title, description, difficulty, estimated_minutes, content_md)
VALUES (24, 5, 1, 'Exploring Real Spike Data',
  'Load actual macaque V1 spike recordings and explore neural firing patterns in real data.',
  'advanced', 40,
  '# Exploring Real Spike Data

Welcome to **Phase 5** — you are now working with **real neuroscience data**!

Every previous lesson used simulated data. That was essential for learning, because you knew exactly what signals were in the data. But real data is messy, surprising, and far more interesting.

## The Dataset

The file `spike_data.mat` contains multi-unit spike recordings from a **Utah electrode array** implanted in macaque primary visual cortex (V1). This is the same type of data used in cutting-edge brain-computer interface research.

The dataset comes from Mike X Cohen''s *Analyzing Neural Time Series Data* course materials.

## What is a Utah Array?

A Utah array is a 10×10 grid of tiny electrodes (each ~1mm long) that gets surgically implanted on the surface of the brain. Each electrode records the electrical activity of one or a few nearby neurons.

When a neuron fires an **action potential** (or "spike"), the electrode picks up a brief voltage deflection (~1ms duration). By detecting these spikes, we can study how neurons encode information.

## Loading .mat Files

In these exercises, the datasets are pre-installed on the server at a known path. You load them like this:

```matlab
NEURO_DATA = ''/usr/share/neuroscience-data'';
data = load([NEURO_DATA ''/spike_data.mat'']);
```

The `load()` function reads the `.mat` file and returns a struct with the variables stored inside. Use `fieldnames(data)` to see what is in the struct.

## Working with Structs

Remember: when you load a .mat file, the result is a **struct**. Access fields with dot notation:

```matlab
data = load(''file.mat'');
data.fieldName    % access a field
size(data.fieldName)  % check dimensions
```

## Tips for Real Data

- Always inspect the data first (`size`, `fieldnames`, `whos`)
- Real data will not look as clean as simulated data
- Check for NaN or Inf values
- Look at the range and distribution before analysis

Let''s dive in!');

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (24, 1, 'Load and inspect spike data',
  'Load the spike dataset and explore its structure.

1. Set the data path: NEURO_DATA = ''/usr/share/neuroscience-data'';
2. Load spike_data.mat into a variable called `data`
3. Display the field names of the loaded struct using `fieldnames(data)`
4. For each field, display its name and size using a loop:
   - Format: disp([name '': '' num2str(size(value))])
5. Display the total number of fields: disp([''Total fields: '' num2str(length(fieldnames(data)))])',
  '% Load and inspect real spike data
NEURO_DATA = ''/usr/share/neuroscience-data'';

% Load the data
% YOUR CODE HERE

% Display field names
% YOUR CODE HERE

% Loop through fields and show sizes
% YOUR CODE HERE

% Display total number of fields
% YOUR CODE HERE
',
  'NEURO_DATA = ''/usr/share/neuroscience-data'';
data = load([NEURO_DATA ''/spike_data.mat'']);

fnames = fieldnames(data);
disp(''Field names:'');
disp(fnames);

for i = 1:length(fnames)
  name = fnames{i};
  value = data.(name);
  disp([name '': '' num2str(size(value))]);
end

disp([''Total fields: '' num2str(length(fnames))]);',
  '["Use load([NEURO_DATA ''/spike_data.mat'']) to load the file into a struct.","Use fieldnames(data) to get a cell array of field names.","Loop with: for i = 1:length(fnames), name = fnames{i}; value = data.(name); end"]',
  '[]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (24, 2, 'Compute firing rates across trials',
  'Analyze spike counts to compute firing rates from the real data.

After loading the data, you will find spike timing information. For this exercise, we will work with whatever spike count or timing data is available in the struct.

1. Load spike_data.mat
2. Get the field names and display them
3. Pick the first numeric matrix field (the largest one by number of elements)
4. Display its size
5. Compute the mean across the first dimension (averaging across trials/rows)
6. Display the first 10 values of the mean: disp(mean_vals(1:min(10,end)))
7. Display the overall mean: disp([''Overall mean: '' num2str(mean(mean_vals))])
8. Display the standard deviation: disp([''Std dev: '' num2str(std(mean_vals))])',
  '% Compute firing rates from real spike data
NEURO_DATA = ''/usr/share/neuroscience-data'';
data = load([NEURO_DATA ''/spike_data.mat'']);

% Get field names
fnames = fieldnames(data);
disp(''Available fields:'');
disp(fnames);

% Find the largest numeric field
% YOUR CODE HERE

% Compute mean across first dimension
% YOUR CODE HERE

% Display first 10 mean values
% YOUR CODE HERE

% Display overall statistics
% YOUR CODE HERE
',
  'NEURO_DATA = ''/usr/share/neuroscience-data'';
data = load([NEURO_DATA ''/spike_data.mat'']);

fnames = fieldnames(data);
disp(''Available fields:'');
disp(fnames);

max_numel = 0;
largest_field = '''';
for i = 1:length(fnames)
  val = data.(fnames{i});
  if isnumeric(val) && numel(val) > max_numel
    max_numel = numel(val);
    largest_field = fnames{i};
  end
end

disp([''Largest field: '' largest_field]);
spike_matrix = data.(largest_field);
disp([''Size: '' num2str(size(spike_matrix))]);

mean_vals = mean(spike_matrix, 1);
disp(''First 10 mean values:'');
disp(mean_vals(1:min(10,end)));

disp([''Overall mean: '' num2str(mean(mean_vals))]);
disp([''Std dev: '' num2str(std(mean_vals))]);',
  '["Loop through fields with isnumeric() and numel() to find the largest matrix.","Use data.(fieldname) with dynamic field names to access struct fields.","mean(matrix, 1) computes the mean along rows (across trials)."]',
  '[]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (24, 3, 'Plot a neural tuning curve',
  'Create a visualization of the spike data — a tuning curve or firing rate profile.

1. Load spike_data.mat
2. Find the largest numeric matrix in the struct (same approach as Exercise 2)
3. Compute the mean across the first dimension
4. Compute the standard error of the mean: SEM = std(matrix, 0, 1) / sqrt(size(matrix, 1))
5. Create a figure with 2 subplots (2 rows, 1 column):
   - Top: Plot the mean firing rate profile. Title: ''Mean Neural Response Profile''. xlabel: ''Time/Condition Index''. ylabel: ''Mean Response''.
   - Bottom: Plot the mean with error bars using errorbar(). Title: ''Response with SEM Error Bars''. Same axis labels.
6. Main title: ''Real Spike Data Analysis''',
  '% Plot neural tuning curve from real data
NEURO_DATA = ''/usr/share/neuroscience-data'';
data = load([NEURO_DATA ''/spike_data.mat'']);

% Find largest numeric field
fnames = fieldnames(data);
max_numel = 0;
largest_field = '''';
for i = 1:length(fnames)
  val = data.(fnames{i});
  if isnumeric(val) && numel(val) > max_numel
    max_numel = numel(val);
    largest_field = fnames{i};
  end
end

spike_matrix = data.(largest_field);

% Compute mean and SEM
% YOUR CODE HERE

% Create figure
figure;
% YOUR CODE HERE
',
  'NEURO_DATA = ''/usr/share/neuroscience-data'';
data = load([NEURO_DATA ''/spike_data.mat'']);

fnames = fieldnames(data);
max_numel = 0;
largest_field = '''';
for i = 1:length(fnames)
  val = data.(fnames{i});
  if isnumeric(val) && numel(val) > max_numel
    max_numel = numel(val);
    largest_field = fnames{i};
  end
end

spike_matrix = data.(largest_field);

mean_vals = mean(spike_matrix, 1);
sem_vals = std(spike_matrix, 0, 1) / sqrt(size(spike_matrix, 1));
x = 1:length(mean_vals);

figure;

subplot(2,1,1);
plot(x, mean_vals, ''b-'', ''LineWidth'', 1.5);
xlabel(''Time/Condition Index'');
ylabel(''Mean Response'');
title(''Mean Neural Response Profile'');

subplot(2,1,2);
errorbar(x, mean_vals, sem_vals, ''r-'', ''LineWidth'', 1);
xlabel(''Time/Condition Index'');
ylabel(''Mean Response'');
title(''Response with SEM Error Bars'');

sgtitle(''Real Spike Data Analysis'');',
  '["SEM = std(matrix, 0, 1) / sqrt(size(matrix, 1)) — the 0 means default normalization (N-1).","errorbar(x, y, err) plots y vs x with vertical error bars of size err.","Use sgtitle(''...'') for the overall figure title."]',
  '[]',
  true);


-- ============================================
-- Lesson 25: Real EEG: Steady-State Visual Evoked Potentials
-- ============================================
INSERT INTO lessons (id, phase, order_num, title, description, difficulty, estimated_minutes, content_md)
VALUES (25, 5, 2, 'Real EEG: Steady-State Visual Evoked Potentials',
  'Load real human SSVEP EEG data, compute power spectra, and identify frequency-tagged brain responses.',
  'advanced', 45,
  '# Real EEG: Steady-State Visual Evoked Potentials

In this lesson you will work with **real human EEG data** — specifically, steady-state visual evoked potential (SSVEP) recordings.

## What are SSVEPs?

When you look at a light flickering at a constant frequency (say 15 Hz), your visual cortex generates a brain response **at that exact frequency**. This is an SSVEP.

SSVEPs are remarkably robust and are used in:
- **Brain-computer interfaces (BCIs):** different buttons flicker at different frequencies; the BCI detects which one you are looking at
- **Attention research:** the SSVEP gets stronger when you pay attention to the flickering stimulus
- **Clinical neuroscience:** testing visual pathway integrity

## The Dataset

The file `ssvep_data.mat` contains a real SSVEP recording. The data typically includes:
- Multi-channel EEG time series
- Sampling rate information
- Possibly trial/condition markers

This data comes from Mike X Cohen''s course materials.

## The Analysis Plan

1. Load and inspect the data structure
2. Examine the raw EEG time series
3. Compute the power spectrum using FFT
4. Identify the SSVEP peak — a sharp spike at the stimulation frequency

## Why SSVEPs are Great for Learning

SSVEP data gives you a **clear, unambiguous signal** to find. Unlike many brain signals that are subtle and require statistical techniques to detect, an SSVEP peak jumps right out of the power spectrum. This makes it perfect for practicing spectral analysis on real data.

Let''s find some brain responses!');

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (25, 1, 'Load and inspect SSVEP EEG data',
  'Load the SSVEP EEG dataset and explore its structure.

1. Set the data path and load ssvep_data.mat
2. Display all field names
3. For each field, display: name, class (using class()), and size
4. Look for a field that could be the sampling rate (usually a scalar) and display it
5. Look for the main EEG data matrix (usually the largest 2D matrix) and display its size
6. Display: ''Channels: X, Timepoints: Y'' based on the data matrix dimensions (assume channels are rows if the matrix has fewer rows than columns, otherwise columns)',
  '% Load and inspect real SSVEP EEG data
NEURO_DATA = ''/usr/share/neuroscience-data'';
data = load([NEURO_DATA ''/ssvep_data.mat'']);

% Display all fields with their class and size
fnames = fieldnames(data);
% YOUR CODE HERE

% Find sampling rate (scalar numeric field)
% YOUR CODE HERE

% Find main EEG data matrix
% YOUR CODE HERE
',
  'NEURO_DATA = ''/usr/share/neuroscience-data'';
data = load([NEURO_DATA ''/ssvep_data.mat'']);

fnames = fieldnames(data);
disp(''=== Data Structure ==='');
for i = 1:length(fnames)
  name = fnames{i};
  val = data.(name);
  disp([name '' | class: '' class(val) '' | size: '' num2str(size(val))]);
end

disp('''');
disp(''=== Looking for sampling rate ==='');
for i = 1:length(fnames)
  val = data.(fnames{i});
  if isnumeric(val) && isscalar(val)
    disp([fnames{i} '' = '' num2str(val) '' (scalar — possible sampling rate)'']);
  end
end

disp('''');
disp(''=== Looking for EEG data matrix ==='');
max_numel = 0;
eeg_field = '''';
for i = 1:length(fnames)
  val = data.(fnames{i});
  if isnumeric(val) && ndims(val) == 2 && numel(val) > max_numel
    max_numel = numel(val);
    eeg_field = fnames{i};
  end
end

if ~isempty(eeg_field)
  eeg = data.(eeg_field);
  disp([''EEG field: '' eeg_field '' | size: '' num2str(size(eeg))]);
  [r, c] = size(eeg);
  if r < c
    disp([''Channels: '' num2str(r) '', Timepoints: '' num2str(c)]);
  else
    disp([''Channels: '' num2str(c) '', Timepoints: '' num2str(r)]);
  end
end',
  '["Use class(val) to get the data type of each field (double, char, struct, etc.).","A scalar numeric field (numel == 1) is likely the sampling rate.","The EEG data is usually the largest 2D numeric matrix in the file."]',
  '[]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (25, 2, 'Compute the power spectrum of real EEG',
  'Compute the power spectrum of the SSVEP EEG data to find frequency-tagged brain responses.

1. Load ssvep_data.mat
2. Find the main EEG matrix (largest 2D numeric field) and the sampling rate (scalar numeric field). If no scalar is found, assume fs = 1000.
3. Extract the first channel (first row if channels are rows, first column otherwise)
4. Compute the FFT and power spectrum: power = abs(fft_result(1:N/2+1)).^2 / N
5. Create frequency axis: freqs = (0:N/2) * fs / N
6. Plot the power spectrum from 1 to 80 Hz
   - Title: ''Power Spectrum - SSVEP EEG (Channel 1)''
   - xlabel: ''Frequency (Hz)'', ylabel: ''Power''
7. Find the peak frequency between 5 and 50 Hz and display it:
   disp([''Peak frequency: '' num2str(peak_freq) '' Hz''])',
  '% Power spectrum of real SSVEP EEG
NEURO_DATA = ''/usr/share/neuroscience-data'';
data = load([NEURO_DATA ''/ssvep_data.mat'']);

% Find EEG matrix and sampling rate
fnames = fieldnames(data);
% YOUR CODE HERE

% Extract first channel
% YOUR CODE HERE

% Compute FFT and power spectrum
% YOUR CODE HERE

% Plot 1-80 Hz
figure;
% YOUR CODE HERE

% Find and display peak frequency
% YOUR CODE HERE
',
  'NEURO_DATA = ''/usr/share/neuroscience-data'';
data = load([NEURO_DATA ''/ssvep_data.mat'']);

fnames = fieldnames(data);

fs = 1000;
for i = 1:length(fnames)
  val = data.(fnames{i});
  if isnumeric(val) && isscalar(val) && val > 0
    fs = val;
    break;
  end
end
disp([''Sampling rate: '' num2str(fs) '' Hz'']);

max_numel = 0;
eeg_field = '''';
for i = 1:length(fnames)
  val = data.(fnames{i});
  if isnumeric(val) && ndims(val) == 2 && numel(val) > max_numel
    max_numel = numel(val);
    eeg_field = fnames{i};
  end
end

eeg = data.(eeg_field);
[r, c] = size(eeg);
if r < c
  channel1 = eeg(1, :);
else
  channel1 = eeg(:, 1)'';
end

N = length(channel1);
fft_result = fft(channel1);
power = abs(fft_result(1:N/2+1)).^2 / N;
freqs = (0:N/2) * fs / N;

plot_idx = freqs >= 1 & freqs <= 80;

figure;
plot(freqs(plot_idx), power(plot_idx), ''b-'', ''LineWidth'', 1.2);
xlabel(''Frequency (Hz)'');
ylabel(''Power'');
title(''Power Spectrum - SSVEP EEG (Channel 1)'');

search_idx = freqs >= 5 & freqs <= 50;
search_power = power;
search_power(~search_idx) = 0;
[~, peak_bin] = max(search_power);
peak_freq = freqs(peak_bin);
disp([''Peak frequency: '' num2str(peak_freq) '' Hz'']);',
  '["To find the sampling rate, loop through fields and check: isnumeric(val) && isscalar(val).","If channels are rows (fewer rows than columns), first channel = eeg(1,:).","For peak finding: zero out the power outside 5-50 Hz, then use max() to find the peak."]',
  '[]',
  true);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (25, 3, 'Compare power spectra across channels',
  'Compare the power spectra across multiple EEG channels to see how the SSVEP response varies across the scalp.

1. Load ssvep_data.mat, find the EEG matrix and sampling rate (default 1000 Hz)
2. Determine the number of channels (min dimension of the EEG matrix). Use at most 6 channels: num_ch = min(num_channels, 6)
3. For each channel, compute the power spectrum
4. Create a figure with num_ch subplots (arranged as num_ch x 1):
   - Each subplot: plot power spectrum from 1-60 Hz
   - Title each: [''Channel '' num2str(ch)]
   - ylabel: ''Power''
   - Only add xlabel ''Frequency (Hz)'' to the bottom subplot
5. Main title: ''SSVEP Power Spectra Across Channels''
6. After plotting, find the peak frequency (5-50 Hz) for each channel and display:
   disp([''Channel '' num2str(ch) '' peak: '' num2str(peak_freq) '' Hz''])',
  '% Compare SSVEP power across channels
NEURO_DATA = ''/usr/share/neuroscience-data'';
data = load([NEURO_DATA ''/ssvep_data.mat'']);

% Find EEG matrix and sampling rate
fnames = fieldnames(data);
fs = 1000;
for i = 1:length(fnames)
  val = data.(fnames{i});
  if isnumeric(val) && isscalar(val) && val > 0
    fs = val; break;
  end
end

max_numel = 0; eeg_field = '''';
for i = 1:length(fnames)
  val = data.(fnames{i});
  if isnumeric(val) && ndims(val) == 2 && numel(val) > max_numel
    max_numel = numel(val); eeg_field = fnames{i};
  end
end
eeg = data.(eeg_field);

% Determine channels
[r, c] = size(eeg);
if r < c
  num_channels = r;
else
  num_channels = c;
  eeg = eeg'';  % transpose so channels are rows
end
num_ch = min(num_channels, 6);

% Compute and plot power spectra
figure;
% YOUR CODE HERE

% Display peak frequencies
% YOUR CODE HERE
',
  'NEURO_DATA = ''/usr/share/neuroscience-data'';
data = load([NEURO_DATA ''/ssvep_data.mat'']);

fnames = fieldnames(data);
fs = 1000;
for i = 1:length(fnames)
  val = data.(fnames{i});
  if isnumeric(val) && isscalar(val) && val > 0
    fs = val; break;
  end
end

max_numel = 0; eeg_field = '''';
for i = 1:length(fnames)
  val = data.(fnames{i});
  if isnumeric(val) && ndims(val) == 2 && numel(val) > max_numel
    max_numel = numel(val); eeg_field = fnames{i};
  end
end
eeg = data.(eeg_field);

[r, c] = size(eeg);
if r < c
  num_channels = r;
else
  num_channels = c;
  eeg = eeg'';
end
num_ch = min(num_channels, 6);

N = size(eeg, 2);
freqs = (0:N/2) * fs / N;
plot_idx = freqs >= 1 & freqs <= 60;
search_idx = freqs >= 5 & freqs <= 50;

figure;
for ch = 1:num_ch
  fft_result = fft(eeg(ch, :));
  power = abs(fft_result(1:N/2+1)).^2 / N;

  subplot(num_ch, 1, ch);
  plot(freqs(plot_idx), power(plot_idx), ''LineWidth'', 1);
  ylabel(''Power'');
  title([''Channel '' num2str(ch)]);
  if ch == num_ch
    xlabel(''Frequency (Hz)'');
  end
end
sgtitle(''SSVEP Power Spectra Across Channels'');

disp(''=== Peak Frequencies ==='');
for ch = 1:num_ch
  fft_result = fft(eeg(ch, :));
  power = abs(fft_result(1:N/2+1)).^2 / N;
  search_power = power;
  search_power(~search_idx) = 0;
  [~, peak_bin] = max(search_power);
  disp([''Channel '' num2str(ch) '' peak: '' num2str(freqs(peak_bin)) '' Hz'']);
end',
  '["Loop from ch = 1:num_ch. For each channel: fft_result = fft(eeg(ch,:)); power = abs(fft_result(1:N/2+1)).^2 / N;","Use subplot(num_ch, 1, ch) to stack plots vertically.","For peak finding per channel, recompute the power and mask outside 5-50 Hz."]',
  '[]',
  true);


-- ============================================
-- Lesson 26: Working with fMRI Data
-- ============================================
INSERT INTO lessons (id, phase, order_num, title, description, difficulty, estimated_minutes, content_md)
VALUES (26, 5, 3, 'Working with fMRI Data',
  'Load real fMRI brain volumes, extract ROI time series, and correlate brain activity with a task design.',
  'advanced', 45,
  '# Working with fMRI Data

Functional MRI (fMRI) measures brain activity by detecting changes in **blood oxygenation**. When neurons in a brain region become active, blood flow to that region increases — this is called the **BOLD response** (Blood Oxygen Level Dependent).

## How fMRI Differs from EEG

| | EEG | fMRI |
|---|---|---|
| **Measures** | Electrical activity | Blood oxygenation |
| **Time resolution** | ~1 ms | ~1-2 seconds |
| **Spatial resolution** | ~1 cm | ~1-3 mm |
| **Data format** | Channels × Time | 3D volumes over time |

fMRI gives you a **3D picture of the brain** at each time point. A typical fMRI experiment collects one 3D volume every 1-2 seconds for several minutes.

## The Dataset

The file `fmri_data.mat` contains task-based fMRI data. This could include:
- A 4D matrix: X × Y × Z × Time (voxels across time)
- Or a 2D matrix: Voxels × Time (already reshaped)
- Task timing information
- Possibly a design matrix

## Region of Interest (ROI) Analysis

Rather than analyzing every voxel in the brain (~100,000+ voxels), we often focus on a **Region of Interest** — a predefined brain area. We extract the average time series from that region and analyze it.

## Percent Signal Change

fMRI BOLD signals are measured in arbitrary units. To make results meaningful, we compute **percent signal change** relative to baseline:

```matlab
psc = (signal - baseline) / baseline * 100;
```

A typical BOLD response is 1-5% signal change — tiny but reliable.

Let''s explore some real brain imaging data!');

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (26, 1, 'Load and inspect fMRI data',
  'Load the fMRI dataset and explore its structure.

1. Load fmri_data.mat
2. Display all field names with class and size (same pattern as previous lessons)
3. Find the largest numeric field — this is likely the fMRI data
4. Display its dimensions and the total number of elements
5. If the data has more than 2 dimensions, display: ''This is a 4D volume: X x Y x Z x Time''
   If it has 2 dimensions, display: ''This is a 2D matrix: Voxels x Time'' (or Time x Voxels based on which is larger)
6. Display the min, max, and mean of the entire dataset:
   disp([''Min: '' num2str(min(data_matrix(:)))])
   disp([''Max: '' num2str(max(data_matrix(:)))])
   disp([''Mean: '' num2str(mean(data_matrix(:)))])',
  '% Load and inspect real fMRI data
NEURO_DATA = ''/usr/share/neuroscience-data'';
data = load([NEURO_DATA ''/fmri_data.mat'']);

% Display structure
fnames = fieldnames(data);
% YOUR CODE HERE

% Find main data matrix
% YOUR CODE HERE

% Display dimensionality
% YOUR CODE HERE

% Display value range
% YOUR CODE HERE
',
  'NEURO_DATA = ''/usr/share/neuroscience-data'';
data = load([NEURO_DATA ''/fmri_data.mat'']);

fnames = fieldnames(data);
disp(''=== fMRI Data Structure ==='');
for i = 1:length(fnames)
  name = fnames{i};
  val = data.(name);
  disp([name '' | class: '' class(val) '' | size: '' num2str(size(val))]);
end

max_numel = 0;
fmri_field = '''';
for i = 1:length(fnames)
  val = data.(fnames{i});
  if isnumeric(val) && numel(val) > max_numel
    max_numel = numel(val);
    fmri_field = fnames{i};
  end
end

fmri_matrix = data.(fmri_field);
disp('''');
disp([''Main data field: '' fmri_field]);
disp([''Dimensions: '' num2str(size(fmri_matrix))]);
disp([''Total elements: '' num2str(numel(fmri_matrix))]);

nd = ndims(fmri_matrix);
if nd > 2
  disp([''This is a '' num2str(nd) ''D volume: '' num2str(size(fmri_matrix))]);
else
  [r, c] = size(fmri_matrix);
  if r > c
    disp([''This is a 2D matrix: '' num2str(r) '' Voxels x '' num2str(c) '' Time'']);
  else
    disp([''This is a 2D matrix: '' num2str(r) '' Time x '' num2str(c) '' Voxels'']);
  end
end

disp('''');
disp([''Min: '' num2str(min(fmri_matrix(:)))]);
disp([''Max: '' num2str(max(fmri_matrix(:)))]);
disp([''Mean: '' num2str(mean(fmri_matrix(:)))]);',
  '["Use ndims() to check how many dimensions the data has.","fmri_matrix(:) reshapes any matrix into a column vector — useful for global min/max/mean.","A 4D fMRI volume is typically X×Y×Z×Time where the last dimension is time."]',
  '[]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (26, 2, 'Extract and plot an ROI time series',
  'Extract a time series from the fMRI data and visualize it.

1. Load fmri_data.mat and find the main numeric field
2. Extract a time series:
   - If data is 4D (X×Y×Z×T): pick the center voxel (round(size/2) for first 3 dims) and extract across time. Also compute mean across a 3×3×3 cube around center.
   - If data is 2D: extract the first row (or column, whichever is the time dimension — the shorter dimension is typically time)
3. If the time series has more than 500 points, only use the first 500
4. Compute percent signal change: psc = (ts - mean(ts)) / mean(ts) * 100
5. Create a figure with 2 subplots:
   - Top: raw time series. Title: ''Raw fMRI Time Series''. ylabel: ''Signal (a.u.)''
   - Bottom: percent signal change. Title: ''Percent Signal Change''. ylabel: ''% Change''
   - Both: xlabel: ''Time Point''
6. Main title: ''fMRI ROI Time Series''',
  '% Extract ROI time series from fMRI data
NEURO_DATA = ''/usr/share/neuroscience-data'';
data = load([NEURO_DATA ''/fmri_data.mat'']);

% Find main data field
fnames = fieldnames(data);
max_numel = 0; fmri_field = '''';
for i = 1:length(fnames)
  val = data.(fnames{i});
  if isnumeric(val) && numel(val) > max_numel
    max_numel = numel(val); fmri_field = fnames{i};
  end
end
fmri = data.(fmri_field);

% Extract time series based on dimensionality
% YOUR CODE HERE

% Truncate if needed
% YOUR CODE HERE

% Compute percent signal change
% YOUR CODE HERE

% Plot
figure;
% YOUR CODE HERE
',
  'NEURO_DATA = ''/usr/share/neuroscience-data'';
data = load([NEURO_DATA ''/fmri_data.mat'']);

fnames = fieldnames(data);
max_numel = 0; fmri_field = '''';
for i = 1:length(fnames)
  val = data.(fnames{i});
  if isnumeric(val) && numel(val) > max_numel
    max_numel = numel(val); fmri_field = fnames{i};
  end
end
fmri = data.(fmri_field);

nd = ndims(fmri);
if nd > 2
  cx = round(size(fmri,1)/2);
  cy = round(size(fmri,2)/2);
  cz = round(size(fmri,3)/2);
  ts = squeeze(fmri(cx, cy, cz, :))'';
  disp([''Extracted from center voxel: ['' num2str(cx) '','' num2str(cy) '','' num2str(cz) '']'']);
else
  [r, c] = size(fmri);
  if r < c
    ts = fmri(1, :);
  else
    ts = fmri(:, 1)'';
  end
  disp([''Extracted first row/column, length: '' num2str(length(ts))]);
end

if length(ts) > 500
  ts = ts(1:500);
end

ts_mean = mean(ts);
psc = (ts - ts_mean) / ts_mean * 100;

figure;

subplot(2,1,1);
plot(ts, ''b-'', ''LineWidth'', 1);
xlabel(''Time Point'');
ylabel(''Signal (a.u.)'');
title(''Raw fMRI Time Series'');

subplot(2,1,2);
plot(psc, ''r-'', ''LineWidth'', 1);
hold on;
plot([1 length(psc)], [0 0], ''k--'');
hold off;
xlabel(''Time Point'');
ylabel(''% Change'');
title(''Percent Signal Change'');

sgtitle(''fMRI ROI Time Series'');',
  '["For 4D data: squeeze(fmri(cx,cy,cz,:)) extracts the time series at a single voxel. squeeze removes singleton dimensions.","Percent signal change: psc = (ts - mean(ts)) / mean(ts) * 100","Add a horizontal dashed line at 0 to the PSC plot: plot([1 length(psc)], [0 0], ''k--'')"]',
  '[]',
  true);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (26, 3, 'Correlate fMRI signal with task design',
  'Create a simple block-design task regressor and correlate it with the fMRI time series.

1. Load fmri_data.mat, extract a time series (same approach as Exercise 2, use first 200 points or less)
2. Create a block-design regressor: alternating blocks of 20 time points ON (1) and 20 OFF (0) for the full length of the time series. Use repmat or a loop.
3. Compute the correlation between the time series (percent signal change) and the task regressor using corrcoef()
4. Create a figure with 3 subplots (3×1):
   - Top: the task regressor (step function). Title: ''Task Design (Block Design)''. ylabel: ''Task ON/OFF''
   - Middle: percent signal change of the time series. Title: ''fMRI Percent Signal Change''. ylabel: ''% Change''
   - Bottom: overlay both (normalized to same scale). Title: [''Correlation: r = '' num2str(r, ''%.3f'')]. ylabel: ''Normalized''
5. Main title: ''fMRI Task Correlation Analysis''
6. Display: disp([''Correlation with task: r = '' num2str(r, ''%.3f'')])',
  '% Correlate fMRI signal with task design
NEURO_DATA = ''/usr/share/neuroscience-data'';
data = load([NEURO_DATA ''/fmri_data.mat'']);

% Extract time series (reuse approach from Ex 2)
fnames = fieldnames(data);
max_numel = 0; fmri_field = '''';
for i = 1:length(fnames)
  val = data.(fnames{i});
  if isnumeric(val) && numel(val) > max_numel
    max_numel = numel(val); fmri_field = fnames{i};
  end
end
fmri = data.(fmri_field);

% Extract time series
% YOUR CODE HERE

% Limit to 200 points
% YOUR CODE HERE

% Compute percent signal change
% YOUR CODE HERE

% Create block-design regressor
% YOUR CODE HERE

% Compute correlation
% YOUR CODE HERE

% Plot
figure;
% YOUR CODE HERE
',
  'NEURO_DATA = ''/usr/share/neuroscience-data'';
data = load([NEURO_DATA ''/fmri_data.mat'']);

fnames = fieldnames(data);
max_numel = 0; fmri_field = '''';
for i = 1:length(fnames)
  val = data.(fnames{i});
  if isnumeric(val) && numel(val) > max_numel
    max_numel = numel(val); fmri_field = fnames{i};
  end
end
fmri = data.(fmri_field);

nd = ndims(fmri);
if nd > 2
  cx = round(size(fmri,1)/2);
  cy = round(size(fmri,2)/2);
  cz = round(size(fmri,3)/2);
  ts = squeeze(fmri(cx, cy, cz, :))'';
else
  [r, c] = size(fmri);
  if r < c
    ts = fmri(1, :);
  else
    ts = fmri(:, 1)'';
  end
end

if length(ts) > 200
  ts = ts(1:200);
end
N = length(ts);

psc = (ts - mean(ts)) / mean(ts) * 100;

block_length = 20;
one_cycle = [ones(1, block_length), zeros(1, block_length)];
num_cycles = ceil(N / (2 * block_length));
task = repmat(one_cycle, 1, num_cycles);
task = task(1:N);

R = corrcoef(psc, task);
r = R(1, 2);
disp([''Correlation with task: r = '' num2str(r, ''%.3f'')]);

figure;

subplot(3,1,1);
plot(task, ''k-'', ''LineWidth'', 1.5);
ylim([-0.2 1.3]);
xlabel(''Time Point'');
ylabel(''Task ON/OFF'');
title(''Task Design (Block Design)'');

subplot(3,1,2);
plot(psc, ''b-'', ''LineWidth'', 1);
xlabel(''Time Point'');
ylabel(''% Change'');
title(''fMRI Percent Signal Change'');

subplot(3,1,3);
psc_norm = (psc - min(psc)) / (max(psc) - min(psc));
plot(psc_norm, ''b-'', ''LineWidth'', 1);
hold on;
plot(task, ''r-'', ''LineWidth'', 1.5);
hold off;
legend(''fMRI (normalized)'', ''Task'');
xlabel(''Time Point'');
ylabel(''Normalized'');
title([''Correlation: r = '' num2str(r, ''%.3f'')]);

sgtitle(''fMRI Task Correlation Analysis'');',
  '["Create one cycle: one_cycle = [ones(1,20), zeros(1,20)]; then repmat and truncate to the right length.","corrcoef(x, y) returns a 2×2 matrix; the correlation is at position (1,2) or (2,1).","Normalize for overlay: psc_norm = (psc - min(psc)) / (max(psc) - min(psc))"]',
  '[]',
  true);


-- ============================================
-- Lesson 27: Calcium Imaging: Watching Neurons Fire
-- ============================================
INSERT INTO lessons (id, phase, order_num, title, description, difficulty, estimated_minutes, content_md)
VALUES (27, 5, 4, 'Calcium Imaging: Watching Neurons Fire',
  'Load real two-photon calcium imaging data, extract fluorescence traces, and detect neural activity events.',
  'advanced', 45,
  '# Calcium Imaging: Watching Neurons Fire

Calcium imaging is one of the most exciting techniques in modern neuroscience. It lets you literally **watch hundreds of neurons fire in real time** under a microscope.

## How Calcium Imaging Works

1. Neurons are loaded with a **calcium indicator** — a molecule that fluoresces (glows) when calcium is present
2. When a neuron fires an action potential, calcium floods into the cell
3. A **two-photon microscope** captures images of the glowing neurons at ~30 frames/second
4. Brighter = more calcium = more neural activity

## Why It Matters

Calcium imaging can record from **hundreds to thousands of neurons simultaneously** with single-cell resolution. Compare this to:
- EEG: millions of neurons, no single-cell resolution
- Single electrodes: one neuron at a time
- Utah arrays: ~100 neurons

## The Dataset

The file `calcium_data.mat` contains calcium imaging data. This typically includes:
- Fluorescence traces: intensity over time for each identified neuron (ROI)
- Possibly the raw imaging frames
- Frame rate information

## Key Concepts

### dF/F (Delta F over F)
Raw fluorescence values are not directly comparable between neurons (some are brighter than others). We normalize using **dF/F**:

```matlab
F0 = mean(F);          % baseline fluorescence
dF_F = (F - F0) / F0;  % normalized change
```

A dF/F of 0.5 means the fluorescence increased by 50% above baseline.

### Calcium Transients
When a neuron fires, the calcium signal rises sharply and decays slowly (over ~0.5-2 seconds). These events are called **calcium transients**. We can detect them by thresholding the dF/F signal.

Let''s analyze some real calcium data!');

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (27, 1, 'Load and inspect calcium imaging data',
  'Load the calcium imaging dataset and explore its contents.

1. Load calcium_data.mat
2. Display all field names with their class and size
3. Find all numeric fields and sort them by number of elements (largest first)
4. For the top 3 largest numeric fields, display:
   - Field name, size, min, max, and mean
5. Try to identify which field is likely the fluorescence trace data:
   - It should be 2D (neurons × time or time × neurons)
   - Display: ''Likely fluorescence data: [field] with [N] neurons and [T] timepoints''',
  '% Load and inspect calcium imaging data
NEURO_DATA = ''/usr/share/neuroscience-data'';
data = load([NEURO_DATA ''/calcium_data.mat'']);

% Display all fields
fnames = fieldnames(data);
% YOUR CODE HERE

% Find and rank numeric fields by size
% YOUR CODE HERE

% Identify fluorescence data
% YOUR CODE HERE
',
  'NEURO_DATA = ''/usr/share/neuroscience-data'';
data = load([NEURO_DATA ''/calcium_data.mat'']);

fnames = fieldnames(data);
disp(''=== Calcium Imaging Data Structure ==='');
for i = 1:length(fnames)
  name = fnames{i};
  val = data.(name);
  disp([name '' | class: '' class(val) '' | size: '' num2str(size(val))]);
end

disp('''');
disp(''=== Numeric Fields (sorted by size) ==='');
num_fields = {};
num_sizes = [];
for i = 1:length(fnames)
  val = data.(fnames{i});
  if isnumeric(val)
    num_fields{end+1} = fnames{i};
    num_sizes(end+1) = numel(val);
  end
end

[~, sort_idx] = sort(num_sizes, ''descend'');
for j = 1:min(3, length(sort_idx))
  idx = sort_idx(j);
  name = num_fields{idx};
  val = data.(name);
  disp([name '' | size: '' num2str(size(val)) ...
    '' | min: '' num2str(min(val(:))) ...
    '' | max: '' num2str(max(val(:))) ...
    '' | mean: '' num2str(mean(val(:)))]);
end

disp('''');
disp(''=== Identifying Fluorescence Data ==='');
for j = 1:length(sort_idx)
  idx = sort_idx(j);
  name = num_fields{idx};
  val = data.(name);
  if ndims(val) == 2 && min(size(val)) > 1
    [r, c] = size(val);
    if r < c
      disp([''Likely fluorescence data: '' name '' with '' num2str(r) '' neurons and '' num2str(c) '' timepoints'']);
    else
      disp([''Likely fluorescence data: '' name '' with '' num2str(c) '' neurons and '' num2str(r) '' timepoints'']);
    end
    break;
  end
end',
  '["Store field names and their numel() values, then sort with [~, idx] = sort(sizes, ''descend'').","The fluorescence data is usually a 2D matrix where one dimension is neurons and the other is time.","If rows < columns, rows are likely neurons; if columns < rows, columns are likely neurons."]',
  '[]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (27, 2, 'Compute dF/F and visualize traces',
  'Extract fluorescence traces and compute the normalized dF/F signal.

1. Load calcium_data.mat
2. Find the main fluorescence matrix (largest 2D numeric field)
3. Orient it so neurons are rows and time is columns
4. Select the first 5 neurons (or fewer if less available): num_neurons = min(5, size(traces,1))
5. For each neuron, compute dF/F:
   - F0 = mean of the trace (baseline)
   - dF_F = (F - F0) / F0
6. Create a figure with 2 subplots (stacked):
   - Top: plot raw fluorescence traces for the selected neurons (offset vertically for visibility). Title: ''Raw Fluorescence Traces''. ylabel: ''Fluorescence (offset)''
   - Bottom: plot dF/F traces (also offset). Title: ''Normalized dF/F Traces''. ylabel: ''dF/F (offset)''
   - Both: xlabel: ''Frame Number''
7. Add a legend showing neuron numbers
8. Main title: ''Calcium Imaging: Fluorescence Traces''',
  '% Compute dF/F from calcium imaging data
NEURO_DATA = ''/usr/share/neuroscience-data'';
data = load([NEURO_DATA ''/calcium_data.mat'']);

% Find fluorescence matrix
fnames = fieldnames(data);
max_numel = 0; ca_field = '''';
for i = 1:length(fnames)
  val = data.(fnames{i});
  if isnumeric(val) && ndims(val) == 2 && min(size(val)) > 1 && numel(val) > max_numel
    max_numel = numel(val); ca_field = fnames{i};
  end
end

traces = data.(ca_field);
[r, c] = size(traces);
if r > c
  traces = traces'';  % ensure neurons are rows
end

num_neurons = min(5, size(traces, 1));
disp([''Analyzing '' num2str(num_neurons) '' neurons, '' num2str(size(traces,2)) '' timepoints'']);

% Compute dF/F for selected neurons
% YOUR CODE HERE

% Plot
figure;
% YOUR CODE HERE
',
  'NEURO_DATA = ''/usr/share/neuroscience-data'';
data = load([NEURO_DATA ''/calcium_data.mat'']);

fnames = fieldnames(data);
max_numel = 0; ca_field = '''';
for i = 1:length(fnames)
  val = data.(fnames{i});
  if isnumeric(val) && ndims(val) == 2 && min(size(val)) > 1 && numel(val) > max_numel
    max_numel = numel(val); ca_field = fnames{i};
  end
end

traces = data.(ca_field);
[r, c] = size(traces);
if r > c
  traces = traces'';
end

num_neurons = min(5, size(traces, 1));
num_frames = size(traces, 2);
disp([''Analyzing '' num2str(num_neurons) '' neurons, '' num2str(num_frames) '' timepoints'']);

dff = zeros(num_neurons, num_frames);
for n = 1:num_neurons
  F = traces(n, :);
  F0 = mean(F);
  dff(n, :) = (F - F0) / F0;
end

figure;

subplot(2,1,1);
hold on;
leg_labels = {};
for n = 1:num_neurons
  offset = (n-1) * (max(traces(n,:)) - min(traces(n,:))) * 1.2;
  plot(traces(n,:) + offset, ''LineWidth'', 0.8);
  leg_labels{n} = [''Neuron '' num2str(n)];
end
hold off;
xlabel(''Frame Number'');
ylabel(''Fluorescence (offset)'');
title(''Raw Fluorescence Traces'');
legend(leg_labels);

subplot(2,1,2);
hold on;
for n = 1:num_neurons
  offset = (n-1) * 2;
  plot(dff(n,:) + offset, ''LineWidth'', 0.8);
end
hold off;
xlabel(''Frame Number'');
ylabel(''dF/F (offset)'');
title(''Normalized dF/F Traces'');
legend(leg_labels);

sgtitle(''Calcium Imaging: Fluorescence Traces'');',
  '["dF/F for each neuron: F0 = mean(traces(n,:)); dff(n,:) = (traces(n,:) - F0) / F0;","Offset traces vertically: plot(trace + offset) where offset = (n-1) * spacing.","Use hold on to plot multiple traces on the same axes."]',
  '[]',
  true);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (27, 3, 'Detect calcium transients',
  'Detect calcium transient events in the dF/F traces using thresholding.

1. Load calcium_data.mat, extract traces, orient as neurons×time
2. Compute dF/F for the first neuron only
3. Detect transients: find time points where dF/F exceeds 2 standard deviations above the mean
   - threshold = mean(dff) + 2 * std(dff)
   - transient_mask = dff > threshold
4. Count the number of threshold crossings (rising edges):
   - rising_edges = diff(transient_mask) == 1
   - num_events = sum(rising_edges)
5. Display: disp([''Threshold: '' num2str(threshold, ''%.3f'')])
   disp([''Detected events: '' num2str(num_events)])
6. Create a figure with 2 subplots:
   - Top: dF/F trace with horizontal line at threshold and dots at detected event onsets. Title: ''Calcium Transient Detection (Neuron 1)''. ylabel: ''dF/F''
   - Bottom: zoom into the first 500 frames (or less) showing the same. Title: ''Zoomed View (first 500 frames)''. ylabel: ''dF/F''
   - Both: xlabel: ''Frame Number''
7. Main title: ''Calcium Transient Detection''',
  '% Detect calcium transients
NEURO_DATA = ''/usr/share/neuroscience-data'';
data = load([NEURO_DATA ''/calcium_data.mat'']);

% Find fluorescence matrix
fnames = fieldnames(data);
max_numel = 0; ca_field = '''';
for i = 1:length(fnames)
  val = data.(fnames{i});
  if isnumeric(val) && ndims(val) == 2 && min(size(val)) > 1 && numel(val) > max_numel
    max_numel = numel(val); ca_field = fnames{i};
  end
end
traces = data.(ca_field);
[r, c] = size(traces);
if r > c, traces = traces''; end

% Compute dF/F for neuron 1
F = traces(1, :);
F0 = mean(F);
dff = (F - F0) / F0;

% Detect transients
% YOUR CODE HERE

% Count events
% YOUR CODE HERE

% Display results
% YOUR CODE HERE

% Plot
figure;
% YOUR CODE HERE
',
  'NEURO_DATA = ''/usr/share/neuroscience-data'';
data = load([NEURO_DATA ''/calcium_data.mat'']);

fnames = fieldnames(data);
max_numel = 0; ca_field = '''';
for i = 1:length(fnames)
  val = data.(fnames{i});
  if isnumeric(val) && ndims(val) == 2 && min(size(val)) > 1 && numel(val) > max_numel
    max_numel = numel(val); ca_field = fnames{i};
  end
end
traces = data.(ca_field);
[r, c] = size(traces);
if r > c, traces = traces''; end

F = traces(1, :);
F0 = mean(F);
dff = (F - F0) / F0;

threshold = mean(dff) + 2 * std(dff);
transient_mask = dff > threshold;

rising_edges = diff([0 transient_mask]) == 1;
event_onsets = find(rising_edges);
num_events = length(event_onsets);

disp([''Threshold: '' num2str(threshold, ''%.3f'')]);
disp([''Detected events: '' num2str(num_events)]);

frames = 1:length(dff);

figure;

subplot(2,1,1);
plot(frames, dff, ''b-'', ''LineWidth'', 0.8);
hold on;
plot([1 length(dff)], [threshold threshold], ''r--'', ''LineWidth'', 1.5);
if num_events > 0
  plot(event_onsets, dff(event_onsets), ''rv'', ''MarkerSize'', 6, ''MarkerFaceColor'', ''r'');
end
hold off;
xlabel(''Frame Number'');
ylabel(''dF/F'');
title(''Calcium Transient Detection (Neuron 1)'');
legend(''dF/F'', ''Threshold'', ''Events'');

zoom_end = min(500, length(dff));
subplot(2,1,2);
plot(frames(1:zoom_end), dff(1:zoom_end), ''b-'', ''LineWidth'', 0.8);
hold on;
plot([1 zoom_end], [threshold threshold], ''r--'', ''LineWidth'', 1.5);
zoom_events = event_onsets(event_onsets <= zoom_end);
if ~isempty(zoom_events)
  plot(zoom_events, dff(zoom_events), ''rv'', ''MarkerSize'', 8, ''MarkerFaceColor'', ''r'');
end
hold off;
xlabel(''Frame Number'');
ylabel(''dF/F'');
title(''Zoomed View (first 500 frames)'');

sgtitle(''Calcium Transient Detection'');',
  '["Threshold: threshold = mean(dff) + 2*std(dff). Mask: transient_mask = dff > threshold.","Rising edges: diff([0 transient_mask]) == 1 — prepend 0 to catch events at frame 1.","Plot event markers: plot(event_onsets, dff(event_onsets), ''rv'', ''MarkerFaceColor'', ''r'')"]',
  '[]',
  true);


-- ============================================
-- Lesson 28: Cross-Modal Neuroscience Capstone
-- ============================================
INSERT INTO lessons (id, phase, order_num, title, description, difficulty, estimated_minutes, content_md)
VALUES (28, 5, 5, 'Cross-Modal Neuroscience Capstone',
  'Load multiple real datasets, compare analysis techniques across recording modalities, and synthesize everything you have learned.',
  'advanced', 60,
  '# Cross-Modal Neuroscience Capstone

This is the **final lesson** of Synapse. You have gone from `disp(''Hello, World!'')` to analyzing real brain data. Now you will bring it all together.

In this capstone, you will work with **multiple real datasets simultaneously** — comparing how we analyze neural data across different recording techniques.

## The Big Picture

Each recording technique gives you a different window into the brain:

| Technique | Scale | What You See |
|-----------|-------|--------------|
| **Spike recordings** | Single neurons | When individual neurons fire |
| **EEG** | Whole brain (surface) | Aggregate electrical rhythms |
| **fMRI** | Whole brain (3D) | Which regions are active |
| **Calcium imaging** | Hundreds of neurons | Population activity patterns |

No single technique tells the whole story. Modern neuroscience often combines multiple modalities.

## What You Will Do

1. Load all four datasets
2. Apply the appropriate analysis to each
3. Compare results across modalities
4. Create a summary visualization

## Reflection

Think about what you have learned:
- **Phase 1:** MATLAB basics — variables, loops, arrays, functions
- **Phase 2:** Data manipulation — matrices, plotting, file I/O
- **Phase 3:** Signal processing — FFT, filtering, spectrograms
- **Phase 4:** Neuroscience — EEG, ERPs, spectral analysis, source localization concepts
- **Phase 5:** Real data — spikes, EEG, fMRI, calcium imaging

You now have the skills to start analyzing real data in a neuroscience lab. Let''s finish strong!');

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (28, 1, 'Multi-modal data inventory',
  'Load all four neuroscience datasets and create an inventory of what each contains.

1. Load all four files:
   - spike_data.mat
   - ssvep_data.mat
   - fmri_data.mat
   - calcium_data.mat
2. For each dataset, display:
   - Dataset name
   - Number of fields
   - For the largest numeric field: name, dimensions, value range (min/max), data type
3. Create a summary comparison:
   disp(''=== Cross-Modal Comparison ==='')
   For each dataset, display one line:
   ''[Dataset]: [largest field size] | range: [min] to [max]''
4. Display the total memory usage: sum up numel * 8 bytes (assuming double) for all numeric fields across all four datasets. Display in MB:
   disp([''Total data size: '' num2str(total_bytes / 1e6, ''%.1f'') '' MB''])',
  '% Cross-modal data inventory
NEURO_DATA = ''/usr/share/neuroscience-data'';

% Load all four datasets
datasets = struct();
datasets.spikes = load([NEURO_DATA ''/spike_data.mat'']);
datasets.ssvep = load([NEURO_DATA ''/ssvep_data.mat'']);
datasets.fmri = load([NEURO_DATA ''/fmri_data.mat'']);
datasets.calcium = load([NEURO_DATA ''/calcium_data.mat'']);

names = fieldnames(datasets);

% Analyze each dataset
% YOUR CODE HERE

% Summary comparison
disp(''=== Cross-Modal Comparison ==='');
% YOUR CODE HERE

% Total memory
% YOUR CODE HERE
',
  'NEURO_DATA = ''/usr/share/neuroscience-data'';

datasets = struct();
datasets.spikes = load([NEURO_DATA ''/spike_data.mat'']);
datasets.ssvep = load([NEURO_DATA ''/ssvep_data.mat'']);
datasets.fmri = load([NEURO_DATA ''/fmri_data.mat'']);
datasets.calcium = load([NEURO_DATA ''/calcium_data.mat'']);

names = fieldnames(datasets);
total_bytes = 0;
summary_info = {};

for d = 1:length(names)
  dname = names{d};
  ds = datasets.(dname);
  fnames = fieldnames(ds);

  disp([''=== '' upper(dname) '' ==='']);
  disp([''Fields: '' num2str(length(fnames))]);

  max_numel = 0;
  largest_name = '''';
  largest_val = [];

  for i = 1:length(fnames)
    val = ds.(fnames{i});
    if isnumeric(val)
      total_bytes = total_bytes + numel(val) * 8;
      if numel(val) > max_numel
        max_numel = numel(val);
        largest_name = fnames{i};
        largest_val = val;
      end
    end
  end

  if ~isempty(largest_val)
    disp([''  Largest: '' largest_name '' | size: '' num2str(size(largest_val)) ...
      '' | range: '' num2str(min(largest_val(:))) '' to '' num2str(max(largest_val(:))) ...
      '' | class: '' class(largest_val)]);
    summary_info{d} = [dname '': '' num2str(size(largest_val)) ...
      '' | range: '' num2str(min(largest_val(:)), ''%.2f'') ...
      '' to '' num2str(max(largest_val(:)), ''%.2f'')];
  end
  disp('''');
end

disp(''=== Cross-Modal Comparison ==='');
for d = 1:length(summary_info)
  disp(summary_info{d});
end

disp('''');
disp([''Total data size: '' num2str(total_bytes / 1e6, ''%.1f'') '' MB'']);',
  '["Use a struct with named fields to organize all four datasets: datasets.spikes, datasets.ssvep, etc.","Loop through dataset names with fieldnames(datasets), then through each dataset''s fields with fieldnames(ds).","Memory: numel(val) * 8 gives bytes for double arrays. Sum across all numeric fields."]',
  '[]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (28, 2, 'Cross-modal analysis comparison',
  'Perform a characteristic analysis on each dataset and display the key finding.

1. Load all four datasets
2. For each, apply the appropriate analysis:

   **Spikes:** Find the largest numeric field. Compute the mean firing rate (mean of all values). Display: ''Spikes — Mean response: [value]''

   **SSVEP:** Find the largest 2D field. Extract channel 1. Compute FFT, find peak frequency between 5-50 Hz (assume fs=1000 if no scalar field). Display: ''SSVEP — Peak frequency: [freq] Hz''

   **fMRI:** Find the largest field. Extract a single time series (center voxel for 4D, first row/col for 2D, limit to 200 points). Compute the standard deviation of percent signal change. Display: ''fMRI — PSC std dev: [value]%''

   **Calcium:** Find the largest 2D field. Compute dF/F for the first trace. Count threshold crossings (2 std above mean). Display: ''Calcium — Detected events: [N] (neuron 1)''

3. Display all results in a summary block with a header:
   ''=== Key Findings Across Modalities ===''',
  '% Cross-modal analysis comparison
NEURO_DATA = ''/usr/share/neuroscience-data'';

datasets = struct();
datasets.spikes = load([NEURO_DATA ''/spike_data.mat'']);
datasets.ssvep = load([NEURO_DATA ''/ssvep_data.mat'']);
datasets.fmri = load([NEURO_DATA ''/fmri_data.mat'']);
datasets.calcium = load([NEURO_DATA ''/calcium_data.mat'']);

results = {};

% --- Spike analysis ---
% YOUR CODE HERE

% --- SSVEP analysis ---
% YOUR CODE HERE

% --- fMRI analysis ---
% YOUR CODE HERE

% --- Calcium analysis ---
% YOUR CODE HERE

% Display summary
disp(''=== Key Findings Across Modalities ==='');
for i = 1:length(results)
  disp(results{i});
end
',
  'NEURO_DATA = ''/usr/share/neuroscience-data'';

datasets = struct();
datasets.spikes = load([NEURO_DATA ''/spike_data.mat'']);
datasets.ssvep = load([NEURO_DATA ''/ssvep_data.mat'']);
datasets.fmri = load([NEURO_DATA ''/fmri_data.mat'']);
datasets.calcium = load([NEURO_DATA ''/calcium_data.mat'']);

results = {};

% Helper: find largest numeric field
function [name, val] = find_largest(ds)
  fnames = fieldnames(ds);
  max_n = 0; name = ''''; val = [];
  for i = 1:length(fnames)
    v = ds.(fnames{i});
    if isnumeric(v) && numel(v) > max_n
      max_n = numel(v); name = fnames{i}; val = v;
    end
  end
end

% --- Spikes ---
[~, spike_val] = find_largest(datasets.spikes);
mean_rate = mean(spike_val(:));
results{end+1} = [''Spikes - Mean response: '' num2str(mean_rate, ''%.4f'')];

% --- SSVEP ---
ds = datasets.ssvep;
fnames = fieldnames(ds);
fs_eeg = 1000;
for i = 1:length(fnames)
  v = ds.(fnames{i});
  if isnumeric(v) && isscalar(v) && v > 0
    fs_eeg = v; break;
  end
end
[~, eeg_val] = find_largest(ds);
[r, c] = size(eeg_val);
if r < c
  ch1 = eeg_val(1,:);
else
  ch1 = eeg_val(:,1)'';
end
N = length(ch1);
fft_r = fft(ch1);
pow = abs(fft_r(1:N/2+1)).^2 / N;
freqs = (0:N/2) * fs_eeg / N;
search = freqs >= 5 & freqs <= 50;
pow_search = pow; pow_search(~search) = 0;
[~, pk] = max(pow_search);
results{end+1} = [''SSVEP - Peak frequency: '' num2str(freqs(pk), ''%.1f'') '' Hz''];

% --- fMRI ---
[~, fmri_val] = find_largest(datasets.fmri);
nd = ndims(fmri_val);
if nd > 2
  cx = round(size(fmri_val,1)/2);
  cy = round(size(fmri_val,2)/2);
  cz = round(size(fmri_val,3)/2);
  ts = squeeze(fmri_val(cx,cy,cz,:))'';
else
  [r,c] = size(fmri_val);
  if r < c, ts = fmri_val(1,:); else ts = fmri_val(:,1)''; end
end
if length(ts) > 200, ts = ts(1:200); end
psc = (ts - mean(ts)) / mean(ts) * 100;
results{end+1} = [''fMRI - PSC std dev: '' num2str(std(psc), ''%.2f'') ''%''];

% --- Calcium ---
[~, ca_val] = find_largest(datasets.calcium);
[r,c] = size(ca_val);
if r > c, ca_val = ca_val''; end
F = ca_val(1,:);
F0 = mean(F);
dff = (F - F0) / F0;
thresh = mean(dff) + 2*std(dff);
rising = diff([0 (dff > thresh)]) == 1;
results{end+1} = [''Calcium - Detected events: '' num2str(sum(rising)) '' (neuron 1)''];

disp(''=== Key Findings Across Modalities ==='');
for i = 1:length(results)
  disp(results{i});
end',
  '["Create a helper function to find the largest numeric field — you will reuse it for all four datasets.","For SSVEP: same FFT + peak-finding approach from Lesson 22. For fMRI: same center-voxel extraction from Lesson 23.","For calcium: same dF/F + threshold detection from Lesson 24. Use diff([0 mask]) == 1 for rising edges."]',
  '[]',
  false);

INSERT INTO exercises (lesson_id, order_num, title, prompt, starter_code, solution, hints, test_cases, requires_plot)
VALUES (28, 3, 'Final capstone visualization',
  'Create a final multi-panel figure comparing all four modalities.

1. Load all four datasets and perform the analyses from Exercise 2
2. Create a 2×2 figure (figure position: [50, 50, 1200, 800]):

   **Panel (1,1) — Spikes:** Plot the mean response profile (mean across first dimension of the largest field). Title: ''Spike Data: Mean Response''. ylabel: ''Response''. xlabel: ''Index''.

   **Panel (1,2) — SSVEP:** Plot the power spectrum (1-60 Hz) of channel 1. Title: ''SSVEP: Power Spectrum (Ch 1)''. ylabel: ''Power''. xlabel: ''Frequency (Hz)''.

   **Panel (2,1) — fMRI:** Plot the percent signal change time series. Title: ''fMRI: Percent Signal Change''. ylabel: ''% Change''. xlabel: ''Time Point''.

   **Panel (2,2) — Calcium:** Plot the dF/F trace of neuron 1 with threshold line and event markers. Title: ''Calcium: dF/F with Events''. ylabel: ''dF/F''. xlabel: ''Frame''.

3. Main title: ''Synapse Capstone: Four Modalities of Neural Data''
4. After the figure, display a congratulations message:
   disp(''Congratulations! You have completed all 25 lessons of Synapse.'')
   disp(''You can now analyze real neuroscience data in MATLAB.'')',
  '% Final Capstone Visualization
NEURO_DATA = ''/usr/share/neuroscience-data'';

% Load all datasets
spikes = load([NEURO_DATA ''/spike_data.mat'']);
ssvep = load([NEURO_DATA ''/ssvep_data.mat'']);
fmri_ds = load([NEURO_DATA ''/fmri_data.mat'']);
calcium = load([NEURO_DATA ''/calcium_data.mat'']);

% Helper: find largest numeric field
function [name, val] = find_largest(ds)
  fnames = fieldnames(ds);
  max_n = 0; name = ''''; val = [];
  for i = 1:length(fnames)
    v = ds.(fnames{i});
    if isnumeric(v) && numel(v) > max_n
      max_n = numel(v); name = fnames{i}; val = v;
    end
  end
end

figure(''Position'', [50, 50, 1200, 800]);

% Panel 1: Spikes
% YOUR CODE HERE

% Panel 2: SSVEP
% YOUR CODE HERE

% Panel 3: fMRI
% YOUR CODE HERE

% Panel 4: Calcium
% YOUR CODE HERE

sgtitle(''Synapse Capstone: Four Modalities of Neural Data'');

disp(''Congratulations! You have completed all 25 lessons of Synapse.'');
disp(''You can now analyze real neuroscience data in MATLAB.'');
',
  'NEURO_DATA = ''/usr/share/neuroscience-data'';

spikes = load([NEURO_DATA ''/spike_data.mat'']);
ssvep = load([NEURO_DATA ''/ssvep_data.mat'']);
fmri_ds = load([NEURO_DATA ''/fmri_data.mat'']);
calcium = load([NEURO_DATA ''/calcium_data.mat'']);

function [name, val] = find_largest(ds)
  fnames = fieldnames(ds);
  max_n = 0; name = ''''; val = [];
  for i = 1:length(fnames)
    v = ds.(fnames{i});
    if isnumeric(v) && numel(v) > max_n
      max_n = numel(v); name = fnames{i}; val = v;
    end
  end
end

figure(''Position'', [50, 50, 1200, 800]);

% Panel 1: Spikes
subplot(2,2,1);
[~, spike_val] = find_largest(spikes);
mean_spike = mean(spike_val, 1);
plot(mean_spike, ''b-'', ''LineWidth'', 1.2);
xlabel(''Index'');
ylabel(''Response'');
title(''Spike Data: Mean Response'');

% Panel 2: SSVEP
subplot(2,2,2);
fnames = fieldnames(ssvep);
fs_eeg = 1000;
for i = 1:length(fnames)
  v = ssvep.(fnames{i});
  if isnumeric(v) && isscalar(v) && v > 0
    fs_eeg = v; break;
  end
end
[~, eeg_val] = find_largest(ssvep);
[r, c] = size(eeg_val);
if r < c, ch1 = eeg_val(1,:); else ch1 = eeg_val(:,1)''; end
N = length(ch1);
fft_r = fft(ch1);
pow = abs(fft_r(1:N/2+1)).^2 / N;
freqs = (0:N/2) * fs_eeg / N;
idx = freqs >= 1 & freqs <= 60;
plot(freqs(idx), pow(idx), ''r-'', ''LineWidth'', 1.2);
xlabel(''Frequency (Hz)'');
ylabel(''Power'');
title(''SSVEP: Power Spectrum (Ch 1)'');

% Panel 3: fMRI
subplot(2,2,3);
[~, fmri_val] = find_largest(fmri_ds);
nd = ndims(fmri_val);
if nd > 2
  cx = round(size(fmri_val,1)/2);
  cy = round(size(fmri_val,2)/2);
  cz = round(size(fmri_val,3)/2);
  ts = squeeze(fmri_val(cx,cy,cz,:))'';
else
  [r,c] = size(fmri_val);
  if r < c, ts = fmri_val(1,:); else ts = fmri_val(:,1)''; end
end
if length(ts) > 200, ts = ts(1:200); end
psc = (ts - mean(ts)) / mean(ts) * 100;
plot(psc, ''Color'', [0.2 0.6 0.2], ''LineWidth'', 1.2);
hold on;
plot([1 length(psc)], [0 0], ''k--'');
hold off;
xlabel(''Time Point'');
ylabel(''% Change'');
title(''fMRI: Percent Signal Change'');

% Panel 4: Calcium
subplot(2,2,4);
[~, ca_val] = find_largest(calcium);
[r,c] = size(ca_val);
if r > c, ca_val = ca_val''; end
F = ca_val(1,:);
F0 = mean(F);
dff = (F - F0) / F0;
thresh = mean(dff) + 2*std(dff);
rising = diff([0 (dff > thresh)]) == 1;
events = find(rising);

plot(dff, ''m-'', ''LineWidth'', 0.8);
hold on;
plot([1 length(dff)], [thresh thresh], ''k--'', ''LineWidth'', 1);
if ~isempty(events)
  plot(events, dff(events), ''kv'', ''MarkerSize'', 5, ''MarkerFaceColor'', ''k'');
end
hold off;
xlabel(''Frame'');
ylabel(''dF/F'');
title(''Calcium: dF/F with Events'');

sgtitle(''Synapse Capstone: Four Modalities of Neural Data'');

disp(''Congratulations! You have completed all 25 lessons of Synapse.'');
disp(''You can now analyze real neuroscience data in MATLAB.'');',
  '["Reuse the find_largest helper for all four datasets. Each panel applies the same analysis from Exercises in Lessons 21-24.","For spikes: mean(spike_val, 1) averages across trials. For SSVEP: FFT of channel 1.","For fMRI: extract center voxel, compute PSC. For calcium: dF/F + threshold + event detection."]',
  '[]',
  true);


-- Reset sequences
SELECT setval('lessons_id_seq', (SELECT MAX(id) FROM lessons));
SELECT setval('exercises_id_seq', (SELECT MAX(id) FROM exercises));
