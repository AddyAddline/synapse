{
  "phase": 4,
  "order_num": 9,
  "title": "From Simulated to Real Data",
  "description": "Learn what makes real data different from simulated data, and build a toolkit for inspecting, cleaning, and navigating messy datasets.",
  "difficulty": "advanced",
  "estimated_minutes": 30,
  "content_md": "# From Simulated to Real Data\n\nEverything you have worked with so far used **simulated data** — clean, predictable signals that you generated yourself. Real neuroscience data is different.\n\n## Simulated vs. Real: Side by Side\n\n**Simulated sine wave:**\n```matlab\nt = 0:0.001:1;\nclean = sin(2*pi*10*t);\n```\nPerfect. Exactly 10 Hz. No noise. Every time.\n\n**Real EEG data:**\n- Noisy baseline\n- Artifacts from eye blinks and muscle movements\n- Varies from trial to trial\n- Might contain NaN values from bad channels\n- Unexpected dimensions\n\n## Common Real-Data Surprises\n\n### 1. NaN Values\nBad channels or rejected trials often get replaced with NaN (Not a Number). Any operation involving NaN gives NaN:\n```matlab\nmean([1 2 NaN 4])  % Returns NaN!\nnanmean([1 2 NaN 4])  % Returns 2.333 (ignores NaN)\n```\n\n### 2. Varying Lengths\nTrials might have different durations. You cannot stack them into a matrix without padding or trimming.\n\n### 3. Unexpected Dimensions\nYou expect a 64×1000 matrix (64 channels × 1000 timepoints) but get 1000×64. Always check with `size()`.\n\n### 4. Missing Channels\nSome channels might be missing entirely, shifting all the indices.\n\n## The Data Inspection Checklist\n\nBefore analyzing ANY dataset, always run:\n```matlab\nsize(data)        % How big is it?\nclass(data)       % What type is it?\nmin(data(:))      % What is the range?\nmax(data(:))\nany(isnan(data(:)))  % Any NaN values?\nany(isinf(data(:)))  % Any infinite values?\n```\n\n## Working with Structs\n\nReal .mat files often contain **structs** — containers with named fields:\n```matlab\ndata = load('experiment.mat');\nfieldnames(data)           % What fields exist?\ndata.eeg                    % Access a field\ndata.params.sampling_rate   % Nested struct access\n```\n\nUse `fieldnames()` to explore, and dot notation to access.\n\n## The Golden Rule of Real Data\n\n**Always plot your data first.** Before any analysis, just look at it. You will catch more problems with your eyes than with any automated check.\n\nLet's practice working with messy data!",
  "exercises": [
    {
      "order_num": 1,
      "title": "Data inspection",
      "prompt": "Load a simulated 'messy' dataset and identify all issues.\n\nThe code below creates a dataset with several problems hidden in it. Your job is to find them all.\n\n1. Run the setup code that creates the messy data\n2. Write an inspection function that checks for:\n   - Size and dimensions\n   - Data type (class)\n   - NaN values (count them)\n   - Inf values (count them)\n   - Value range (min/max)\n   - Outliers (values more than 5 standard deviations from the mean, after removing NaN/Inf)\n3. Display a clear report for each check\n4. At the end, summarize: 'Found N issues' where N is the count of problems found (NaN count > 0 is 1 issue, Inf count > 0 is another, outlier count > 0 is another)",
      "starter_code": "% Data inspection exercise\n% This creates a 'messy' dataset simulating real-world problems\nrand('state', 42);\n\n% Simulated 8-channel, 500-timepoint EEG data\neeg = randn(8, 500) * 50;  % Normal EEG-like values\n\n% Problem 1: Channel 3 has NaN values (bad channel)\neeg(3, 100:150) = NaN;\n\n% Problem 2: A few Inf values (artifact)\neeg(5, 200) = Inf;\neeg(5, 201) = -Inf;\n\n% Problem 3: Channel 7 has an extreme outlier\neeg(7, 300) = 50000;  % Way outside normal range\n\n% Problem 4: Channel 1 has a DC offset\neeg(1, :) = eeg(1, :) + 1000;\n\n% Now inspect this data and find all problems\ndisp('=== Data Inspection Report ===');\n% YOUR CODE HERE\n",
      "solution": "rand('state', 42);\n\neeg = randn(8, 500) * 50;\neeg(3, 100:150) = NaN;\neeg(5, 200) = Inf;\neeg(5, 201) = -Inf;\neeg(7, 300) = 50000;\neeg(1, :) = eeg(1, :) + 1000;\n\ndisp('=== Data Inspection Report ===');\nissue_count = 0;\n\n% Size and type\ndisp(['Size: ' num2str(size(eeg))]);\ndisp(['Class: ' class(eeg)]);\ndisp(['Channels: ' num2str(size(eeg,1)) ', Timepoints: ' num2str(size(eeg,2))]);\n\n% NaN check\nnan_count = sum(isnan(eeg(:)));\ndisp(['NaN values: ' num2str(nan_count)]);\nif nan_count > 0\n  issue_count = issue_count + 1;\n  for ch = 1:size(eeg,1)\n    ch_nans = sum(isnan(eeg(ch,:)));\n    if ch_nans > 0\n      disp(['  Channel ' num2str(ch) ': ' num2str(ch_nans) ' NaN values']);\n    end\n  end\nend\n\n% Inf check\ninf_count = sum(isinf(eeg(:)));\ndisp(['Inf values: ' num2str(inf_count)]);\nif inf_count > 0\n  issue_count = issue_count + 1;\n  for ch = 1:size(eeg,1)\n    ch_infs = sum(isinf(eeg(ch,:)));\n    if ch_infs > 0\n      disp(['  Channel ' num2str(ch) ': ' num2str(ch_infs) ' Inf values']);\n    end\n  end\nend\n\n% Value range\nclean = eeg(~isnan(eeg) & ~isinf(eeg));\ndisp(['Min (clean): ' num2str(min(clean))]);\ndisp(['Max (clean): ' num2str(max(clean))]);\ndisp(['Mean (clean): ' num2str(mean(clean), '%.2f')]);\ndisp(['Std (clean): ' num2str(std(clean), '%.2f')]);\n\n% Outlier check (>5 std from mean)\nthresh = 5 * std(clean);\nmu = mean(clean);\nfor ch = 1:size(eeg,1)\n  ch_data = eeg(ch,:);\n  ch_clean = ch_data(~isnan(ch_data) & ~isinf(ch_data));\n  outliers = sum(abs(ch_clean - mu) > thresh);\n  if outliers > 0\n    disp(['  Channel ' num2str(ch) ': ' num2str(outliers) ' outlier(s)']);\n  end\nend\nif any(abs(clean - mu) > thresh)\n  issue_count = issue_count + 1;\nend\n\n% Channel mean check (DC offset)\ndisp('');\ndisp('Channel means:');\nfor ch = 1:size(eeg,1)\n  ch_data = eeg(ch,:);\n  ch_clean = ch_data(~isnan(ch_data) & ~isinf(ch_data));\n  ch_mean = mean(ch_clean);\n  flag = '';\n  if abs(ch_mean) > 100\n    flag = ' << DC OFFSET DETECTED';\n    issue_count = issue_count + 1;\n  end\n  disp(['  Channel ' num2str(ch) ': mean = ' num2str(ch_mean, '%.1f') flag]);\nend\n\ndisp('');\ndisp(['Found ' num2str(issue_count) ' issues']);",
      "hints": [
        "Use isnan() and isinf() to find NaN and Inf values. sum(isnan(eeg(:))) counts total NaNs.",
        "For outlier detection: compute mean and std of clean data, then flag anything > 5*std from the mean.",
        "Check per-channel means to find DC offsets — a mean far from 0 indicates a problem."
      ],
      "test_cases": [],
      "requires_plot": false
    },
    {
      "order_num": 2,
      "title": "Data cleaning pipeline",
      "prompt": "Write a function that takes messy EEG data and returns clean data.\n\nYour clean_eeg function should:\n1. Take raw EEG matrix (channels × timepoints) as input\n2. Report the original size\n3. Identify and reject bad channels (>20% NaN or any Inf values)\n4. For remaining channels, replace isolated NaN values with interpolation (use the mean of neighbors, or just use nanmean of the channel)\n5. Remove outlier timepoints (any timepoint where ANY channel exceeds 5 std)\n6. Return the cleaned data and display a summary:\n   - Channels removed\n   - NaN values replaced\n   - Timepoints removed\n   - Final data size\n\nTest with the messy data from Exercise 1.",
      "starter_code": "% Data cleaning pipeline\nrand('state', 42);\n\n% Create messy data\neeg = randn(8, 500) * 50;\neeg(3, 100:150) = NaN;\neeg(5, 200) = Inf;\neeg(5, 201) = -Inf;\neeg(7, 300) = 50000;\neeg(1, :) = eeg(1, :) + 1000;\n\n% Define clean_eeg function\n% YOUR CODE HERE\n\n% Run the cleaning pipeline\nclean = clean_eeg(eeg);\ndisp(['Final clean data size: ' num2str(size(clean))]);\n",
      "solution": "rand('state', 42);\n\neeg = randn(8, 500) * 50;\neeg(3, 100:150) = NaN;\neeg(5, 200) = Inf;\neeg(5, 201) = -Inf;\neeg(7, 300) = 50000;\neeg(1, :) = eeg(1, :) + 1000;\n\nfunction cleaned = clean_eeg(data)\n  [nch, ntp] = size(data);\n  disp(['Original size: ' num2str(nch) ' channels x ' num2str(ntp) ' timepoints']);\n\n  % Step 1: Identify bad channels\n  bad_channels = [];\n  for ch = 1:nch\n    nan_pct = sum(isnan(data(ch,:))) / ntp;\n    has_inf = any(isinf(data(ch,:)));\n    if nan_pct > 0.2 || has_inf\n      bad_channels(end+1) = ch;\n    end\n  end\n\n  if ~isempty(bad_channels)\n    disp(['Removing bad channels: ' num2str(bad_channels)]);\n    data(bad_channels, :) = [];\n  end\n\n  [nch, ntp] = size(data);\n\n  % Step 2: Replace remaining NaN values with channel mean\n  nan_replaced = 0;\n  for ch = 1:nch\n    nan_idx = isnan(data(ch,:));\n    if any(nan_idx)\n      ch_mean = nanmean(data(ch,:));\n      data(ch, nan_idx) = ch_mean;\n      nan_replaced = nan_replaced + sum(nan_idx);\n    end\n  end\n  disp(['NaN values replaced: ' num2str(nan_replaced)]);\n\n  % Step 3: Remove outlier timepoints\n  overall_std = std(data(:));\n  overall_mean = mean(data(:));\n  thresh = 5 * overall_std;\n  bad_timepoints = false(1, ntp);\n  for t = 1:ntp\n    if any(abs(data(:,t) - overall_mean) > thresh)\n      bad_timepoints(t) = true;\n    end\n  end\n  removed_tp = sum(bad_timepoints);\n  data(:, bad_timepoints) = [];\n  disp(['Timepoints removed (outliers): ' num2str(removed_tp)]);\n\n  disp(['Final size: ' num2str(size(data,1)) ' channels x ' num2str(size(data,2)) ' timepoints']);\n  cleaned = data;\nend\n\nclean = clean_eeg(eeg);\ndisp(['Final clean data size: ' num2str(size(clean))]);",
      "hints": [
        "Check each channel: if NaN% > 20% or has Inf → mark as bad. Remove all bad channels at once.",
        "For NaN replacement: nanmean(data(ch,:)) gives the channel mean ignoring NaNs. Replace NaN positions with this value.",
        "For outlier removal: compute global std, then check each timepoint — if ANY channel exceeds 5*std, remove that timepoint."
      ],
      "test_cases": [],
      "requires_plot": false
    },
    {
      "order_num": 3,
      "title": "Struct navigation",
      "prompt": "Navigate a nested struct (mimicking a real .mat file) and extract specific information.\n\nThe code below creates a nested struct similar to what you would find in a real experiment file. Extract the requested information.\n\n1. The struct is already created for you\n2. Display the top-level field names\n3. Navigate to experiment.params and display all parameter names and values\n4. Extract the EEG data from experiment.data.eeg and display its size\n5. Extract channel names from experiment.data.channel_names and display them\n6. Compute the mean signal for the channel named 'Oz' (find its index first)\n7. Display:\n   - 'Subject: [id]'\n   - 'Sampling rate: [rate] Hz'\n   - 'Channels: [count]'\n   - 'Duration: [timepoints/sampling_rate] seconds'\n   - 'Oz channel mean: [value]'",
      "starter_code": "% Struct navigation exercise\n% This creates a realistic nested struct\nrand('state', 42);\n\nexperiment = struct();\nexperiment.subject_id = 'S001';\nexperiment.date = '2024-03-15';\nexperiment.params = struct();\nexperiment.params.sampling_rate = 256;\nexperiment.params.filter_low = 0.5;\nexperiment.params.filter_high = 40;\nexperiment.params.reference = 'average';\nexperiment.data = struct();\nexperiment.data.eeg = randn(6, 1280) * 30;  % 6 channels, 5 seconds at 256 Hz\nexperiment.data.channel_names = {'Fz', 'Cz', 'Pz', 'Oz', 'F3', 'F4'};\nexperiment.data.events = struct();\nexperiment.data.events.times = [0.5, 1.5, 2.5, 3.5];\nexperiment.data.events.labels = {'stim', 'stim', 'stim', 'stim'};\n\n% Navigate and extract information\n% YOUR CODE HERE\n",
      "solution": "rand('state', 42);\n\nexperiment = struct();\nexperiment.subject_id = 'S001';\nexperiment.date = '2024-03-15';\nexperiment.params = struct();\nexperiment.params.sampling_rate = 256;\nexperiment.params.filter_low = 0.5;\nexperiment.params.filter_high = 40;\nexperiment.params.reference = 'average';\nexperiment.data = struct();\nexperiment.data.eeg = randn(6, 1280) * 30;\nexperiment.data.channel_names = {'Fz', 'Cz', 'Pz', 'Oz', 'F3', 'F4'};\nexperiment.data.events = struct();\nexperiment.data.events.times = [0.5, 1.5, 2.5, 3.5];\nexperiment.data.events.labels = {'stim', 'stim', 'stim', 'stim'};\n\n% Top-level fields\ndisp('=== Top-level fields ===');\ndisp(fieldnames(experiment));\n\n% Parameters\ndisp('=== Parameters ===');\npnames = fieldnames(experiment.params);\nfor i = 1:length(pnames)\n  val = experiment.params.(pnames{i});\n  if isnumeric(val)\n    disp([pnames{i} ': ' num2str(val)]);\n  else\n    disp([pnames{i} ': ' val]);\n  end\nend\n\n% EEG data\neeg = experiment.data.eeg;\ndisp('');\ndisp(['EEG size: ' num2str(size(eeg))]);\n\n% Channel names\nch_names = experiment.data.channel_names;\ndisp('Channels:');\nfor i = 1:length(ch_names)\n  disp(['  ' num2str(i) ': ' ch_names{i}]);\nend\n\n% Find Oz channel\noz_idx = 0;\nfor i = 1:length(ch_names)\n  if strcmp(ch_names{i}, 'Oz')\n    oz_idx = i;\n    break;\n  end\nend\n\nfs = experiment.params.sampling_rate;\noz_mean = mean(eeg(oz_idx, :));\n\ndisp('');\ndisp(['Subject: ' experiment.subject_id]);\ndisp(['Sampling rate: ' num2str(fs) ' Hz']);\ndisp(['Channels: ' num2str(size(eeg, 1))]);\ndisp(['Duration: ' num2str(size(eeg, 2) / fs) ' seconds']);\ndisp(['Oz channel mean: ' num2str(oz_mean, '%.4f')]);",
      "hints": [
        "Access nested fields with dot notation: experiment.params.sampling_rate",
        "Channel names are in a cell array — use strcmp(ch_names{i}, 'Oz') to find the Oz channel index.",
        "Duration in seconds = number of timepoints / sampling rate"
      ],
      "test_cases": [],
      "requires_plot": false
    }
  ]
}
